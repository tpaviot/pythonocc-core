###############################################

# X3D Package for Python x3d.py

# generator:  X3duomToX3dPythonPackage.xslt
# X3DUOM:     X3dUnifiedObjectModel-4.0.xml
# Python X3D: https://www.web3d.org/x3d/stylesheets/python/python.html
"""
The x3d.py Python X3D Package supports programmers with Python interfaces and objects for standards-based X3D programming, all as open source.

This work is part of the X3D Python Scene Access Interface Library (X3DPSAIL).
"""

_DEBUG = True       # options True False

###############################################

# SimpleType Enumerations

ACCESSTYPECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'initializeOnly', # A field with accessType initializeOnly can be initialized, but cannot send or receive events.
    'inputOnly', # A field with accessType inputOnly cannot be initialized or included in a scene file, but can receive input event values via a ROUTE.
    'outputOnly', # A field with accessType outputOnly cannot be initialized or included in a scene file, but can send output event values via a ROUTE.
    'inputOutput' # A field with accessType inputOutput can be initialized, and can also send or receive events.
)
def assertValidAccessType(fieldName, value):
    """
    Utility function to assert type validity of accessTypeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in ACCESSTYPECHOICES:
        # print ('*** assertValidAccessType ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in ACCESSTYPECHOICES:
        # print ('*** assertValidAccessType ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in ACCESSTYPECHOICES=' + str(ACCESSTYPECHOICES))

APPLIEDPARAMETERSCHOICES = (
    # note these MFString values use XML syntax
    # strict set of allowed values follow, no other values are valid
    '"BOUNCE"', # The bounce field value is used.
    '"USER_FRICTION"', # The system will normally calculate the friction direction vector that is perpendicular to the contact normal. This setting indicates that the user-supplied value in this contact should be used.
    '"FRICTION_COEFFICIENT-2"', # Apply frictionCoefficients values
    '"ERROR_REDUCTION"', # Apply softnessErrorCorrection value
    '"CONSTANT_FORCE"', # Apply softnessConstantForceMix value
    '"SPEED-1"', # Apply first component of surfaceSpeed array
    '"SPEED-2"', # Apply second component of surfaceSpeed array
    '"SLIP-1"', # Apply first component of slipFactors array
    '"SLIP-2"' # Apply second component of slipFactors array
)
def assertValidAppliedParameters(fieldName, value):
    """
    Utility function to assert type validity of appliedParametersChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in APPLIEDPARAMETERSCHOICES:
        # print ('*** assertValidAppliedParameters ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in APPLIEDPARAMETERSCHOICES:
        # print ('*** assertValidAppliedParameters ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in APPLIEDPARAMETERSCHOICES=' + str(APPLIEDPARAMETERSCHOICES))

BIQUADTYPEFILTERCHOICES = (
    # strict set of allowed values follow, no other values are valid
    'lowpass',
    'highpass',
    'bandpass',
    'lowshelf',
    'highshelf',
    'peaking',
    'notch',
    'allpass'
)
def assertValidBiquadTypeFilter(fieldName, value):
    """
    Utility function to assert type validity of biquadTypeFilterChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in BIQUADTYPEFILTERCHOICES:
        # print ('*** assertValidBiquadTypeFilter ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in BIQUADTYPEFILTERCHOICES:
        # print ('*** assertValidBiquadTypeFilter ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in BIQUADTYPEFILTERCHOICES=' + str(BIQUADTYPEFILTERCHOICES))

CHANNELCOUNTMODECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'max',
    'clamped-max',
    'explicit'
)
def assertValidChannelCountMode(fieldName, value):
    """
    Utility function to assert type validity of channelCountModeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in CHANNELCOUNTMODECHOICES:
        # print ('*** assertValidChannelCountMode ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in CHANNELCOUNTMODECHOICES:
        # print ('*** assertValidChannelCountMode ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in CHANNELCOUNTMODECHOICES=' + str(CHANNELCOUNTMODECHOICES))

CHANNELINTERPRETATIONCHOICES = (
    # strict set of allowed values follow, no other values are valid
    'speakers',
    'discrete'
)
def assertValidChannelInterpretation(fieldName, value):
    """
    Utility function to assert type validity of channelInterpretationChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in CHANNELINTERPRETATIONCHOICES:
        # print ('*** assertValidChannelInterpretation ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in CHANNELINTERPRETATIONCHOICES:
        # print ('*** assertValidChannelInterpretation ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in CHANNELINTERPRETATIONCHOICES=' + str(CHANNELINTERPRETATIONCHOICES))

CLOSURETYPECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'PIE', # Connects arc endpoints to center, forming a pie wedge
    'CHORD' # Connects arc endpoints directly to each other, as in chord on a circle
)
def assertValidClosureType(fieldName, value):
    """
    Utility function to assert type validity of closureTypeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in CLOSURETYPECHOICES:
        # print ('*** assertValidClosureType ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in CLOSURETYPECHOICES:
        # print ('*** assertValidClosureType ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in CLOSURETYPECHOICES=' + str(CLOSURETYPECHOICES))

COMPONENTNAMECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'Core', # The Core component supplies the base functionality for the X3D run-time system, including the abstract base node type, field types, the event model, and routing.
    'CADGeometry', # The CADGeometry component is provided for Computer-Aided Design (CAD) nodes.
    'CubeMapTexturing', # The Cube Map Environmental Texturing component describes how additional texturing effects are defined to produce environmental effects such as reflections from objects.
    'DIS', # The Distributed Interactive Simulation (DIS) component provides networked interoperability with the IEEE DIS protocol for sharing state and conducting real-time platform-level simulations across multiple host computers.
    'EnvironmentalEffects', # Nodes in the Environmental effects component support the creation of realistic environmental effects such as panoramic backgrounds and fog.
    'EnvironmentalSensor', # The Environment Sensor nodes emit events indicating activity in the scene environment, usually based on interactions between the viewer and the world.
    'EventUtilities', # The Event Utility nodes provide the capability to filter, trigger, convert, or sequence numerous event-types for common interactive applications without the use of a Script node.
    'Followers', # The Follower nodes (Chasers and Dampers) support dynamic creation of smooth parameter transitions at run time.
    'Geometry2D', # The Geometry2D component defines how two-dimensional geometry is specified and what shapes are available.
    'Geometry3D', # The Geometry3D component describes how three-dimensional geometry is specified and defines ElevationGrid, Extrusion, IndexedFaceSet, and most primitive geometry nodes (Box, Cone, Cylinder, Sphere).
    'Geospatial', # The Geospatial component defines how to associate real-world locations in an X3D scene and specifies nodes particularly tuned for geospatial applications.
    'Grouping', # The Grouping component describes how nodes are organized into groups to establish a transformation hierarchy for the X3D scene graph.
    'HAnim', # The Humanoid Animation (HAnim) component for X3D defines node bindings and other details for implementing ISO/IEC 19774, the HAnim International Specification. Original name was H-Anim for X3D versions 3.0 through 3.3, both enumeration values HAnim and H-Anim are allowed to pass validation.
    'H-Anim', # Legacy enumeration H-Anim for X3D versions 3.0-3.3 provides backwards compatibility with Humanoid Animation (HAnim) version 1, preferred form of enumeration value is HAnim.
    'Interpolation', # Interpolator nodes provide keyframe-based animation capability.
    'KeyDeviceSensor', # The Key Device Sensor defines how keyboard keystrokes are inserted into an X3D world.
    'Layering', # The Layering component describes how to layer a set of subscene layers into a composite scene.
    'Layout', # The Layout component defines how to precisely position content in a scene in relation to the rendered results, especially for integrating 2D content with 3D content.
    'Lighting', # The Lighting component specifies how light sources are defined and positioned, as well as how lights effect the rendered image.
    'Navigation', # The Navigation component specifies how a user can effectively and intuitively move through and around a 3D scene.
    'Networking', # The Networking component defines node types and other features used to access file-based and streaming resources on the World Wide Web.
    'NURBS', # The NURBS component describes Non-uniform Rational B-Spline (NURBS) geometry and interpolation nodes.
    'ParticleSystems', # The Particle Systems component specifies how to model particles and their interactions through the application of basic physics principles to affect motion.
    'Picking', # The Picking component provides the ability to test for arbitrary object collision and provide basic capabilities to detecting object intersections and interactions.
    'PointingDeviceSensor', # Pointing device sensor nodes detect pointing events from user-interface devices, defining activities such as a user selecting a piece of geometry.
    'TextureProjector', # Projective texture mapping nodes project textures onto geometry in a scene.
    'Rendering', # The Rendering component includes fundamental rendering primitives such as TriangleSet and PointSet nodes, as well as geometric properties nodes that define how coordinate indices, colors, normals and texture coordinates are specified.
    'RigidBodyPhysics', # The Rigid Body Physics component describes how to model rigid bodies and their interactions through the application of basic physics principles to effect motion.
    'Scripting', # The Script component describes how Script nodes are used to effect changes in X3D worlds.
    'Shaders', # The programmable shaders component describes how programmable shaders are specified and how they affect the visual appearance of geometry.
    'Shape', # The Shape component defines nodes for associating geometry with their visible properties and the scene environment.
    'Sound', # The Sound component defines how sound is delivered to an X3D world as well as how sounds are accessed.
    'Text', # The Text component defines how text strings are rendered in an X3D scene.
    'Texturing', # The Texturing component specifies how 2D texture images are defined and then positioned on associated geometry.
    'Texturing3D', # The Texturing3D component specifies how 3D volumetric textures describe surface properties as data points in a volume of space, rather than a flat surface.
    'Time', # The Time component defines how time is sensed, computed and associated with events in an X3D scene.
    'VolumeRendering' # The Volume Rendering component provides the ability to specify and render volumetric data sets.
)
def assertValidComponentName(fieldName, value):
    """
    Utility function to assert type validity of componentNameChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in COMPONENTNAMECHOICES:
        # print ('*** assertValidComponentName ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in COMPONENTNAMECHOICES:
        # print ('*** assertValidComponentName ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in COMPONENTNAMECHOICES=' + str(COMPONENTNAMECHOICES))

DISTANCEMODELCHOICES = (
    # strict set of allowed values follow, no other values are valid
    'linear',
    'inverse',
    'exponential'
)
def assertValidDistanceModel(fieldName, value):
    """
    Utility function to assert type validity of distanceModelChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in DISTANCEMODELCHOICES:
        # print ('*** assertValidDistanceModel ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in DISTANCEMODELCHOICES:
        # print ('*** assertValidDistanceModel ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in DISTANCEMODELCHOICES=' + str(DISTANCEMODELCHOICES))

FIELDTYPECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'SFBool', # Single Field (singleton) Boolean
    'MFBool', # Multiple Field (list) Boolean
    'SFColor', # Single Field (singleton) color value, red-green-blue
    'MFColor', # Multiple Field (list) color value, red-green-blue
    'SFColorRGBA', # Single Field (singleton) color value, red-green-blue alpha (opacity)
    'MFColorRGBA', # Multiple Field (list) color value, red-green-blue alpha (opacity)
    'SFDouble', # Single Field (singleton) double-precision (64-bit) float
    'MFDouble', # Multiple Field (list) 2-tuple double-precision (64-bit) float vector
    'SFFloat', # Single Field (singleton) single-precision (32-bit) float
    'MFFloat', # Multiple Field (list) single-precision (32-bit) float vector
    'SFImage', # Single Field (singleton) image value
    'MFImage', # Multiple Field (list) image values
    'SFInt32', # Single Field (singleton) 32-bit integer
    'MFInt32', # Multiple Field (list) 32-bit integer
    'SFNode', # Single Field (singleton) node
    'MFNode', # Multiple Field (list) nodes
    'SFRotation', # Single Field (singleton) rotation value using 3-tuple axis, radian angle
    'MFRotation', # Multiple Field (list) rotation values using 3-tuple axis, radian angle
    'SFString', # Single Field (singleton) string value
    'MFString', # Multiple Field (list) SFString array
    'SFTime', # Single Field (singleton) time value in seconds
    'MFTime', # Multiple Field (list) time array in seconds
    'SFVec2d', # Single Field (singleton) 2-tuple double-precision float vector
    'MFVec2d', # Multiple Field (list) 2-tuple double-precision float vectors
    'SFVec2f', # Single Field (singleton) 2-tuple single-precision float vector
    'MFVec2f', # Multiple Field (list) 2-tuple single-precision float vectors
    'SFVec3d', # Single Field (singleton) 3-tuple double-precision float vector
    'MFVec3d', # Multiple Field (list) 3-tuple double-precision float vectors
    'SFVec3f', # Single Field (singleton) 3-tuple single-precision float vector
    'MFVec3f', # Multiple Field (list) 3-tuple single-precision float vectors
    'SFVec4d', # Single Field (singleton) 4-tuple double-precision float vector
    'MFVec4d', # Multiple Field (list) 4-tuple double-precision float vectors
    'SFVec4f', # Single Field (singleton) 4-tuple single-precision float vector
    'MFVec4f', # Multiple Field (list) 4-tuple single-precision float vectors
    'SFMatrix3d', # Single Field (singleton) 3×3 matrix of double-precision floating point numbers
    'MFMatrix3d', # Multiple Field (list) 3×3 matrices of double-precision floating point numbers
    'SFMatrix3f', # Single Field (singleton) 3×3 matrix of single-precision floating point numbers
    'MFMatrix3f', # Multiple Field (list) 3×3 matrices of double-precision floating point numbers
    'SFMatrix4d', # Single Field (singleton) 4×4 matrix of double-precision floating point numbers
    'MFMatrix4d', # Multiple Field (list) 4×4 matric3w of double-precision floating point numbers
    'SFMatrix4f', # Single Field (singleton) 4×4 matrix of single-precision floating point numbers
    'MFMatrix4f' # Multiple Field (list) 4×4 matrices of single-precision floating point numbers
)
def assertValidFieldType(fieldName, value):
    """
    Utility function to assert type validity of fieldTypeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in FIELDTYPECHOICES:
        # print ('*** assertValidFieldType ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in FIELDTYPECHOICES:
        # print ('*** assertValidFieldType ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in FIELDTYPECHOICES=' + str(FIELDTYPECHOICES))

FOGTYPECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'LINEAR', # linear blending as a function of distance
    'EXPONENTIAL' # exponential blending as a function of distance
)
def assertValidFogType(fieldName, value):
    """
    Utility function to assert type validity of fogTypeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in FOGTYPECHOICES:
        # print ('*** assertValidFogType ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in FOGTYPECHOICES:
        # print ('*** assertValidFogType ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in FOGTYPECHOICES=' + str(FOGTYPECHOICES))

FONTFAMILYVALUES = (
    # specification-defined values follow, other values are also allowed
    '"SANS"', # default font family for sans-serif font such as Helvetica
    '"SERIF"', # default font family for serif font such as Times-Roman
    '"TYPEWRITER"' # default font family for a fixed-pitch font such as Courier
)

FONTSTYLECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'PLAIN', # default plain type
    'BOLD', # boldface type
    'ITALIC', # italic type
    'BOLDITALIC' # bold and italic type
)
def assertValidFontStyle(fieldName, value):
    """
    Utility function to assert type validity of fontStyleChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in FONTSTYLECHOICES:
        # print ('*** assertValidFontStyle ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in FONTSTYLECHOICES:
        # print ('*** assertValidFontStyle ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in FONTSTYLECHOICES=' + str(FONTSTYLECHOICES))

FORCEOUTPUTVALUES = (
    # specification-defined values follow, other values are also allowed
    '"ALL"', # all forceOutput fields computed
    '"NONE"' # no forceOutput fields computed
)

GENERATEDCUBEMAPTEXTUREUPDATECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'NONE', # no further texture updates are rendered
    'NEXT_FRAME_ONLY', # render texture once at end of frame
    'ALWAYS' # texture to be rendered every frame
)
def assertValidGeneratedCubeMapTextureUpdate(fieldName, value):
    """
    Utility function to assert type validity of generatedCubeMapTextureUpdateChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in GENERATEDCUBEMAPTEXTUREUPDATECHOICES:
        # print ('*** assertValidGeneratedCubeMapTextureUpdate ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in GENERATEDCUBEMAPTEXTUREUPDATECHOICES:
        # print ('*** assertValidGeneratedCubeMapTextureUpdate ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in GENERATEDCUBEMAPTEXTUREUPDATECHOICES=' + str(GENERATEDCUBEMAPTEXTUREUPDATECHOICES))

GEOMETADATAKEYVALUES = (
    # specification-defined values follow, other values are also allowed
    'title',
    'description',
    'coordinateSystem',
    'horizontalDatum',
    'verticalDatum',
    'ellipsoid',
    'extent',
    'resolution',
    'originator',
    'copyright',
    'date',
    'metadataFormat',
    'dataUrl',
    'dataFormat'
)

GEOSYSTEMEARTHELLIPSOIDVALUES = (
    # specification-defined values follow, other values are also allowed
    'AM', # Modified Airy
    'AN', # Australian National
    'BN', # Bessel 1841 (Namibia)
    'BR', # Bessel 1841 (Ethiopia Indonesia ...)
    'CC', # Clarke 1866
    'CD', # Clarke 1880
    'EA', # Everest (India 1830)
    'EB', # Everest (Sabah & Sarawak)
    'EC', # Everest (India 1956)
    'ED', # Everest (W. Malaysia 1969)
    'EE', # Everest (W. Malaysia & Singapore 1948)
    'EF', # Everest (Pakistan)
    'FA', # Modified Fischer 1960
    'HE', # Helmert 1906
    'HO', # Hough 1960
    'ID', # Indonesia 1974
    'IN', # International 1924
    'KA', # Krassovsky 1940
    'RF', # Geodetic Reference System 1980 (GRS 80)
    'SA', # South American 1969
    'WD', # WGS 72
    'WE', # WGS 84
    'WGS84', # WGS84 geoid
    'Zn', # Zone number (1..60) (only used with UTM)
    'S' # Southern hemisphere (only used with UTM)
)

GEOSYSTEMSPATIALREFERENCEFRAMEVALUES = (
    # specification-defined values follow, other values are also allowed
    'GD', # Geodetic spatial reference frame (latitude/longitude), to be followed by ellipsoid
    'UTM', # Universal Transverse Mercator. One further required argument must be supplied for UTM in order to specify the zone number (1..60) with optional suffix of "S" may be appended in order to specify that the coordinates are in the southern hemisphere. Optional arguments can follow.
    'GC', # Earth-fixed Geocentric with respect to the WGS84 ellipsoid. No additional arguments are supported.
    'GDC', # Synonymous to GD, but may be subject to future deprecation
    'GCC' # Synonymous to GC, but may be subject to future deprecation
)

HANIMFEATUREPOINTNAMEVALUES = (
    # specification-defined values follow, other values are also allowed
    'skull_vertex', # CAESAR 2003 skull_vertex matches ISO 7250-1 part 5.22 Vertex (top of head). No corresponding landmark provided in CAESAR 2018.
    'glabella', # glabella is between the eyebrows and above the nose
    'sellion', # osseocartilaginous junction of the nasal dorsum
    'l_infraorbitale', # Left Infraorbitale foramen is opening in maxillary bone of skull located below the infraorbital margin of the orbit.
    'l_tragion', # notch just above the tragus of the ear
    'l_gonion', # Left Gonion is midpoint of mandibular angle of the jaw.
    'r_infraorbitale', # Right Infraorbitale foramen is opening in maxillary bone of skull located below the infraorbital margin of the orbit.
    'r_tragion', # notch just above the tragus of the ear
    'r_gonion', # Right Gonion is midpoint of the mandibular angle of the jaw.
    'supramenton', # center point above tip of chin
    'cervicale',
    'adams_apple',
    'suprasternale', # Suprasternale
    'substernale',
    'l_clavicle',
    'l_acromion',
    'l_axilla_proximal', # Left Axilla Proximal (Anterior)
    'l_axilla_distal', # Left Axilla Distal (Posterior)
    'l_axilla_posterior_folds',
    'r_clavicle',
    'r_acromion',
    'r_axilla_proximal', # Right Axilla Proximal (Anterior)
    'r_axilla_distal', # Right Axilla Distal (Posterior)
    'r_axilla_posterior_folds', # Right Posterior Axillary Folds
    'spine_1_middle_back',
    'spine_2_lower_back',
    'waist_preferred_anterior',
    'waist_preferred_posterior',
    'l_rib10',
    'l_thelion',
    'r_rib10',
    'r_thelion',
    'l_asis',
    'l_iliocristale',
    'l_psis',
    'r_asis',
    'r_iliocristale',
    'r_psis',
    'crotch',
    'l_femoral_lateral_epicondyle',
    'l_femoral_medial_epicondyle',
    'l_suprapatella',
    'l_trochanterion',
    'r_femoral_lateral_epicondyle',
    'r_femoral_medial_epicondyle',
    'r_suprapatella',
    'r_trochanterion',
    'l_tibiale',
    'l_medial_malleolus',
    'l_lateral_malleolus',
    'l_sphyrion',
    'r_tibiale',
    'r_medial_malleolus',
    'r_lateral_malleolus',
    'r_sphyrion',
    'l_metatarsal_phalanx_1',
    'l_metatarsal_phalanx_5',
    'l_dactylion',
    'l_calcaneus_posterior',
    'r_metatarsal_phalanx_1',
    'r_metatarsal_phalanx_5',
    'r_dactylion',
    'r_calcaneus_posterior',
    'l_humeral_lateral_epicondyle',
    'l_humeral_medial_epicondyle',
    'l_olecranon',
    'r_humeral_lateral_epicondyle',
    'r_humeral_medial_epicondyle',
    'r_olecranon',
    'l_radiale',
    'l_ulnar_styloid',
    'l_radial_styloid',
    'r_radiale',
    'r_ulnar_styloid',
    'r_radial_styloid',
    'l_metacarpal_phalanx_2',
    'l_metacarpal_phalanx_3',
    'l_metacarpal_phalanx_5',
    'r_metacarpal_phalanx_2',
    'r_metacarpal_phalanx_3',
    'r_metacarpal_phalanx_5',
    'nuchale',
    'l_neck_base',
    'r_neck_base',
    'navel',
    'l_ectocanthus',
    'r_ectocanthus',
    'menton',
    'mesosternale',
    'opisthocranion',
    'l_knee_crease',
    'r_knee_crease',
    'rear_center_midsagittal_plane',
    'buttocks_standing_wall_contact_point',
    'l_chest_midsagittal_plane',
    'r_chest_midsagittal_plane',
    'l_bideltoid',
    'r_bideltoid',
    'l_carpal_distal_phalanx_1',
    'l_carpal_distal_phalanx_2',
    'l_carpal_distal_phalanx_3',
    'l_carpal_distal_phalanx_4',
    'l_carpal_distal_phalanx_5',
    'r_carpal_distal_phalanx_1',
    'r_carpal_distal_phalanx_2',
    'r_carpal_distal_phalanx_3',
    'r_carpal_distal_phalanx_4',
    'r_carpal_distal_phalanx_5',
    'l_tarsal_distal_phalanx_1',
    'l_tarsal_distal_phalanx_2',
    'l_tarsal_distal_phalanx_3',
    'l_tarsal_distal_phalanx_4',
    'l_tarsal_distal_phalanx_5',
    'r_tarsal_distal_phalanx_1',
    'r_tarsal_distal_phalanx_2',
    'r_tarsal_distal_phalanx_3',
    'r_tarsal_distal_phalanx_4',
    'r_tarsal_distal_phalanx_5'
)

HANIMHUMANOIDINFOKEYVALUES = (
    # specification-defined values follow, other values are also allowed
    'authorName',
    'authorEmail',
    'copyright',
    'creationDate',
    'usageRestrictions',
    'humanoidVersion',
    'age',
    'gender',
    'height',
    'weight'
)

HANIMJOINTNAMEVALUES = (
    # specification-defined values follow, other values are also allowed
    'humanoid_root',
    'sacroiliac',
    'l_hip',
    'l_knee',
    'l_talocrural',
    'l_talocalcaneonavicular',
    'l_cuneonavicular_1',
    'l_tarsometatarsal_1',
    'l_metatarsophalangeal_1',
    'l_tarsal_interphalangeal_1',
    'l_cuneonavicular_2',
    'l_tarsometatarsal_2',
    'l_metatarsophalangeal_2',
    'l_tarsal_proximal_interphalangeal_2',
    'l_tarsal_distal_interphalangeal_2',
    'l_cuneonavicular_3',
    'l_tarsometatarsal_3',
    'l_metatarsophalangeal_3',
    'l_tarsal_proximal_interphalangeal_3',
    'l_tarsal_distal_interphalangeal_3',
    'l_calcaneocuboid',
    'l_transversetarsal',
    'l_tarsometatarsal_4',
    'l_metatarsophalangeal_4',
    'l_tarsal_proximal_interphalangeal_4',
    'l_tarsal_distal_interphalangeal_4',
    'l_tarsometatarsal_5',
    'l_metatarsophalangeal_5',
    'l_tarsal_proximal_interphalangeal_5',
    'l_tarsal_distal_interphalangeal_5',
    'r_hip',
    'r_knee',
    'r_talocrural',
    'r_talocalcaneonavicular',
    'r_cuneonavicular_1',
    'r_tarsometatarsal_1',
    'r_metatarsophalangeal_1',
    'r_tarsal_interphalangeal_1',
    'r_cuneonavicular_2',
    'r_tarsometatarsal_2',
    'r_metatarsophalangeal_2',
    'r_tarsal_proximal_interphalangeal_2',
    'r_tarsal_distal_interphalangeal_2',
    'r_cuneonavicular_3',
    'r_tarsometatarsal_3',
    'r_metatarsophalangeal_3',
    'r_tarsal_proximal_interphalangeal_3',
    'r_tarsal_distal_interphalangeal_3',
    'r_calcaneocuboid',
    'r_transversetarsal',
    'r_tarsometatarsal_4',
    'r_metatarsophalangeal_4',
    'r_tarsal_proximal_interphalangeal_4',
    'r_tarsal_distal_interphalangeal_4',
    'r_tarsometatarsal_5',
    'r_metatarsophalangeal_5',
    'r_tarsal_proximal_interphalangeal_5',
    'r_tarsal_distal_interphalangeal_5',
    'vl5',
    'vl4',
    'vl3',
    'vl2',
    'vl1',
    'vt12',
    'vt11',
    'vt10',
    'vt9',
    'vt8',
    'vt7',
    'vt6',
    'vt5',
    'vt4',
    'vt3',
    'vt2',
    'vt1',
    'vc7',
    'vc6',
    'vc5',
    'vc4',
    'vc3',
    'vc2',
    'vc1',
    'skullbase',
    'l_eyelid_joint',
    'r_eyelid_joint',
    'l_eyeball_joint',
    'r_eyeball_joint',
    'l_eyebrow_joint',
    'r_eyebrow_joint',
    'temporomandibular',
    'l_sternoclavicular',
    'l_acromioclavicular',
    'l_shoulder',
    'l_elbow',
    'l_radiocarpal',
    'l_midcarpal_1',
    'l_carpometacarpal_1',
    'l_metacarpophalangeal_1',
    'l_carpal_interphalangeal_1',
    'l_midcarpal_2',
    'l_carpometacarpal_2',
    'l_metacarpophalangeal_2',
    'l_carpal_proximal_interphalangeal_2',
    'l_carpal_distal_interphalangeal_2',
    'l_midcarpal_3',
    'l_carpometacarpal_3',
    'l_metacarpophalangeal_3',
    'l_carpal_proximal_interphalangeal_3',
    'l_carpal_distal_interphalangeal_3',
    'l_midcarpal_4_5',
    'l_carpometacarpal_4',
    'l_metacarpophalangeal_4',
    'l_carpal_proximal_interphalangeal_4',
    'l_carpal_distal_interphalangeal_4',
    'l_carpometacarpal_5',
    'l_metacarpophalangeal_5',
    'l_carpal_proximal_interphalangeal_5',
    'l_carpal_distal_interphalangeal_5',
    'r_sternoclavicular',
    'r_acromioclavicular',
    'r_shoulder',
    'r_elbow',
    'r_radiocarpal',
    'r_midcarpal_1',
    'r_carpometacarpal_1',
    'r_metacarpophalangeal_1',
    'r_carpal_interphalangeal_1',
    'r_midcarpal_2',
    'r_carpometacarpal_2',
    'r_metacarpophalangeal_2',
    'r_carpal_proximal_interphalangeal_2',
    'r_carpal_distal_interphalangeal_2',
    'r_midcarpal_3',
    'r_carpometacarpal_3',
    'r_metacarpophalangeal_3',
    'r_carpal_proximal_interphalangeal_3',
    'r_carpal_distal_interphalangeal_3',
    'r_midcarpal_4_5',
    'r_carpometacarpal_4',
    'r_metacarpophalangeal_4',
    'r_carpal_proximal_interphalangeal_4',
    'r_carpal_distal_interphalangeal_4',
    'r_carpometacarpal_5',
    'r_metacarpophalangeal_5',
    'r_carpal_proximal_interphalangeal_5',
    'r_carpal_distal_interphalangeal_5'
)

HANIMSEGMENTNAMEVALUES = (
    # specification-defined values follow, other values are also allowed
    'sacrum',
    'pelvis',
    'l_thigh',
    'l_calf',
    'l_talus',
    'l_navicular',
    'l_cuneiform_1',
    'l_metatarsal_1',
    'l_tarsal_proximal_phalanx_1',
    'l_tarsal_distal_phalanx_1',
    'l_cuneiform_2',
    'l_metatarsal_2',
    'l_tarsal_proximal_phalanx_2',
    'l_tarsal_middle_phalanx_2',
    'l_tarsal_distal_phalanx_2',
    'l_cuneiform_3',
    'l_metatarsal_3',
    'l_tarsal_proximal_phalanx_3',
    'l_tarsal_middle_phalanx_3',
    'l_tarsal_distal_phalanx_3',
    'l_calcaneus',
    'l_cuboid',
    'l_metatarsal_4',
    'l_tarsal_proximal_phalanx_4',
    'l_tarsal_middle_phalanx_4',
    'l_tarsal_distal_phalanx_4',
    'l_metatarsal_5',
    'l_tarsal_proximal_phalanx_5',
    'l_tarsal_middle_phalanx_5',
    'l_tarsal_distal_phalanx_5',
    'r_thigh',
    'r_calf',
    'r_talus',
    'r_navicular',
    'r_cuneiform_1',
    'r_metatarsal_1',
    'r_tarsal_proximal_phalanx_1',
    'r_tarsal_distal_phalanx_1',
    'r_cuneiform_2',
    'r_metatarsal_2',
    'r_tarsal_proximal_phalanx_2',
    'r_tarsal_middle_phalanx_2',
    'r_tarsal_distal_phalanx_2',
    'r_cuneiform_3',
    'r_metatarsal_3',
    'r_tarsal_proximal_phalanx_3',
    'r_tarsal_middle_phalanx_3',
    'r_tarsal_distal_phalanx_3',
    'r_calcaneus',
    'r_cuboid',
    'r_metatarsal_4',
    'r_tarsal_proximal_phalanx_4',
    'r_tarsal_middle_phalanx_4',
    'r_tarsal_distal_phalanx_4',
    'r_metatarsal_5',
    'r_tarsal_proximal_phalanx_5',
    'r_tarsal_middle_phalanx_5',
    'r_tarsal_distal_phalanx_5',
    'l5',
    'l4',
    'l3',
    'l2',
    'l1',
    't12',
    't11',
    't10',
    't9',
    't8',
    't7',
    't6',
    't5',
    't4',
    't3',
    't2',
    't1',
    'c7',
    'c6',
    'c5',
    'c4',
    'c3',
    'c2',
    'c1',
    'skull',
    'l_eyelid',
    'r_eyelid',
    'l_eyeball',
    'r_eyeball',
    'l_eyebrow',
    'r_eyebrow',
    'jaw',
    'l_clavicle',
    'l_scapula',
    'l_upperarm',
    'l_forearm',
    'l_carpal',
    'l_trapezium',
    'l_metacarpal_1',
    'l_carpal_proximal_phalanx_1',
    'l_carpal_distal_phalanx_1',
    'l_trapezoid',
    'l_metacarpal_2',
    'l_carpal_proximal_phalanx_2',
    'l_carpal_middle_phalanx_2',
    'l_carpal_distal_phalanx_2',
    'l_capitate',
    'l_metacarpal_3',
    'l_carpal_proximal_phalanx_3',
    'l_carpal_middle_phalanx_3',
    'l_carpal_distal_phalanx_3',
    'l_hamate',
    'l_metacarpal_4',
    'l_carpal_proximal_phalanx_4',
    'l_carpal_middle_phalanx_4',
    'l_carpal_distal_phalanx_4',
    'l_metacarpal_5',
    'l_carpal_proximal_phalanx_5',
    'l_carpal_middle_phalanx_5',
    'l_carpal_distal_phalanx_5',
    'r_clavicle',
    'r_scapula',
    'r_upperarm',
    'r_forearm',
    'r_carpal',
    'r_trapezium',
    'r_metacarpal_1',
    'r_carpal_proximal_phalanx_1',
    'r_carpal_distal_phalanx_1',
    'r_trapezoid',
    'r_metacarpal_2',
    'r_carpal_proximal_phalanx_2',
    'r_carpal_middle_phalanx_2',
    'r_carpal_distal_phalanx_2',
    'r_capitate',
    'r_metacarpal_3',
    'r_carpal_proximal_phalanx_3',
    'r_carpal_middle_phalanx_3',
    'r_carpal_distal_phalanx_3',
    'r_hamate',
    'r_metacarpal_4',
    'r_carpal_proximal_phalanx_4',
    'r_carpal_middle_phalanx_4',
    'r_carpal_distal_phalanx_4',
    'r_metacarpal_5',
    'r_carpal_proximal_phalanx_5',
    'r_carpal_middle_phalanx_5',
    'r_carpal_distal_phalanx_5'
)

HANIMVERSIONCHOICES = (
    # strict set of allowed values follow, no other values are valid
    '1.0', # International standard HAnim 19774 version 1 approved by ISO in 2006. Note that HAnim version 2.0 has more capabilties, while version 1.0 includes several small incompatibilities. Since no other versions were formally approved, no other values are allowed for earlier HAnim versions.
    '2.0' # Revised standard HAnim 19774 version 2 (parts 1 and 2) were approved by ISO in November 2019, published by Web3D Consortium May 2020.
)
def assertValidHanimVersion(fieldName, value):
    """
    Utility function to assert type validity of hanimVersionChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in HANIMVERSIONCHOICES:
        # print ('*** assertValidHanimVersion ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in HANIMVERSIONCHOICES:
        # print ('*** assertValidHanimVersion ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in HANIMVERSIONCHOICES=' + str(HANIMVERSIONCHOICES))

INTERSECTIONTYPEVALUES = (
    # specification-defined values follow, other values are also allowed
    'BOUNDS', # TODO undefined in X3D specification
    'GEOMETRY' # TODO undefined in X3D specification
)

JUSTIFYCHOICES = (
    # note these MFString values use XML syntax
    # strict set of allowed values follow, no other values are valid
    '"MIDDLE"',
    '"MIDDLE" "BEGIN"',
    '"MIDDLE" "END"',
    '"MIDDLE" "FIRST"',
    '"MIDDLE" "MIDDLE"',
    '"BEGIN"',
    '"BEGIN" "BEGIN"',
    '"BEGIN" "END"',
    '"BEGIN" "FIRST"',
    '"BEGIN" "MIDDLE"',
    '"END"',
    '"END" "BEGIN"',
    '"END" "END"',
    '"END" "FIRST"',
    '"END" "MIDDLE"',
    '"FIRST"',
    '"FIRST" "BEGIN"',
    '"FIRST" "END"',
    '"FIRST" "FIRST"',
    '"FIRST" "MIDDLE"'
)
def assertValidJustify(fieldName, value):
    """
    Utility function to assert type validity of justifyChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in JUSTIFYCHOICES:
        # print ('*** assertValidJustify ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in JUSTIFYCHOICES:
        # print ('*** assertValidJustify ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in JUSTIFYCHOICES=' + str(JUSTIFYCHOICES))

LAYOUTALIGNCHOICES = (
    # note these MFString values use XML syntax
    # strict set of allowed values follow, no other values are valid
    '"LEFT" "BOTTOM"',
    '"LEFT" "CENTER"',
    '"LEFT" "TOP"',
    '"CENTER" "BOTTOM"',
    '"CENTER" "CENTER"',
    '"CENTER" "TOP"',
    '"RIGHT" "BOTTOM"',
    '"RIGHT" "CENTER"',
    '"RIGHT" "TOP"'
)
def assertValidLayoutAlign(fieldName, value):
    """
    Utility function to assert type validity of layoutAlignChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in LAYOUTALIGNCHOICES:
        # print ('*** assertValidLayoutAlign ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in LAYOUTALIGNCHOICES:
        # print ('*** assertValidLayoutAlign ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in LAYOUTALIGNCHOICES=' + str(LAYOUTALIGNCHOICES))

LAYOUTSCALEMODECHOICES = (
    # note these MFString values use XML syntax
    # strict set of allowed values follow, no other values are valid
    '"NONE" "NONE"',
    '"NONE" "FRACTION"',
    '"NONE" "STRETCH"',
    '"NONE" "PIXEL"',
    '"FRACTION" "NONE"',
    '"FRACTION" "FRACTION"',
    '"FRACTION" "STRETCH"',
    '"FRACTION" "PIXEL"',
    '"STRETCH" "NONE"',
    '"STRETCH" "FRACTION"',
    '"STRETCH" "STRETCH"',
    '"STRETCH" "PIXEL"',
    '"PIXEL" "NONE"',
    '"PIXEL" "FRACTION"',
    '"PIXEL" "STRETCH"',
    '"PIXEL" "PIXEL"'
)
def assertValidLayoutScaleMode(fieldName, value):
    """
    Utility function to assert type validity of layoutScaleModeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in LAYOUTSCALEMODECHOICES:
        # print ('*** assertValidLayoutScaleMode ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in LAYOUTSCALEMODECHOICES:
        # print ('*** assertValidLayoutScaleMode ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in LAYOUTSCALEMODECHOICES=' + str(LAYOUTSCALEMODECHOICES))

LAYOUTUNITSCHOICES = (
    # note these MFString values use XML syntax
    # strict set of allowed values follow, no other values are valid
    '"WORLD" "WORLD"',
    '"WORLD" "FRACTION"',
    '"WORLD" "PIXEL"',
    '"FRACTION" "WORLD"',
    '"FRACTION" "FRACTION"',
    '"FRACTION" "PIXEL"',
    '"PIXEL" "WORLD"',
    '"PIXEL" "FRACTION"',
    '"PIXEL" "PIXEL"'
)
def assertValidLayoutUnits(fieldName, value):
    """
    Utility function to assert type validity of layoutUnitsChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in LAYOUTUNITSCHOICES:
        # print ('*** assertValidLayoutUnits ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in LAYOUTUNITSCHOICES:
        # print ('*** assertValidLayoutUnits ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in LAYOUTUNITSCHOICES=' + str(LAYOUTUNITSCHOICES))

METADIRECTIONCHOICES = (
    # strict set of allowed values follow, no other values are valid
    'rtl', # right-to-left
    'ltr' # left-to-right
)
def assertValidMetaDirection(fieldName, value):
    """
    Utility function to assert type validity of metaDirectionChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in METADIRECTIONCHOICES:
        # print ('*** assertValidMetaDirection ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in METADIRECTIONCHOICES:
        # print ('*** assertValidMetaDirection ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in METADIRECTIONCHOICES=' + str(METADIRECTIONCHOICES))

METANAMEVALUES = (
    # specification-defined values follow, other values are also allowed
    'accessRights', # permission required to access resource or security status
    'author', # name of individual author
    'contributor', # name of individual contributing to this resource
    'created', # date of initial version
    'creator', # name of original author
    'description', # summary overview describing this resource
    'disclaimer', # statement of denial or disavowal regarding potential claims or responsiblity
    'drawing', # name or reference link to a supporting drawing or sketch file
    'error', # information about an error (or known problem) that can prevent proper operation
    'generator', # authoring tool or translation tool
    'hint', # user hint about resource features or operation
    'identifier', # url address or unique Uniform Resource Identifier (URI) for resource
    'Image', # name or reference link to supporting image file
    'info', # additional info of interest
    'information', # additional information of interest
    'isVersionOf', # Related resource of which the described resource is a version, edition, or adaptation.
    'keywords', # comma-separated tokens, each of which is a keyword of interest
    'license', # content or software license
    'mediator', # entity that mediates access to resource and for whom resource is intended or useful
    'modified', # date of modified version
    'movie', # name or reference link to supporting movie file (note that Dublin Core term is MovingImage)
    'MovingImage', # name or reference link to supporting movie
    'original', # name or reference link to original file or resource
    'photo', # name or reference link to supporting photo file (note that Dublin Core term is Image)
    'photograph', # name or reference link to supporting photograph file (note that Dublin Core term is Image)
    'publisher', # entity responsible for making the resource available
    'reference', # name or reference link to supporting reference
    'requires', # prerequisites for operation or viewing
    'rights', # intellectual property rights (IPR)
    'robots', # search engine and web-spider guidance value: noindex to block page indexing, nofollow to block following links
    'Sound', # name or reference link to supporting sound file
    'source', # related resource from which the described resource is derived
    'specificationSection', # title of relevant specification section
    'specificationUrl', # url for relevant specification section
    'subject', # search-index subject keywords, key phrases, or classification codes
    'Text', # resource consisting primarily of words for reading
    'title', # file name for this resource
    'TODO', # action item "to do" that still needs to be performed
    'translator', # name of person performing translation from another format or language
    'translated', # date of translation from another format or language
    'version', # current version number or ID of this resource
    'warning' # warning information about a known problem that impedes proper operation
)

MULTITEXTUREFUNCTIONVALUES = (
    # specification-defined values follow, other values are also allowed
    '"COMPLEMENT"', # Invert argument x as (1 - x)
    '"ALPHAREPLICATE"', # Replicate alpha information to all color channels before operation completes.
    '""' # No function is applied - empty SFString is allowed value within MFString array
)

MULTITEXTUREMODEVALUES = (
    # specification-defined values follow, other values are also allowed
    '"ADD"',
    '"ADDSIGNED"',
    '"ADDSIGNED2X"',
    '"ADDSMOOTH"',
    '"BLENDCURRENTALPHA"',
    '"BLENDDIFFUSEALPHA"',
    '"BLENDFACTORALPHA"',
    '"BLENDTEXTUREALPHA"',
    '"DOTPRODUCT3"',
    '"MODULATE"',
    '"MODULATE2X"',
    '"MODULATE4X"',
    '"MODULATEALPHA_ADDCOLOR"',
    '"MODULATEINVALPHA_ADDCOLOR"',
    '"MODULATEINVCOLOR_ADDALPHA"',
    '"OFF"',
    '"REPLACE"',
    '"SELECTARG1"',
    '"SELECTARG2"',
    '"SUBTRACT"'
)

MULTITEXTURESOURCEVALUES = (
    # specification-defined values follow, other values are also allowed
    '"DIFFUSE"',
    '"FACTOR"',
    '"SPECULAR"',
    '""'
)

NAVIGATIONTRANSITIONTYPEVALUES = (
    # specification-defined values follow, other values are also allowed
    '"TELEPORT"', # immediate transition
    '"LINEAR"', # transition may proceed directly through intervening objects
    '"ANIMATE"' # rowser-specific transition
)

NAVIGATIONTYPEVALUES = (
    # specification-defined values follow, other values are also allowed
    '"ANY"', # browser can offer any type for user to choose
    '"WALK"', # free navigation, avatar remains on ground, collision detection
    '"EXAMINE"', # view an individual object by rotating view about center
    '"FLY"', # free navigation, collision detection
    '"LOOKAT"', # navigate to particular object
    '"NONE"', # disables all navigation interfaces
    '"EXPLORE"' # consistent keystroke navigation for both geospatial and Cartesian modes
)

NETWORKMODECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'standAlone', # ignore network but still respond to events in local scene
    'networkReader', # listen to network and read PDU packets at readInterval, act as remotely linked copy of entity
    'networkWriter' # send PDU packets to network at writeInterval, act as master entity
)
def assertValidNetworkMode(fieldName, value):
    """
    Utility function to assert type validity of networkModeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in NETWORKMODECHOICES:
        # print ('*** assertValidNetworkMode ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in NETWORKMODECHOICES:
        # print ('*** assertValidNetworkMode ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in NETWORKMODECHOICES=' + str(NETWORKMODECHOICES))

PARTICLESYSTEMGEOMETRYTYPEVALUES = (
    # specification-defined values follow, other values are also allowed
    'LINE', # line is drawn along current velocity vector of particle
    'POINT', # point geometry is rendered at particle position
    'QUAD', # quad geometry is rendered at particle position facing direction traveled
    'SPRITE', # quad geometry is rendered at particle position facing screen
    'TRIANGLE', # pair of triangles creating quad geometry is rendered at particle position facing direction traveled
    'GEOMETRY' # geometry field is used for rendering each particle
)

PERIODICWAVETYPECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'sine',
    'square',
    'sawtooth',
    'triangle',
    'custom'
)
def assertValidPeriodicWaveType(fieldName, value):
    """
    Utility function to assert type validity of periodicWaveTypeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in PERIODICWAVETYPECHOICES:
        # print ('*** assertValidPeriodicWaveType ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in PERIODICWAVETYPECHOICES:
        # print ('*** assertValidPeriodicWaveType ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in PERIODICWAVETYPECHOICES=' + str(PERIODICWAVETYPECHOICES))

PHASEFUNCTIONVALUES = (
    # specification-defined values follow, other values are also allowed
    'Henyey-Greenstein', # Henyey-Greenstein phase function for scattering model
    'NONE' # no scattering
)

PICKABLEOBJECTTYPEVALUES = (
    # specification-defined values follow, other values are also allowed
    '"ALL"', # each node is available for picking
    '"NONE"', # no node is available for picking
    '"TERRAIN"' # TERRAIN is an example value
)

PICKSENSORMATCHCRITERIONCHOICES = (
    # strict set of allowed values follow, no other values are valid
    'MATCH_ANY', # any match of objectType values is acceptable
    'MATCH_EVERY', # every objectType value in X3DPickSensorNode and X3DPickableObject shall match
    'MATCH_ONLY_ONE' # one and only one objectType value can match
)
def assertValidPickSensorMatchCriterion(fieldName, value):
    """
    Utility function to assert type validity of pickSensorMatchCriterionChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in PICKSENSORMATCHCRITERIONCHOICES:
        # print ('*** assertValidPickSensorMatchCriterion ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in PICKSENSORMATCHCRITERIONCHOICES:
        # print ('*** assertValidPickSensorMatchCriterion ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in PICKSENSORMATCHCRITERIONCHOICES=' + str(PICKSENSORMATCHCRITERIONCHOICES))

PICKSENSORSORTORDERVALUES = (
    # specification-defined values follow, other values are also allowed
    'ANY', # any single object that can satisfy picking conditions
    'CLOSEST', # return closest object by distance that satisfies conditions of this pick sensor
    'ALL', # every object that satisfies picking conditions for this pick sensor is returned
    'ALL_SORTED' # every object that satisfies picking conditions for this pick sensor is returned, in sorted order
)

PROFILENAMECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'Core', # Core Profile includes no nodes and is provided as the basis for custom componentization. Allowed X3D statements for all profiles are: connect ExternProtoDeclare EXPORT field fieldValue IMPORT IS ProtoBody ProtoDeclare ProtoInterface ProtoInstance ROUTE X3D. Allowed X3D nodes for this profile are: MetadataBoolean MetadataDouble MetadataFloat MetadataInteger MetadataSet MetadataString.
    'Interchange', # Interchange Profile equals the minimum subset of nodes needed to display lightweight compelling content. Allowed X3D nodes for this profile are: Appearance Background Box Color ColorInterpolator ColorRGBA Cone Coordinate CoordinateInterpolator Cylinder DirectionalLight Group ImageTexture IndexedFaceSet IndexedLineSet IndexedTriangleFanSet IndexedTriangleSet IndexedTriangleStripSet LineSet Material MetadataBoolean MetadataDouble MetadataFloat MetadataInteger MetadataSet MetadataString MultiTexture MultiTextureCoordinate MultiTextureTransform NavigationInfo Normal NormalInterpolator OrientationInterpolator PixelTexture PointSet PositionInterpolator ScalarInterpolator Shape Sphere TextureCoordinate TextureCoordinateGenerator TextureTransform TimeSensor Transform TriangleFanSet TriangleSet TriangleStripSet Viewpoint WorldInfo.
    'CADInterchange', # CADInterchange Profile adds support for CADGeometry component nodes to Interchange Profile. Allowed X3D nodes for this profile are: Anchor Appearance CADAssembly CADFace CADLayer CADPart Billboard Collision Color ColorRGBA Coordinate DirectionalLight FragmentShader Group ImageTexture IndexedLineSet IndexedQuadSet IndexedTriangleFanSet IndexedTriangleSet IndexedTriangleStripSet Inline LineProperties LineSet LOD Material MetadataBoolean MetadataDouble MetadataFloat MetadataInteger MetadataSet MetadataString MultiShader MultiTexture MultiTextureCoordinate MultiTextureTransform NavigationInfo Normal PixelTexture PointSet QuadSet Shader ShaderAppearance Shape TextureCoordinate TextureCoordinateGenerator TextureTransform Transform TriangleFanSet TriangleSet TriangleStripSet Viewpoint VertexShader WorldInfo.
    'Interactive', # Interactive Profile adds interaction nodes (Anchor, KeySensor) to the minimum subset of nodes needed to display lightweight compelling content. Allowed X3D nodes for this profile are: Anchor Appearance Background BooleanFilter BooleanSequencer BooleanToggle BooleanTrigger Box Color ColorInterpolator ColorRGBA Cone Coordinate CoordinateInterpolator Cylinder CylinderSensor DirectionalLight ElevationGrid Group ImageTexture IndexedFaceSet IndexedLineSet IndexedTriangleFanSet IndexedTriangleSet IndexedTriangleStripSet Inline IntegerSequencer IntegerTrigger KeySensor LineSet Material MetadataBoolean MetadataDouble MetadataFloat MetadataInteger MetadataSet MetadataString MultiTexture MultiTextureCoordinate MultiTextureTransform NavigationInfo Normal NormalInterpolator OrientationInterpolator IndexedTriangleStripSet Inline IntegerSequencer IntegerTrigger KeySensor LineSet Material MetadataBoolean MetadataDouble MetadataFloat MetadataInteger MetadataSet MetadataString MultiTexture MultiTextureCoordinate MultiTextureTransform NavigationInfo Normal NormalInterpolator OrientationInterpolator PixelTexture PlaneSensor PointLight PointSet PositionInterpolator ProximitySensor ScalarInterpolator Shape Sphere SphereSensor SpotLight StringSensor Switch TextureCoordinate TextureCoordinateGenerator TextureTransform TimeSensor TimeTrigger TouchSensor Transform TriangleFanSet TriangleSet TriangleStripSet Viewpoint VisibilitySensor WorldInfo.
    'Immersive', # Immersive Profile equals all of the nodes in the VRML97 Specification, plus various X3D node additions including KeySensor, StringSensor and Scene. Allowed X3D nodes for this profile are: Anchor Appearance AudioClip Background Billboard BooleanFilter BooleanSequencer BooleanToggle BooleanTrigger Box Collision Color ColorInterpolator ColorRGBA Cone Coordinate CoordinateInterpolator Cylinder CylinderSensor DirectionalLight ElevationGrid Extrusion Fog FontStyle Group ImageTexture IndexedFaceSet IndexedLineSet IndexedTriangleFan IndexedTriangleSet IndexedTriangleStripSet Inline IntegerSequencer IntegerTrigger KeySensor LineProperties LineSet LoadSensor LOD Material MetadataBoolean MetadataDouble MetadataFloat MetadataInteger MetadataSet MetadataString MovieTexture MultiTexture MultiTextureCoordinate MultiTextureTransform NavigationInfo Normal NormalInterpolator OrientationInterpolator PixelTexture PlaneSensor PointLight PointSet Polyline2D Polypoint2D PositionInterpolator ProximitySensor Rectangle2D ScalarInterpolator Script Shape Sound Sphere SphereSensor SpotLight StringSensor Switch Text TextureCoordinate TextureCoordinateGenerator TextureTransform TimeSensor TimeTrigger TouchSensor TriangleFanSet TriangleSet TriangleSet2D TriangleStripSet Transform Viewpoint VisibilitySensor WorldInfo.
    'MedicalInterchange', # The MedicalInterchange profile adds support for VolumeRendering component to Interchange profile. Allowed X3D nodes for this profile are: Anchor Arc2D ArcClose2D Appearance Background Billboard BlendedVolumeStyle BooleanFilter BooleanSequencer BooleanToggle BooleanTrigger BoundaryEnhancementVolumeStyle Box CartoonVolumeStyle Circle2D ClipPlane Collision Color ColorInterpolator ColorRGBA ComposedVolumeStyle CompositeTexture3D Cone Coordinate CoordinateDouble CoordinateInterpolator Cylinder DirectionalLight Disk2D EdgeEnhancementVolumeStyle FillProperties FontStyle Group ImageTexture ImageTexture3D IndexedFaceSet IndexedLineSet IndexedTriangleFanSet IndexedTriangleSet IndexedTriangleStripSet Inline IntegerSequencer IntegerTrigger IsoSurfaceVolumeData LineProperties LineSet LOD Material MetadataBoolean MetadataDouble MetadataFloat MetadataInteger MetadataSet MetadataString MultiTexture MultiTextureCoordinate MultiTextureTransform NavigationInfo Normal NormalInterpolator OctTree OpacityMapVolumeStyle OrientationInterpolator OrthoViewpoint PixelTexture PixelTexture3D PointSet Polyline2D Polypoint2D PositionInterpolator ProjectionVolumeStyle Rectangle2D ScalarInterpolator SegmentedVolumeData ShadedVolumeStyle Shape SilhouetteEnhancementVolumeStyle Sphere StaticGroup Switch Text TextureCoordinate TextureCoordinate3D TextureCoordinate4D TextureCoordinateGenerator TextureMatrixTransform TextureProperties TextureTransform TextureTransform3D TimeSensor TimeTrigger ToneMappedVolumeStyle Transform TriangleFanSet TriangleSet TriangleStripSet Viewpoint ViewpointGroup VolumeData WorldInfo.
    'MPEG4Interactive', # MPEGInteractive Profile defines base interoperability with MPEG4 standards to a small subset of nodes needed to display lightweight compelling content. Allowed X3D nodes for this profile are: Anchor Appearance Background Box Color ColorInterpolator ColorRGBA Cone Coordinate CoordinateInterpolator Cylinder CylinderSensor DirectionalLight ElevationGrid Group ImageTexture IndexedFaceSet IndexedLineSet Inline LineSet Material MetadataBoolean MetadataDouble MetadataFloat MetadataInteger MetadataSet MetadataString NavigationInfo NormalInterpolator OrientationInterpolator PixelTexture PlaneSensor PointLight PointSet PositionInterpolator ProximitySensor ScalarInterpolator Shape Sphere SphereSensor SpotLight Switch TextureCoordinate TextureTransform TimeSensor TouchSensor Transform Viewpoint WorldInfo.
    'Full' # The Full Profile corresponds to all Immersive X3D nodes plus all approved/implemented extensions. All X3D nodes and statements are allowed in this profile.
)
def assertValidProfileName(fieldName, value):
    """
    Utility function to assert type validity of profileNameChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in PROFILENAMECHOICES:
        # print ('*** assertValidProfileName ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in PROFILENAMECHOICES:
        # print ('*** assertValidProfileName ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in PROFILENAMECHOICES=' + str(PROFILENAMECHOICES))

PROJECTIONVOLUMESTYLETYPECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'MAX', # Maximum Intensity Projection (MIP) or Least MIP (LMIP) algorithm is used to generate output color
    'MIN', # Minimum Intensity Projection algorithm is used to generate output color
    'AVERAGE' # All voxels along ray are averaged to generate output color
)
def assertValidProjectionVolumeStyleType(fieldName, value):
    """
    Utility function to assert type validity of projectionVolumeStyleTypeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in PROJECTIONVOLUMESTYLETYPECHOICES:
        # print ('*** assertValidProjectionVolumeStyleType ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in PROJECTIONVOLUMESTYLETYPECHOICES:
        # print ('*** assertValidProjectionVolumeStyleType ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in PROJECTIONVOLUMESTYLETYPECHOICES=' + str(PROJECTIONVOLUMESTYLETYPECHOICES))

SHADERLANGUAGEVALUES = (
    # specification-defined values follow, other values are also allowed
    'Cg', # nVidia Cg shading language
    'GLSL', # OpenGL shading language (GLSL)
    'HLSL' # Microsoft High Level Shading Language (HLSL)
)

SHADERPARTTYPEVALUES = (
    # specification-defined values follow, other values are also allowed
    'VERTEX', # vertex shader
    'FRAGMENT' # fragment shader
)

TEXTUREBOUNDARYMODECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'CLAMP', # Clamp texture coordinates to range [0,1]
    'CLAMP_TO_EDGE', # Clamp texture coordinates such that a border texel is never sampled
    'CLAMP_TO_BOUNDARY', # Clamp texture coordinates such that texture samples are border texels for fragments
    'MIRRORED_REPEAT', # Texture coordinates are mirrored and then clamped as in CLAMP_TO_EDGE
    'REPEAT' # Repeat a texture across the fragment
)
def assertValidTextureBoundaryMode(fieldName, value):
    """
    Utility function to assert type validity of textureBoundaryModeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in TEXTUREBOUNDARYMODECHOICES:
        # print ('*** assertValidTextureBoundaryMode ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in TEXTUREBOUNDARYMODECHOICES:
        # print ('*** assertValidTextureBoundaryMode ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in TEXTUREBOUNDARYMODECHOICES=' + str(TEXTUREBOUNDARYMODECHOICES))

TEXTURECOMPRESSIONMODECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'DEFAULT', # browser-specified default compression mode
    'FASTEST', # fastest method available
    'HIGH', # greatest amount of compression
    'LOW', # least amount of compression
    'MEDIUM', # moderate amount of compressions
    'NICEST' # highest quality method available
)
def assertValidTextureCompressionMode(fieldName, value):
    """
    Utility function to assert type validity of textureCompressionModeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in TEXTURECOMPRESSIONMODECHOICES:
        # print ('*** assertValidTextureCompressionMode ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in TEXTURECOMPRESSIONMODECHOICES:
        # print ('*** assertValidTextureCompressionMode ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in TEXTURECOMPRESSIONMODECHOICES=' + str(TEXTURECOMPRESSIONMODECHOICES))

TEXTURECOORDINATEGENERATORMODECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'SPHERE', # Creates texture coordinates for a spherical environment
    'CAMERASPACENORMAL', # Use vertex normal, transformed to camera space, as input texture coordinates
    'CAMERASPACEPOSITION', # Use vertex position, transformed to camera space, as input texture coordinates
    'CAMERASPACEREFLECTIONVECTOR', # Use reflection vector, transformed to camera space, as input texture coordinates
    'SPHERE-LOCAL', # Sphere mapping but in local coordinates
    'COORD', # Use vertex coordinates
    'COORD-EYE', # Use vertex coordinates transformed to camera space
    'NOISE', # Apply Perlin solid noise function on vertex coordinates
    'NOISE-EYE', # Apply Perlin solid noise function on vertex coordinates transformed to camera space
    'SPHERE-REFLECT', # similar to CAMERASPACEREFLECTIONVECTOR with optional index of refraction
    'SPHERE-REFLECT-LOCAL' # Similar to SPHERE-REFLECT transformed to camera space
)
def assertValidTextureCoordinateGeneratorMode(fieldName, value):
    """
    Utility function to assert type validity of textureCoordinateGeneratorModeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in TEXTURECOORDINATEGENERATORMODECHOICES:
        # print ('*** assertValidTextureCoordinateGeneratorMode ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in TEXTURECOORDINATEGENERATORMODECHOICES:
        # print ('*** assertValidTextureCoordinateGeneratorMode ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in TEXTURECOORDINATEGENERATORMODECHOICES=' + str(TEXTURECOORDINATEGENERATORMODECHOICES))

TEXTUREMAGNIFICATIONMODECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'AVG_PIXEL', # weighted average of four texture elements closest to center of pixel being textured
    'DEFAULT', # browser-specified default magnification mode
    'FASTEST', # fastest method available
    'NEAREST_PIXEL', # texture element nearest to the center of pixel being textured
    'NICEST' # highest quality method available
)
def assertValidTextureMagnificationMode(fieldName, value):
    """
    Utility function to assert type validity of textureMagnificationModeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in TEXTUREMAGNIFICATIONMODECHOICES:
        # print ('*** assertValidTextureMagnificationMode ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in TEXTUREMAGNIFICATIONMODECHOICES:
        # print ('*** assertValidTextureMagnificationMode ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in TEXTUREMAGNIFICATIONMODECHOICES=' + str(TEXTUREMAGNIFICATIONMODECHOICES))

TEXTUREMINIFICATIONMODECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'AVG_PIXEL', # weighted average of four texture elements closest to center of pixel being textured
    'AVG_PIXEL_AVG_MIPMAP', # tri-linear mipmap filtering
    'AVG_PIXEL_NEAREST_MIPMAP', # choose mipmap that most closely matches size of pixel being textured, use weighted average of four texture elements closest to center of pixel
    'DEFAULT', # browser-specified default minification mode
    'FASTEST', # fastest method available, use mipmaps if possible
    'NEAREST_PIXEL', # texture element nearest to center of pixel being textured
    'NEAREST_PIXEL_AVG_MIPMAP', # texture element nearest to center of pixel being textured, use average of two nearest mipmaps
    'NEAREST_PIXEL_NEAREST_MIPMAP', # texture element nearest to center of pixel being textured, use nearest mipmap
    'NICEST' # highest quality method available
)
def assertValidTextureMinificationMode(fieldName, value):
    """
    Utility function to assert type validity of textureMinificationModeChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in TEXTUREMINIFICATIONMODECHOICES:
        # print ('*** assertValidTextureMinificationMode ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in TEXTUREMINIFICATIONMODECHOICES:
        # print ('*** assertValidTextureMinificationMode ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in TEXTUREMINIFICATIONMODECHOICES=' + str(TEXTUREMINIFICATIONMODECHOICES))

UNITCATEGORYCHOICES = (
    # strict set of allowed values follow, no other values are valid
    'angle', # angle default is radians
    'force', # force default is newtons
    'length', # length default is meters
    'mass' # mass default is kilograms
)
def assertValidUnitCategory(fieldName, value):
    """
    Utility function to assert type validity of unitCategoryChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in UNITCATEGORYCHOICES:
        # print ('*** assertValidUnitCategory ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in UNITCATEGORYCHOICES:
        # print ('*** assertValidUnitCategory ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in UNITCATEGORYCHOICES=' + str(UNITCATEGORYCHOICES))

VOLUMERENDERINGWEIGHTFUNCTIONCHOICES = (
    # strict set of allowed values follow, no other values are valid
    'CONSTANT', # Use weightConstant1
    'ALPHA1', # Use O_v
    'ALPHA2', # Use O_blend
    'ONE_MINUS_ALPHA1', # Use 1 - O_v
    'ONE_MINUS_ALPHA2', # Use 1 - O_blend
    'TABLE' # Use table lookup value
)
def assertValidVolumeRenderingWeightFunction(fieldName, value):
    """
    Utility function to assert type validity of volumeRenderingWeightFunctionChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in VOLUMERENDERINGWEIGHTFUNCTIONCHOICES:
        # print ('*** assertValidVolumeRenderingWeightFunction ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in VOLUMERENDERINGWEIGHTFUNCTIONCHOICES:
        # print ('*** assertValidVolumeRenderingWeightFunction ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in VOLUMERENDERINGWEIGHTFUNCTIONCHOICES=' + str(VOLUMERENDERINGWEIGHTFUNCTIONCHOICES))

WAVESHAPEROVERSAMPLECHOICES = (
    # strict set of allowed values follow, no other values are valid
    'none',
    '2x',
    '4x'
)
def assertValidWaveShaperOversample(fieldName, value):
    """
    Utility function to assert type validity of waveShaperOversampleChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in WAVESHAPEROVERSAMPLECHOICES:
        # print ('*** assertValidWaveShaperOversample ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in WAVESHAPEROVERSAMPLECHOICES:
        # print ('*** assertValidWaveShaperOversample ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in WAVESHAPEROVERSAMPLECHOICES=' + str(WAVESHAPEROVERSAMPLECHOICES))

X3DVERSIONCHOICES = (
    # strict set of allowed values follow, no other values are valid
    '3.0', # X3D version 3.0 approved by ISO in 2004.
    '3.1', # X3D version 3.1 Amendment 1 approved by ISO in 2005. Backwards compatibility maintained with version 3.0.
    '3.2', # X3D version 3.2 Amendment 2 approved by ISO in 2007. Backwards compatibility maintained with versions 3.0 and 3.1.
    '3.3', # X3D version 3.3 approved by ISO in 2013 as International Standard (IS). Backwards compatibility maintained with versions 3.0, 3.1 and 3.2.
    '4.0' # X3D version 4.0 under final development by Web3D Consortium. Backwards compatibility maintained with versions 3.0, 3.1, 3.2 and 3.3.
)
def assertValidX3dVersion(fieldName, value):
    """
    Utility function to assert type validity of x3dVersionChoices value, otherwise raise X3DTypeError with diagnostic message.
    Note MFString enumeration values are provided in XML syntax, so check validity accordingly.
    """
    if  not value:
        return True # no failure on empty defaults
    if str(MFString(value).XML()) in X3DVERSIONCHOICES:
        # print ('*** assertValidX3dVersion ' + fieldName + ' str(MFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    if isinstance(value, (SFString, str)) and str(SFString(value).XML()) in X3DVERSIONCHOICES:
        # print ('*** assertValidX3dVersion ' + fieldName + ' str(SFString(' + str(value) + ').XML())=' + str(MFString(value).XML()), flush=True) # diagnostic
        return True
    raise X3DTypeError(fieldName + ' value=\'' + MFString(value).XML() + '\' does not match allowed enumerations in X3DVERSIONCHOICES=' + str(X3DVERSIONCHOICES))

###############################################

# Utility Functions

def metaDiagnostics(self, headElement=None):
    """
    Utility function to return any meta info, hint, warning, error, TODO values in this model.
    """
    if  headElement is None:
        headElement = self
    if  isinstance(headElement, X3D):
        headElement = headElement.head
    # print('type(headElement)=' + str(type(headElement)), flush=True) # diagnostic
    if  isinstance(headElement, head):
        result = "meta "
        for each in headElement.children:
            if isinstance(each, meta) and each.name in ('info', 'hint', 'warning', 'error', 'TODO'):
                result += each.name.strip() + ': ' + each.content.strip()
                if  result.endswith('.') or result.endswith(','):
                    result += ' '
                else:
                    result += ', '
        if  result.strip() != "meta":
            return result.rstrip(', ').strip()
    return ''

###############################################

# Field Validation Functions

# Type-specific functions to check for valid values, throw exception if illegal value is found

def fixBoolean(value, default=None):
    """
    Utility function to convert boolean to corresponding Python value.
    """
    # if _DEBUG: print('fixBoolean(value=' + str(value) + ', default=' + str(default) + ')', flush=True)
    if  value is None:
        return default
    if isinstance(value, list) and len(value) == 1:
        # if _DEBUG: print('fixBoolean downcasting by resetting singleton list value=' + str(value) + ' as value=' + str(value[0]), flush=True)
        value = value[0]
    elif isinstance(value, SFBool):
        return value.value # dereference
    elif isinstance(value, MFBool) and len(value) == 1:
        return value.value[0] # dereference
    if value in ('true', 'True'):
        return True
    if value in ('false', 'False'):
        return False
    if isinstance(value, bool):
        return value
    if isinstance(value, list):
        index = 0
        result = value
        for each in value:
#           print('each=' + str(each), flush=True) # debug
            if  each in ('true', 'True'):
                result[index] = True
            elif each in ('false', 'False'):
                result[index] = False
            while isinstance(each, list) and len(each) == 1:
                # if _DEBUG: print('fixBoolean downcasting by extracting singleton list value[' + str(index) + ']=' + str(each) + ' as each[0]=' + str(each[0]), flush=True)
                result[index] = each[0]
            if not isinstance(result[index], bool):
                # print(flush=True)
                raise X3DTypeError('fixBoolean(value=' + str(value) + ') MFBool value[' + str(index) + ']=' + str(each) + ', result[' + str(index) + ']=' + result[index] + ' with type=' + str(type(value)) + ' is not a valid Python bool expression')
            index += 1
        # if _DEBUG: print('...fixBoolean result=' + str(result), flush=True)
        return result
    # print(flush=True)
    raise X3DTypeError('fixBoolean(value=' + str(value) + ') with type=' + str(type(value)) + ') is not a valid Python bool')

def isPositive(value):
    """
    Utility function to confirm positive value(s) greater than or equal to zero.
    """
    if  value is None:
        return None
    if isinstance(value, list) and any(isinstance(x, tuple) for x in value):
        for each in value:
            for element in each:
                if element <= 0:
                    return False
        return True
    if isinstance(value, (list, tuple)):
        for each in value:
            if each <= 0:
                return False
        return True
    if isinstance(value, (int, float)):
        return value > 0
    raise X3DTypeError('isPositive(value=' + str(value) + ') with type=' + str(type(value)) + ') is not a valid Python number')

def assertPositive(fieldName, value):
    """
    Utility function to raise X3DTypeError if not isPositive(value).
    """
    # if _DEBUG: print('* debug: assertPositive(' + str(fieldName) + ', ' + str(value) + ')', flush=True);
    assert isPositive(value), fieldName + '=' + str(value) + ' fails assertPositive requirements: value(s) greater than or equal to zero'

def isNonNegative(value):
    """
    Utility function to confirm nonnegative value(s) greater than or equal to zero.
    """
    if  value is None:
        return None
    if isinstance(value, list) and any(isinstance(x, tuple) for x in value):
        for each in value:
            for element in each:
                if element < 0:
                    return False
        return True
    if isinstance(value, (list, tuple)):
        # if _DEBUG: print('isNonNegative: ', value, flush=True);
        for each in value:
            if each < 0:
                return False
        return True
    if isinstance(value, (int, float)):
        return value >= 0
    raise X3DTypeError('isNonNegative(value=' + str(value) + ') with type=' + str(type(value)) + ') is not a valid Python number')

def assertNonNegative(fieldName, value):
    """
    Utility function to raise X3DTypeError if not isNonNegative(value).
    """
    # if _DEBUG: print('* debug: assertNonNegative(' + str(fieldName) + ', ' + str(value) + ')', flush=True);
    assert isNonNegative(value), fieldName + '=' + str(value) + ' fails assertNonNegative requirements: value(s) greater than or equal to zero'

def isZeroToOne(value):
    """
    Utility function to confirm value(s) in range [0..1]
    """
    # if True or _DEBUG: print('* debug: isZeroToOne(' + str(value) + ')', flush=True);
    if  value is None:
        return None
    if isinstance(value, (list, tuple)):
        for each in value:
            if isinstance(each, (list, tuple)):
                for another in each:
                    if not 0 <= another <= 1:
                        return False
            elif not 0 <= each <= 1:
                return False
        return True
    if isinstance(value, (int, float)):
        return 0 <= value <= 1
    raise X3DTypeError('isZeroToOne(value=' + str(value) + ') with type=' + str(type(value)) + ') is not a valid Python number')

def assertZeroToOne(fieldName, value):
    """
    Utility function to raise X3DTypeError if not isZeroToOne(value)
    """
    # if _DEBUG: print('* debug: assertZeroToOne(' + str(fieldName) + ', ' + str(value) + ')', flush=True);
    assert isZeroToOne(value), fieldName + '=' + str(value) + ' fails assertZeroToOne requirements: value(s) in range [0..1]'

def isLessThanEquals(value, maximum):
    """
    Utility function to confirm value(s) less than or equal to maximum.
    """
    # if True or _DEBUG: print('* debug: isLessThanEquals(' + str(value) + ')', flush=True);
    if  value is None:
        return None
    if isinstance(value, list) and any(isinstance(x, tuple) for x in value):
        for each in value:
            for element in each:
                if element > maximum:
                    return False
        return True
    if isinstance(value, (list, tuple)):
        for each in value:
            if each > maximum:
                return False
        return True
    if isinstance(value, (int, float)):
        return value <= maximum
    raise X3DTypeError('isLessThanEquals(value=' + str(value) + ') with type=' + str(type(value)) + ') is not a valid Python number')

def assertLessThanEquals(fieldName, value, maximum):
    """
    Utility function to raise X3DTypeError if not isLessThanEquals(value)
    """
    # if _DEBUG: print('* debug: assertLessThanEquals(' + str(fieldName) + ', ' + str(value) + ')', flush=True);
    assert isLessThanEquals(value, maximum), fieldName + '=' + str(value) + ' fails assertLessThanEquals maximum=' + str(maximum)

def isLessThan(value, maximum):
    """
    Utility function to confirm value(s) less than maximum.
    """
    # if True or _DEBUG: print('* debug: isLessThan(' + str(value) + ')', flush=True);
    if  value is None:
        return None
    if isinstance(value, list) and any(isinstance(x, tuple) for x in value):
        for each in value:
            for element in each:
                if element >= maximum:
                    return False
        return True
    if isinstance(value, (list, tuple)):
        for each in value:
            if each >= maximum:
                return False
        return True
    if isinstance(value, (int, float)):
        return value < maximum
    raise X3DTypeError('isLessThan(value=' + str(value) + ') with type=' + str(type(value)) + ') is not a valid Python number')

def assertLessThan(fieldName, value, maximum):
    """
    Utility function to raise X3DTypeError if not isLessThan(value)
    """
    # if _DEBUG: print('* debug: assertLessThan(' + str(fieldName) + ', ' + str(value) + ')', flush=True);
    assert isLessThan(value, maximum), fieldName + '=' + str(value) + ' fails assertLessThan maximum=' + str(maximum)

######
def isGreaterThanEquals(value, minimum):
    """
    Utility function to confirm value(s) less than or equal to minimum.
    """
    # if True or _DEBUG: print('* debug: isGreaterThanEquals(' + str(value) + ')', flush=True);
    if  value is None:
        return None
    if isinstance(value, list) and any(isinstance(x, tuple) for x in value):
        for each in value:
            for element in each:
                if element < minimum:
                    return False
        return True
    if isinstance(value, (list, tuple)):
        for each in value:
            if each < minimum:
                return False
        return True
    if isinstance(value, (int, float)):
        return value >= minimum
    raise X3DTypeError('isGreaterThanEquals(value=' + str(value) + ') with type=' + str(type(value)) + ') is not a valid Python number')

def assertGreaterThanEquals(fieldName, value, minimum):
    """
    Utility function to raise X3DTypeError if not isGreaterThanEquals(value)
    """
    # if _DEBUG: print('* debug: assertGreaterThanEquals(' + str(fieldName) + ', ' + str(value) + ')', flush=True);
    assert isGreaterThanEquals(value, minimum), fieldName + '=' + str(value) + ' fails assertGreaterThanEquals minimum=' + str(minimum)

def isGreaterThan(value, minimum):
    """
    Utility function to confirm value(s) less than minimum.
    """
    # if True or _DEBUG: print('* debug: isGreaterThan(' + str(value) + ')', flush=True);
    if isinstance(value, list) and any(isinstance(x, tuple) for x in value):
        for each in value:
            for element in each:
                if element <= minimum:
                    return False
        return True
    if isinstance(value, (list, tuple)):
        for each in value:
            if each <= minimum:
                return False
        return True
    if isinstance(value, (int, float)):
        return value > minimum
    raise X3DTypeError('isGreaterThan(value=' + str(value) + ') with type=' + str(type(value)) + ') is not a valid Python number')

def assertGreaterThan(fieldName, value, minimum):
    """
    Utility function to raise X3DTypeError if not isGreaterThan(value)
    """
    # if _DEBUG: print('* debug: assertGreaterThan(' + str(fieldName) + ', ' + str(value) + ')', flush=True);
    assert isGreaterThan(value, minimum), fieldName + '=' + str(value) + ' fails assertGreaterThan minimum=' + str(minimum)

def isBoundingBox(value):
    """
    Utility function to confirm legal X3D bounding box value of (-1 -1 -1) or nonnegative triple.
    """
    if value is None:
        return None
    # if True or _DEBUG: print('* debug: isBoundingBox(' + str(value) + ')', 'isinstance(value, tuple)=' + str(isinstance(value, tuple)), 'len(value)=' + str(len(value)), flush=True);
    if isinstance(value, (list, tuple)):
        if len(value) != 3:
            return False
        if value[0] == -1 and value[1] == -1 and value[2] == -1:
            return True
        return isNonNegative(value) # legal bounding box tuple
    raise X3DTypeError('isBoundingBox(value=' + str(value) + ') with type=' + str(type(value)) + ') is not a valid Python numeric triple')

def assertBoundingBox(fieldName, value):
    """
    Utility function to raise X3DTypeError if not isBoundingBox(value)
    """
    # if True or _DEBUG: print('* debug: assertBoundingBox(' + str(fieldName) + ', ' + str(value) + ')', flush=True);
    assert isBoundingBox(value), fieldName + '=' + str(value) + ' fails assertBoundingBox requirements: must be (-1, -1, -1) or non-negative 3-tuple'

def isValidSFBool(value):
    """
    Utility function to determine type validity of a SFBool value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFBool) and not isinstance(value, MFBool):
            # if _DEBUG: print('SFBool type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFBool)=' + str(isinstance(value, SFBool)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFBool):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFBool) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, bool):
        return False
    return True

def assertValidSFBool(value):
    """
    Utility function to assert type validity of a SFBool value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFBool) and not isinstance(value, MFBool):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFBool')
    if isinstance(value, SFBool):
        value = value.value # dereference value from this base type
    if isinstance(value, MFBool) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, bool):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid bool value (True or False) for SFBool')
    if not isValidSFBool(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python bool value (True or False) for SFBool')
    return True

def isValidMFBool(value):
    """
    Utility function to determine type validity of a MFBool value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFBool) and not isinstance(value, MFBool):
            # if _DEBUG: print('MFBool type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFBool)=' + str(isinstance(value, MFBool)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFBool):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFBool):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFBool):
            each = each.value # dereference
        if not isinstance(each, bool):
            return False
    return True

def assertValidMFBool(value):
    """
    Utility function to assert type validity of a MFBool value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFBool) and not isinstance(value, MFBool):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFBool')
    if isinstance(value, MFBool):
        value = value.value # dereference value from this base type
    if isinstance(value, SFBool) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFBool')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFBool):
            each = each.value # dereference
        if not isinstance(each, bool):
            # print(flush=True)
            raise X3DTypeError('MFBool list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid bool')
    if not isValidMFBool(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFBool')
    return True

def isValidSFColor(value):
    """
    Utility function to determine type validity of a SFColor value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFColor) and not isinstance(value, MFColor):
            # if _DEBUG: print('SFColor type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFColor)=' + str(isinstance(value, SFColor)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFColor):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFColor) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFColor):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
        if (each < 0) or (each > 1):
            return False
    if tupleCount != 3:
        return False
    if not isZeroToOne(value):
        return False
    return True

def assertValidSFColor(value):
    """
    Utility function to assert type validity of a SFColor value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFColor) and not isinstance(value, MFColor):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFColor')
    if isinstance(value, SFColor):
        value = value.value # dereference value from this base type
    if isinstance(value, MFColor) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFColor')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFColor):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            # print(flush=True)
            raise X3DTypeError('SFColor list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
        if (each < 0) or (each > 1):
            # print(flush=True)
            raise X3DTypeError('SFColor' + str(value)[:100] + ' has value ' + str(each) + ' with type=' + str(type(value)) + ' is  out of range [0..1] and is not a valid SFColor')
    if tupleCount != 3:
        # print(flush=True)
        raise X3DTypeError('SFColor ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 3')
    assertZeroToOne('SFColor', value)
    if not isValidSFColor(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFColor')
    return True

def isValidMFColor(value):
    """
    Utility function to determine type validity of a MFColor value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFColor) and not isinstance(value, MFColor):
            # if _DEBUG: print('MFColor type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFColor)=' + str(isinstance(value, MFColor)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFColor):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFColor):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        _index += 1
        if len(each) % MFColor().TUPLE_SIZE() != 0:
            # if _DEBUG:
            print('* isValidMFColor tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFColor().TUPLE_SIZE()=' + str(MFColor().TUPLE_SIZE()) + ' for value=' + str(value), flush=True)
            return False
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
            if (element < 0) or (element > 1):
                return False
    if not isZeroToOne(value):
        return False
    return True

def assertValidMFColor(value):
    """
    Utility function to assert type validity of a MFColor value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFColor) and not isinstance(value, MFColor):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFColor')
    if isinstance(value, MFColor):
        value = value.value # dereference value from this base type
    if isinstance(value, SFColor) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFColor')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    if isinstance(value, list):
        _index = 0
        for each in value:
            if len(each) % MFColor().TUPLE_SIZE() != 0:
                # print(flush=True)
                raise X3DValueError('MFColor tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFColor().TUPLE_SIZE()=' + str(MFColor().TUPLE_SIZE()) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFColor)):
#                # print(flush=True)
#                raise X3DTypeError('MFColor element #' + str(_index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
            _index += 1
            if isinstance(each, tuple):
                for element in each:
                    if not isinstance(element, float) and not isinstance(element, int):
                        # print(flush=True)
                        raise X3DTypeError('MFColor element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
                    if (element < 0) or (element > 1):
                        # print(flush=True)
                        raise X3DTypeError('MFColor' + str(value)[:100] + ' has value ' + str(element) + ' with type=' + str(type(value)) + ' out of range [0..1] and is not a valid MFColor')
    assertZeroToOne('MFColor', value)
    if not isValidMFColor(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFColor')
    return True

def isValidSFColorRGBA(value):
    """
    Utility function to determine type validity of a SFColorRGBA value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFColorRGBA) and not isinstance(value, MFColorRGBA):
            # if _DEBUG: print('SFColorRGBA type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFColorRGBA)=' + str(isinstance(value, SFColorRGBA)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFColorRGBA):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFColorRGBA) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFColorRGBA):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
        if (each < 0) or (each > 1):
            return False
    if tupleCount != 4:
        return False
    if not isZeroToOne(value):
        return False
    return True

def assertValidSFColorRGBA(value):
    """
    Utility function to assert type validity of a SFColorRGBA value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFColorRGBA) and not isinstance(value, MFColorRGBA):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFColorRGBA')
    if isinstance(value, SFColorRGBA):
        value = value.value # dereference value from this base type
    if isinstance(value, MFColorRGBA) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFColorRGBA')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFColorRGBA):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            # print(flush=True)
            raise X3DTypeError('SFColorRGBA list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
        if (each < 0) or (each > 1):
            # print(flush=True)
            raise X3DTypeError('SFColorRGBA' + str(value)[:100] + ' has value ' + str(each) + ' with type=' + str(type(value)) + ' is  out of range [0..1] and is not a valid SFColorRGBA')
    if tupleCount != 4:
        # print(flush=True)
        raise X3DTypeError('SFColorRGBA ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 4')
    assertZeroToOne('SFColorRGBA', value)
    if not isValidSFColorRGBA(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFColorRGBA')
    return True

def isValidMFColorRGBA(value):
    """
    Utility function to determine type validity of a MFColorRGBA value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFColorRGBA) and not isinstance(value, MFColorRGBA):
            # if _DEBUG: print('MFColorRGBA type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFColorRGBA)=' + str(isinstance(value, MFColorRGBA)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFColorRGBA):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFColorRGBA):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        _index += 1
        if len(each) % MFColorRGBA().TUPLE_SIZE() != 0:
            # if _DEBUG:
            print('* isValidMFColorRGBA tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFColorRGBA().TUPLE_SIZE()=' + str(MFColorRGBA().TUPLE_SIZE()) + ' for value=' + str(value), flush=True)
            return False
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
            if (element < 0) or (element > 1):
                return False
    if not isZeroToOne(value):
        return False
    return True

def assertValidMFColorRGBA(value):
    """
    Utility function to assert type validity of a MFColorRGBA value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFColorRGBA) and not isinstance(value, MFColorRGBA):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFColorRGBA')
    if isinstance(value, MFColorRGBA):
        value = value.value # dereference value from this base type
    if isinstance(value, SFColorRGBA) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFColorRGBA')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    if isinstance(value, list):
        _index = 0
        for each in value:
            if len(each) % MFColorRGBA().TUPLE_SIZE() != 0:
                # print(flush=True)
                raise X3DValueError('MFColorRGBA tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFColorRGBA().TUPLE_SIZE()=' + str(MFColorRGBA().TUPLE_SIZE()) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFColorRGBA)):
#                # print(flush=True)
#                raise X3DTypeError('MFColorRGBA element #' + str(_index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
            _index += 1
            if isinstance(each, tuple):
                for element in each:
                    if not isinstance(element, float) and not isinstance(element, int):
                        # print(flush=True)
                        raise X3DTypeError('MFColorRGBA element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
                    if (element < 0) or (element > 1):
                        # print(flush=True)
                        raise X3DTypeError('MFColorRGBA' + str(value)[:100] + ' has value ' + str(element) + ' with type=' + str(type(value)) + ' out of range [0..1] and is not a valid MFColorRGBA')
    assertZeroToOne('MFColorRGBA', value)
    if not isValidMFColorRGBA(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFColorRGBA')
    return True

def isValidSFDouble(value):
    """
    Utility function to determine type validity of a SFDouble value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFDouble) and not isinstance(value, MFDouble):
            # if _DEBUG: print('SFDouble type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFDouble)=' + str(isinstance(value, SFDouble)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFDouble):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFDouble) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, float) and not isinstance(value, int):
        return False
    return True

def assertValidSFDouble(value):
    """
    Utility function to assert type validity of a SFDouble value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFDouble) and not isinstance(value, MFDouble):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFDouble')
    if isinstance(value, SFDouble):
        value = value.value # dereference value from this base type
    if isinstance(value, MFDouble) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, float) and not isinstance(value, int):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFDouble')
    if not isValidSFDouble(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python float value for SFDouble')
    return True

def isValidMFDouble(value):
    """
    Utility function to determine type validity of a MFDouble value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFDouble) and not isinstance(value, MFDouble):
            # if _DEBUG: print('MFDouble type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFDouble)=' + str(isinstance(value, MFDouble)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFDouble):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFDouble):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFDouble):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    return True

def assertValidMFDouble(value):
    """
    Utility function to assert type validity of a MFDouble value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFDouble) and not isinstance(value, MFDouble):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFDouble')
    if isinstance(value, MFDouble):
        value = value.value # dereference value from this base type
    if isinstance(value, SFDouble) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFDouble')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFDouble):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            # print(flush=True)
            raise X3DTypeError('MFDouble list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if not isValidMFDouble(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFDouble')
    return True

def isValidSFFloat(value):
    """
    Utility function to determine type validity of a SFFloat value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFFloat) and not isinstance(value, MFFloat):
            # if _DEBUG: print('SFFloat type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFFloat)=' + str(isinstance(value, SFFloat)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFFloat):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFFloat) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, float) and not isinstance(value, int):
        return False
    return True

def assertValidSFFloat(value):
    """
    Utility function to assert type validity of a SFFloat value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFFloat) and not isinstance(value, MFFloat):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFFloat')
    if isinstance(value, SFFloat):
        value = value.value # dereference value from this base type
    if isinstance(value, MFFloat) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, float) and not isinstance(value, int):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFFloat')
    if not isValidSFFloat(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python float value for SFFloat')
    return True

def isValidMFFloat(value):
    """
    Utility function to determine type validity of a MFFloat value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFFloat) and not isinstance(value, MFFloat):
            # if _DEBUG: print('MFFloat type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFFloat)=' + str(isinstance(value, MFFloat)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFFloat):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFFloat):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFFloat):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    return True

def assertValidMFFloat(value):
    """
    Utility function to assert type validity of a MFFloat value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFFloat) and not isinstance(value, MFFloat):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFFloat')
    if isinstance(value, MFFloat):
        value = value.value # dereference value from this base type
    if isinstance(value, SFFloat) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFFloat')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFFloat):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            # print(flush=True)
            raise X3DTypeError('MFFloat list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if not isValidMFFloat(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFFloat')
    return True

def isValidSFImage(value):
    """
    Utility function to determine type validity of a SFImage value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFImage) and not isinstance(value, MFImage):
            # if _DEBUG: print('SFImage type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFImage)=' + str(isinstance(value, SFImage)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFImage):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFImage) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, list):
        return False
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFImage):
            each = each.value # dereference
        if not isinstance(each, int):
            return False
    if len(value) > 0: # SFImage list length checks
        if 0 < len(value) < 3:
            return False # SFImage list must start with width, height and number of components (0..4)
        width = value[0]
        height = value[1]
        numberComponents = value[2]
        if  len(value) != (width * height) + 3: # assumes each value in array has all component values in single integer
            print('SFImage array length of ' + str(len(value)) + ' does not equal (width=' + str(width)+ ' * height=' + str(height)+ ') + 3) = ' + str(width * height * numberComponents + 3) + ' (numberComponents=' + numberComponents + ')', flush=True)
            return False # SFImage has invalid list length
    return True

def assertValidSFImage(value):
    """
    Utility function to assert type validity of a SFImage value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFImage) and not isinstance(value, MFImage):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFImage')
    if isinstance(value, SFImage):
        value = value.value # dereference value from this base type
    if isinstance(value, MFImage) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for SFImage')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFImage):
            each = each.value # dereference
        if not isinstance(each, int):
            # print(flush=True)
            raise X3DTypeError('SFImage list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid int')
    if not isValidSFImage(value):
        # print(flush=True)
        diagnostic = ''
        if len(value) > 0: # SFImage list length checks
            if 0 < len(value) < 3:
                diagnostic = 'SFImage list must start with width, height and number of components (0..4)'
            else:
                width = value[0]
                height = value[1]
                numberComponents = value[2]
                diagnostic = ' array length of ' + str(len(value)) + ' does not equal (width=' + str(width)+ ' * height=' + str(height)+ ') + 3) = ' + str(width * height + 3)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for SFImage' + diagnostic)
    return True

def isValidMFImage(value):
    """
    Utility function to determine type validity of a MFImage value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFImage) and not isinstance(value, MFImage):
            # if _DEBUG: print('MFImage type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFImage)=' + str(isinstance(value, MFImage)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFImage):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFImage):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFImage):
            each = each.value # dereference
        if not isinstance(each, int):
            return False
    return True

def assertValidMFImage(value):
    """
    Utility function to assert type validity of a MFImage value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFImage) and not isinstance(value, MFImage):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFImage')
    if isinstance(value, MFImage):
        value = value.value # dereference value from this base type
    if isinstance(value, SFImage) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFImage')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFImage):
            each = each.value # dereference
        if not isinstance(each, int):
            # print(flush=True)
            raise X3DTypeError('MFImage list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid int')
    if not isValidMFImage(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFImage')
    return True

def isValidSFInt32(value):
    """
    Utility function to determine type validity of a SFInt32 value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFInt32) and not isinstance(value, MFInt32):
            # if _DEBUG: print('SFInt32 type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFInt32)=' + str(isinstance(value, SFInt32)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFInt32):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFInt32) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, int):
        return False
    return True

def assertValidSFInt32(value):
    """
    Utility function to assert type validity of a SFInt32 value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFInt32) and not isinstance(value, MFInt32):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFInt32')
    if isinstance(value, SFInt32):
        value = value.value # dereference value from this base type
    if isinstance(value, MFInt32) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, int):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid int value for SFInt32')
    if not isValidSFInt32(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python int value for SFInt32')
    return True

def isValidMFInt32(value):
    """
    Utility function to determine type validity of a MFInt32 value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFInt32) and not isinstance(value, MFInt32):
            # if _DEBUG: print('MFInt32 type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFInt32)=' + str(isinstance(value, MFInt32)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFInt32):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFInt32):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFInt32):
            each = each.value # dereference
        if not isinstance(each, int):
            return False
    return True

def assertValidMFInt32(value):
    """
    Utility function to assert type validity of a MFInt32 value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFInt32) and not isinstance(value, MFInt32):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFInt32')
    if isinstance(value, MFInt32):
        value = value.value # dereference value from this base type
    if isinstance(value, SFInt32) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFInt32')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFInt32):
            each = each.value # dereference
        if not isinstance(each, int):
            # print(flush=True)
            raise X3DTypeError('MFInt32 list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid int')
    if not isValidMFInt32(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFInt32')
    return True

def isValidSFMatrix3d(value):
    """
    Utility function to determine type validity of a SFMatrix3d value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFMatrix3d) and not isinstance(value, MFMatrix3d):
            # if _DEBUG: print('SFMatrix3d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFMatrix3d)=' + str(isinstance(value, SFMatrix3d)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFMatrix3d):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFMatrix3d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFMatrix3d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 9:
        return False
    return True

def assertValidSFMatrix3d(value):
    """
    Utility function to assert type validity of a SFMatrix3d value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFMatrix3d) and not isinstance(value, MFMatrix3d):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFMatrix3d')
    if isinstance(value, SFMatrix3d):
        value = value.value # dereference value from this base type
    if isinstance(value, MFMatrix3d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFMatrix3d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFMatrix3d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            # print(flush=True)
            raise X3DTypeError('SFMatrix3d list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 9:
        # print(flush=True)
        raise X3DTypeError('SFMatrix3d ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 9')
    if not isValidSFMatrix3d(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFMatrix3d')
    return True

def isValidMFMatrix3d(value):
    """
    Utility function to determine type validity of a MFMatrix3d value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFMatrix3d) and not isinstance(value, MFMatrix3d):
            # if _DEBUG: print('MFMatrix3d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFMatrix3d)=' + str(isinstance(value, MFMatrix3d)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFMatrix3d):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFMatrix3d):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        _index += 1
        if len(each) % MFMatrix3d().TUPLE_SIZE() != 0:
            # if _DEBUG:
            print('* isValidMFMatrix3d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFMatrix3d().TUPLE_SIZE()=' + str(MFMatrix3d().TUPLE_SIZE()) + ' for value=' + str(value), flush=True)
            return False
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFMatrix3d(value):
    """
    Utility function to assert type validity of a MFMatrix3d value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFMatrix3d) and not isinstance(value, MFMatrix3d):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFMatrix3d')
    if isinstance(value, MFMatrix3d):
        value = value.value # dereference value from this base type
    if isinstance(value, SFMatrix3d) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFMatrix3d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    if isinstance(value, list):
        _index = 0
        for each in value:
            if len(each) % MFMatrix3d().TUPLE_SIZE() != 0:
                # print(flush=True)
                raise X3DValueError('MFMatrix3d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFMatrix3d().TUPLE_SIZE()=' + str(MFMatrix3d().TUPLE_SIZE()) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFMatrix3d)):
#                # print(flush=True)
#                raise X3DTypeError('MFMatrix3d element #' + str(_index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
            _index += 1
            if isinstance(each, tuple):
                for element in each:
                    if not isinstance(element, float) and not isinstance(element, int):
                        # print(flush=True)
                        raise X3DTypeError('MFMatrix3d element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    if not isValidMFMatrix3d(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFMatrix3d')
    return True

def isValidSFMatrix3f(value):
    """
    Utility function to determine type validity of a SFMatrix3f value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFMatrix3f) and not isinstance(value, MFMatrix3f):
            # if _DEBUG: print('SFMatrix3f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFMatrix3f)=' + str(isinstance(value, SFMatrix3f)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFMatrix3f):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFMatrix3f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFMatrix3f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 9:
        return False
    return True

def assertValidSFMatrix3f(value):
    """
    Utility function to assert type validity of a SFMatrix3f value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFMatrix3f) and not isinstance(value, MFMatrix3f):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFMatrix3f')
    if isinstance(value, SFMatrix3f):
        value = value.value # dereference value from this base type
    if isinstance(value, MFMatrix3f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFMatrix3f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFMatrix3f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            # print(flush=True)
            raise X3DTypeError('SFMatrix3f list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 9:
        # print(flush=True)
        raise X3DTypeError('SFMatrix3f ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 9')
    if not isValidSFMatrix3f(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFMatrix3f')
    return True

def isValidMFMatrix3f(value):
    """
    Utility function to determine type validity of a MFMatrix3f value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFMatrix3f) and not isinstance(value, MFMatrix3f):
            # if _DEBUG: print('MFMatrix3f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFMatrix3f)=' + str(isinstance(value, MFMatrix3f)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFMatrix3f):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFMatrix3f):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        _index += 1
        if len(each) % MFMatrix3f().TUPLE_SIZE() != 0:
            # if _DEBUG:
            print('* isValidMFMatrix3f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFMatrix3f().TUPLE_SIZE()=' + str(MFMatrix3f().TUPLE_SIZE()) + ' for value=' + str(value), flush=True)
            return False
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFMatrix3f(value):
    """
    Utility function to assert type validity of a MFMatrix3f value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFMatrix3f) and not isinstance(value, MFMatrix3f):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFMatrix3f')
    if isinstance(value, MFMatrix3f):
        value = value.value # dereference value from this base type
    if isinstance(value, SFMatrix3f) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFMatrix3f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    if isinstance(value, list):
        _index = 0
        for each in value:
            if len(each) % MFMatrix3f().TUPLE_SIZE() != 0:
                # print(flush=True)
                raise X3DValueError('MFMatrix3f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFMatrix3f().TUPLE_SIZE()=' + str(MFMatrix3f().TUPLE_SIZE()) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFMatrix3f)):
#                # print(flush=True)
#                raise X3DTypeError('MFMatrix3f element #' + str(_index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
            _index += 1
            if isinstance(each, tuple):
                for element in each:
                    if not isinstance(element, float) and not isinstance(element, int):
                        # print(flush=True)
                        raise X3DTypeError('MFMatrix3f element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    if not isValidMFMatrix3f(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFMatrix3f')
    return True

def isValidSFMatrix4d(value):
    """
    Utility function to determine type validity of a SFMatrix4d value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFMatrix4d) and not isinstance(value, MFMatrix4d):
            # if _DEBUG: print('SFMatrix4d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFMatrix4d)=' + str(isinstance(value, SFMatrix4d)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFMatrix4d):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFMatrix4d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFMatrix4d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 16:
        return False
    return True

def assertValidSFMatrix4d(value):
    """
    Utility function to assert type validity of a SFMatrix4d value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFMatrix4d) and not isinstance(value, MFMatrix4d):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFMatrix4d')
    if isinstance(value, SFMatrix4d):
        value = value.value # dereference value from this base type
    if isinstance(value, MFMatrix4d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFMatrix4d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFMatrix4d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            # print(flush=True)
            raise X3DTypeError('SFMatrix4d list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 16:
        # print(flush=True)
        raise X3DTypeError('SFMatrix4d ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 16')
    if not isValidSFMatrix4d(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFMatrix4d')
    return True

def isValidMFMatrix4d(value):
    """
    Utility function to determine type validity of a MFMatrix4d value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFMatrix4d) and not isinstance(value, MFMatrix4d):
            # if _DEBUG: print('MFMatrix4d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFMatrix4d)=' + str(isinstance(value, MFMatrix4d)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFMatrix4d):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFMatrix4d):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        _index += 1
        if len(each) % MFMatrix4d().TUPLE_SIZE() != 0:
            # if _DEBUG:
            print('* isValidMFMatrix4d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFMatrix4d().TUPLE_SIZE()=' + str(MFMatrix4d().TUPLE_SIZE()) + ' for value=' + str(value), flush=True)
            return False
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFMatrix4d(value):
    """
    Utility function to assert type validity of a MFMatrix4d value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFMatrix4d) and not isinstance(value, MFMatrix4d):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFMatrix4d')
    if isinstance(value, MFMatrix4d):
        value = value.value # dereference value from this base type
    if isinstance(value, SFMatrix4d) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFMatrix4d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    if isinstance(value, list):
        _index = 0
        for each in value:
            if len(each) % MFMatrix4d().TUPLE_SIZE() != 0:
                # print(flush=True)
                raise X3DValueError('MFMatrix4d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFMatrix4d().TUPLE_SIZE()=' + str(MFMatrix4d().TUPLE_SIZE()) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFMatrix4d)):
#                # print(flush=True)
#                raise X3DTypeError('MFMatrix4d element #' + str(_index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
            _index += 1
            if isinstance(each, tuple):
                for element in each:
                    if not isinstance(element, float) and not isinstance(element, int):
                        # print(flush=True)
                        raise X3DTypeError('MFMatrix4d element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    if not isValidMFMatrix4d(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFMatrix4d')
    return True

def isValidSFMatrix4f(value):
    """
    Utility function to determine type validity of a SFMatrix4f value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFMatrix4f) and not isinstance(value, MFMatrix4f):
            # if _DEBUG: print('SFMatrix4f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFMatrix4f)=' + str(isinstance(value, SFMatrix4f)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFMatrix4f):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFMatrix4f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFMatrix4f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 16:
        return False
    return True

def assertValidSFMatrix4f(value):
    """
    Utility function to assert type validity of a SFMatrix4f value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFMatrix4f) and not isinstance(value, MFMatrix4f):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFMatrix4f')
    if isinstance(value, SFMatrix4f):
        value = value.value # dereference value from this base type
    if isinstance(value, MFMatrix4f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFMatrix4f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFMatrix4f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            # print(flush=True)
            raise X3DTypeError('SFMatrix4f list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 16:
        # print(flush=True)
        raise X3DTypeError('SFMatrix4f ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 16')
    if not isValidSFMatrix4f(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFMatrix4f')
    return True

def isValidMFMatrix4f(value):
    """
    Utility function to determine type validity of a MFMatrix4f value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFMatrix4f) and not isinstance(value, MFMatrix4f):
            # if _DEBUG: print('MFMatrix4f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFMatrix4f)=' + str(isinstance(value, MFMatrix4f)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFMatrix4f):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFMatrix4f):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        _index += 1
        if len(each) % MFMatrix4f().TUPLE_SIZE() != 0:
            # if _DEBUG:
            print('* isValidMFMatrix4f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFMatrix4f().TUPLE_SIZE()=' + str(MFMatrix4f().TUPLE_SIZE()) + ' for value=' + str(value), flush=True)
            return False
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFMatrix4f(value):
    """
    Utility function to assert type validity of a MFMatrix4f value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFMatrix4f) and not isinstance(value, MFMatrix4f):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFMatrix4f')
    if isinstance(value, MFMatrix4f):
        value = value.value # dereference value from this base type
    if isinstance(value, SFMatrix4f) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFMatrix4f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    if isinstance(value, list):
        _index = 0
        for each in value:
            if len(each) % MFMatrix4f().TUPLE_SIZE() != 0:
                # print(flush=True)
                raise X3DValueError('MFMatrix4f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFMatrix4f().TUPLE_SIZE()=' + str(MFMatrix4f().TUPLE_SIZE()) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFMatrix4f)):
#                # print(flush=True)
#                raise X3DTypeError('MFMatrix4f element #' + str(_index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
            _index += 1
            if isinstance(each, tuple):
                for element in each:
                    if not isinstance(element, float) and not isinstance(element, int):
                        # print(flush=True)
                        raise X3DTypeError('MFMatrix4f element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    if not isValidMFMatrix4f(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFMatrix4f')
    return True

def isValidSFNode(value):
    """
    Utility function to determine type validity of a SFNode value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFNode) and not isinstance(value, MFNode):
            # if _DEBUG: print('SFNode type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFNode)=' + str(isinstance(value, SFNode)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFNode):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFNode) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, object):
        return False
    return True

def assertValidSFNode(value):
    """
    Utility function to assert type validity of a SFNode value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFNode) and not isinstance(value, MFNode):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFNode')
    if isinstance(value, SFNode):
        value = value.value # dereference value from this base type
    if isinstance(value, MFNode) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, object):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid object value for SFNode')
    if not isValidSFNode(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python object value for SFNode')
    return True

def isValidMFNode(value):
    """
    Utility function to determine type validity of a MFNode value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFNode) and not isinstance(value, MFNode):
            # if _DEBUG: print('MFNode type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFNode)=' + str(isinstance(value, MFNode)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFNode):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFNode):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    for each in value:
        if not isinstance(each, (_X3DNode, _X3DStatement)):
            return False
    return True

def assertValidMFNode(value):
    """
    Utility function to assert type validity of a MFNode value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFNode) and not isinstance(value, MFNode):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFNode')
    if isinstance(value, MFNode):
        value = value.value # dereference value from this base type
    if isinstance(value, SFNode) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    for each in value:
        if not isinstance(each, _X3DNode) and not isinstance(each, _X3DStatement):
            # print(flush=True)
            raise X3DTypeError(str(value)[:100] + ' element ' + str(each) + ', type=' + str(type(each)) + ' is not a valid _X3DNode or _X3DStatement for MFNode')
    if not isValidMFNode(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid _X3DNode or _X3DStatement for MFNode')
    return True

def isValidSFRotation(value):
    """
    Utility function to determine type validity of a SFRotation value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFRotation) and not isinstance(value, MFRotation):
            # if _DEBUG: print('SFRotation type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFRotation)=' + str(isinstance(value, SFRotation)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFRotation):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFRotation) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFRotation):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 4:
        return False
    return True

def assertValidSFRotation(value):
    """
    Utility function to assert type validity of a SFRotation value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFRotation) and not isinstance(value, MFRotation):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFRotation')
    if isinstance(value, SFRotation):
        value = value.value # dereference value from this base type
    if isinstance(value, MFRotation) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFRotation')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFRotation):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            # print(flush=True)
            raise X3DTypeError('SFRotation list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 4:
        # print(flush=True)
        raise X3DTypeError('SFRotation ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 4')
    if not isValidSFRotation(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFRotation')
    return True

def isValidMFRotation(value):
    """
    Utility function to determine type validity of a MFRotation value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFRotation) and not isinstance(value, MFRotation):
            # if _DEBUG: print('MFRotation type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFRotation)=' + str(isinstance(value, MFRotation)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFRotation):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFRotation):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        _index += 1
        if len(each) % MFRotation().TUPLE_SIZE() != 0:
            # if _DEBUG:
            print('* isValidMFRotation tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFRotation().TUPLE_SIZE()=' + str(MFRotation().TUPLE_SIZE()) + ' for value=' + str(value), flush=True)
            return False
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFRotation(value):
    """
    Utility function to assert type validity of a MFRotation value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFRotation) and not isinstance(value, MFRotation):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFRotation')
    if isinstance(value, MFRotation):
        value = value.value # dereference value from this base type
    if isinstance(value, SFRotation) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFRotation')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    if isinstance(value, list):
        _index = 0
        for each in value:
            if len(each) % MFRotation().TUPLE_SIZE() != 0:
                # print(flush=True)
                raise X3DValueError('MFRotation tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFRotation().TUPLE_SIZE()=' + str(MFRotation().TUPLE_SIZE()) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFRotation)):
#                # print(flush=True)
#                raise X3DTypeError('MFRotation element #' + str(_index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
            _index += 1
            if isinstance(each, tuple):
                for element in each:
                    if not isinstance(element, float) and not isinstance(element, int):
                        # print(flush=True)
                        raise X3DTypeError('MFRotation element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    if not isValidMFRotation(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFRotation')
    return True

def isValidSFString(value):
    """
    Utility function to determine type validity of a SFString value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFString) and not isinstance(value, MFString):
            # if _DEBUG: print('SFString type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFString)=' + str(isinstance(value, SFString)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFString):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFString) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, str):
        return False
    return True

def assertValidSFString(value):
    """
    Utility function to assert type validity of a SFString value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFString) and not isinstance(value, MFString):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFString')
    if isinstance(value, SFString):
        value = value.value # dereference value from this base type
    if isinstance(value, MFString) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, str):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid str value for SFString')
    if not isValidSFString(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python str value for SFString')
    return True

def isValidMFString(value):
    """
    Utility function to determine type validity of a MFString value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFString) and not isinstance(value, MFString):
            # if _DEBUG: print('MFString type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFString)=' + str(isinstance(value, MFString)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFString):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFString):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFString):
            each = each.value # dereference
        if not isinstance(each, str):
            return False
    return True

def assertValidMFString(value):
    """
    Utility function to assert type validity of a MFString value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFString) and not isinstance(value, MFString):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFString')
    if isinstance(value, MFString):
        value = value.value # dereference value from this base type
    if isinstance(value, SFString) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFString')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFString):
            each = each.value # dereference
        if not isinstance(each, str):
            # print(flush=True)
            raise X3DTypeError('MFString list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid str')
    if not isValidMFString(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFString')
    return True

def isValidSFTime(value):
    """
    Utility function to determine type validity of a SFTime value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFTime) and not isinstance(value, MFTime):
            # if _DEBUG: print('SFTime type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFTime)=' + str(isinstance(value, SFTime)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFTime):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFTime) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, float) and not isinstance(value, int):
        return False
    return True

def assertValidSFTime(value):
    """
    Utility function to assert type validity of a SFTime value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFTime) and not isinstance(value, MFTime):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFTime')
    if isinstance(value, SFTime):
        value = value.value # dereference value from this base type
    if isinstance(value, MFTime) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, float) and not isinstance(value, int):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid float value for SFTime')
    if not isValidSFTime(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python float value for SFTime')
    return True

def isValidMFTime(value):
    """
    Utility function to determine type validity of a MFTime value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFTime) and not isinstance(value, MFTime):
            # if _DEBUG: print('MFTime type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFTime)=' + str(isinstance(value, MFTime)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFTime):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFTime):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFTime):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    return True

def assertValidMFTime(value):
    """
    Utility function to assert type validity of a MFTime value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFTime) and not isinstance(value, MFTime):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFTime')
    if isinstance(value, MFTime):
        value = value.value # dereference value from this base type
    if isinstance(value, SFTime) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFTime')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    for each in value:
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFTime):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            # print(flush=True)
            raise X3DTypeError('MFTime list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if not isValidMFTime(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFTime')
    return True

def isValidSFVec2d(value):
    """
    Utility function to determine type validity of a SFVec2d value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFVec2d) and not isinstance(value, MFVec2d):
            # if _DEBUG: print('SFVec2d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFVec2d)=' + str(isinstance(value, SFVec2d)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFVec2d):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFVec2d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec2d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 2:
        return False
    return True

def assertValidSFVec2d(value):
    """
    Utility function to assert type validity of a SFVec2d value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFVec2d) and not isinstance(value, MFVec2d):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFVec2d')
    if isinstance(value, SFVec2d):
        value = value.value # dereference value from this base type
    if isinstance(value, MFVec2d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec2d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec2d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            # print(flush=True)
            raise X3DTypeError('SFVec2d list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 2:
        # print(flush=True)
        raise X3DTypeError('SFVec2d ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 2')
    if not isValidSFVec2d(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec2d')
    return True

def isValidMFVec2d(value):
    """
    Utility function to determine type validity of a MFVec2d value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFVec2d) and not isinstance(value, MFVec2d):
            # if _DEBUG: print('MFVec2d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFVec2d)=' + str(isinstance(value, MFVec2d)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFVec2d):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFVec2d):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        _index += 1
        if len(each) % MFVec2d().TUPLE_SIZE() != 0:
            # if _DEBUG:
            print('* isValidMFVec2d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec2d().TUPLE_SIZE()=' + str(MFVec2d().TUPLE_SIZE()) + ' for value=' + str(value), flush=True)
            return False
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFVec2d(value):
    """
    Utility function to assert type validity of a MFVec2d value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFVec2d) and not isinstance(value, MFVec2d):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFVec2d')
    if isinstance(value, MFVec2d):
        value = value.value # dereference value from this base type
    if isinstance(value, SFVec2d) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec2d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    if isinstance(value, list):
        _index = 0
        for each in value:
            if len(each) % MFVec2d().TUPLE_SIZE() != 0:
                # print(flush=True)
                raise X3DValueError('MFVec2d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec2d().TUPLE_SIZE()=' + str(MFVec2d().TUPLE_SIZE()) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFVec2d)):
#                # print(flush=True)
#                raise X3DTypeError('MFVec2d element #' + str(_index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
            _index += 1
            if isinstance(each, tuple):
                for element in each:
                    if not isinstance(element, float) and not isinstance(element, int):
                        # print(flush=True)
                        raise X3DTypeError('MFVec2d element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    if not isValidMFVec2d(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec2d')
    return True

def isValidSFVec2f(value):
    """
    Utility function to determine type validity of a SFVec2f value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFVec2f) and not isinstance(value, MFVec2f):
            # if _DEBUG: print('SFVec2f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFVec2f)=' + str(isinstance(value, SFVec2f)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFVec2f):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFVec2f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec2f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 2:
        return False
    return True

def assertValidSFVec2f(value):
    """
    Utility function to assert type validity of a SFVec2f value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFVec2f) and not isinstance(value, MFVec2f):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFVec2f')
    if isinstance(value, SFVec2f):
        value = value.value # dereference value from this base type
    if isinstance(value, MFVec2f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec2f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec2f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            # print(flush=True)
            raise X3DTypeError('SFVec2f list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 2:
        # print(flush=True)
        raise X3DTypeError('SFVec2f ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 2')
    if not isValidSFVec2f(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec2f')
    return True

def isValidMFVec2f(value):
    """
    Utility function to determine type validity of a MFVec2f value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFVec2f) and not isinstance(value, MFVec2f):
            # if _DEBUG: print('MFVec2f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFVec2f)=' + str(isinstance(value, MFVec2f)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFVec2f):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFVec2f):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        _index += 1
        if len(each) % MFVec2f().TUPLE_SIZE() != 0:
            # if _DEBUG:
            print('* isValidMFVec2f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec2f().TUPLE_SIZE()=' + str(MFVec2f().TUPLE_SIZE()) + ' for value=' + str(value), flush=True)
            return False
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFVec2f(value):
    """
    Utility function to assert type validity of a MFVec2f value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFVec2f) and not isinstance(value, MFVec2f):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFVec2f')
    if isinstance(value, MFVec2f):
        value = value.value # dereference value from this base type
    if isinstance(value, SFVec2f) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec2f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    if isinstance(value, list):
        _index = 0
        for each in value:
            if len(each) % MFVec2f().TUPLE_SIZE() != 0:
                # print(flush=True)
                raise X3DValueError('MFVec2f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec2f().TUPLE_SIZE()=' + str(MFVec2f().TUPLE_SIZE()) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFVec2f)):
#                # print(flush=True)
#                raise X3DTypeError('MFVec2f element #' + str(_index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
            _index += 1
            if isinstance(each, tuple):
                for element in each:
                    if not isinstance(element, float) and not isinstance(element, int):
                        # print(flush=True)
                        raise X3DTypeError('MFVec2f element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    if not isValidMFVec2f(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec2f')
    return True

def isValidSFVec3d(value):
    """
    Utility function to determine type validity of a SFVec3d value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFVec3d) and not isinstance(value, MFVec3d):
            # if _DEBUG: print('SFVec3d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFVec3d)=' + str(isinstance(value, SFVec3d)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFVec3d):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFVec3d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec3d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 3:
        return False
    return True

def assertValidSFVec3d(value):
    """
    Utility function to assert type validity of a SFVec3d value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFVec3d) and not isinstance(value, MFVec3d):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFVec3d')
    if isinstance(value, SFVec3d):
        value = value.value # dereference value from this base type
    if isinstance(value, MFVec3d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec3d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec3d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            # print(flush=True)
            raise X3DTypeError('SFVec3d list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 3:
        # print(flush=True)
        raise X3DTypeError('SFVec3d ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 3')
    if not isValidSFVec3d(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec3d')
    return True

def isValidMFVec3d(value):
    """
    Utility function to determine type validity of a MFVec3d value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFVec3d) and not isinstance(value, MFVec3d):
            # if _DEBUG: print('MFVec3d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFVec3d)=' + str(isinstance(value, MFVec3d)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFVec3d):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFVec3d):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        _index += 1
        if len(each) % MFVec3d().TUPLE_SIZE() != 0:
            # if _DEBUG:
            print('* isValidMFVec3d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec3d().TUPLE_SIZE()=' + str(MFVec3d().TUPLE_SIZE()) + ' for value=' + str(value), flush=True)
            return False
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFVec3d(value):
    """
    Utility function to assert type validity of a MFVec3d value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFVec3d) and not isinstance(value, MFVec3d):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFVec3d')
    if isinstance(value, MFVec3d):
        value = value.value # dereference value from this base type
    if isinstance(value, SFVec3d) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec3d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    if isinstance(value, list):
        _index = 0
        for each in value:
            if len(each) % MFVec3d().TUPLE_SIZE() != 0:
                # print(flush=True)
                raise X3DValueError('MFVec3d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec3d().TUPLE_SIZE()=' + str(MFVec3d().TUPLE_SIZE()) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFVec3d)):
#                # print(flush=True)
#                raise X3DTypeError('MFVec3d element #' + str(_index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
            _index += 1
            if isinstance(each, tuple):
                for element in each:
                    if not isinstance(element, float) and not isinstance(element, int):
                        # print(flush=True)
                        raise X3DTypeError('MFVec3d element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    if not isValidMFVec3d(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec3d')
    return True

def isValidSFVec3f(value):
    """
    Utility function to determine type validity of a SFVec3f value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFVec3f) and not isinstance(value, MFVec3f):
            # if _DEBUG: print('SFVec3f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFVec3f)=' + str(isinstance(value, SFVec3f)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFVec3f):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFVec3f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec3f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 3:
        return False
    return True

def assertValidSFVec3f(value):
    """
    Utility function to assert type validity of a SFVec3f value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFVec3f) and not isinstance(value, MFVec3f):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFVec3f')
    if isinstance(value, SFVec3f):
        value = value.value # dereference value from this base type
    if isinstance(value, MFVec3f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec3f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec3f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            # print(flush=True)
            raise X3DTypeError('SFVec3f list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 3:
        # print(flush=True)
        raise X3DTypeError('SFVec3f ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 3')
    if not isValidSFVec3f(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec3f')
    return True

def isValidMFVec3f(value):
    """
    Utility function to determine type validity of a MFVec3f value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFVec3f) and not isinstance(value, MFVec3f):
            # if _DEBUG: print('MFVec3f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFVec3f)=' + str(isinstance(value, MFVec3f)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFVec3f):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFVec3f):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        _index += 1
        if len(each) % MFVec3f().TUPLE_SIZE() != 0:
            # if _DEBUG:
            print('* isValidMFVec3f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec3f().TUPLE_SIZE()=' + str(MFVec3f().TUPLE_SIZE()) + ' for value=' + str(value), flush=True)
            return False
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFVec3f(value):
    """
    Utility function to assert type validity of a MFVec3f value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFVec3f) and not isinstance(value, MFVec3f):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFVec3f')
    if isinstance(value, MFVec3f):
        value = value.value # dereference value from this base type
    if isinstance(value, SFVec3f) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec3f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    if isinstance(value, list):
        _index = 0
        for each in value:
            if len(each) % MFVec3f().TUPLE_SIZE() != 0:
                # print(flush=True)
                raise X3DValueError('MFVec3f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec3f().TUPLE_SIZE()=' + str(MFVec3f().TUPLE_SIZE()) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFVec3f)):
#                # print(flush=True)
#                raise X3DTypeError('MFVec3f element #' + str(_index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
            _index += 1
            if isinstance(each, tuple):
                for element in each:
                    if not isinstance(element, float) and not isinstance(element, int):
                        # print(flush=True)
                        raise X3DTypeError('MFVec3f element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    if not isValidMFVec3f(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec3f')
    return True

def isValidSFVec4d(value):
    """
    Utility function to determine type validity of a SFVec4d value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFVec4d) and not isinstance(value, MFVec4d):
            # if _DEBUG: print('SFVec4d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFVec4d)=' + str(isinstance(value, SFVec4d)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFVec4d):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFVec4d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec4d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 4:
        return False
    return True

def assertValidSFVec4d(value):
    """
    Utility function to assert type validity of a SFVec4d value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFVec4d) and not isinstance(value, MFVec4d):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFVec4d')
    if isinstance(value, SFVec4d):
        value = value.value # dereference value from this base type
    if isinstance(value, MFVec4d) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec4d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec4d):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            # print(flush=True)
            raise X3DTypeError('SFVec4d list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 4:
        # print(flush=True)
        raise X3DTypeError('SFVec4d ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 4')
    if not isValidSFVec4d(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec4d')
    return True

def isValidMFVec4d(value):
    """
    Utility function to determine type validity of a MFVec4d value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFVec4d) and not isinstance(value, MFVec4d):
            # if _DEBUG: print('MFVec4d type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFVec4d)=' + str(isinstance(value, MFVec4d)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFVec4d):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFVec4d):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        _index += 1
        if len(each) % MFVec4d().TUPLE_SIZE() != 0:
            # if _DEBUG:
            print('* isValidMFVec4d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec4d().TUPLE_SIZE()=' + str(MFVec4d().TUPLE_SIZE()) + ' for value=' + str(value), flush=True)
            return False
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFVec4d(value):
    """
    Utility function to assert type validity of a MFVec4d value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFVec4d) and not isinstance(value, MFVec4d):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFVec4d')
    if isinstance(value, MFVec4d):
        value = value.value # dereference value from this base type
    if isinstance(value, SFVec4d) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec4d')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    if isinstance(value, list):
        _index = 0
        for each in value:
            if len(each) % MFVec4d().TUPLE_SIZE() != 0:
                # print(flush=True)
                raise X3DValueError('MFVec4d tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec4d().TUPLE_SIZE()=' + str(MFVec4d().TUPLE_SIZE()) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFVec4d)):
#                # print(flush=True)
#                raise X3DTypeError('MFVec4d element #' + str(_index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
            _index += 1
            if isinstance(each, tuple):
                for element in each:
                    if not isinstance(element, float) and not isinstance(element, int):
                        # print(flush=True)
                        raise X3DTypeError('MFVec4d element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    if not isValidMFVec4d(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec4d')
    return True

def isValidSFVec4f(value):
    """
    Utility function to determine type validity of a SFVec4f value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFVec4f) and not isinstance(value, MFVec4f):
            # if _DEBUG: print('SFVec4f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, SFVec4f)=' + str(isinstance(value, SFVec4f)), flush=True)
            return False # type mismatch!
    if isinstance(value, SFVec4f):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, MFVec4f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
        return True
    if not isinstance(value, tuple):
        return False
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec4f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            return False
    if tupleCount != 4:
        return False
    return True

def assertValidSFVec4f(value):
    """
    Utility function to assert type validity of a SFVec4f value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFVec4f) and not isinstance(value, MFVec4f):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a SFVec4f')
    if isinstance(value, SFVec4f):
        value = value.value # dereference value from this base type
    if isinstance(value, MFVec4f) and len(value) == 1:
        value = value.value[0] # dereference value from this MF type
    if not isinstance(value, tuple):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec4f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #1
    tupleCount = 0
    for each in value:
        tupleCount += 1
        while isinstance(each, list) and len(each) == 1:
            each = each[0] # dereference
        if isinstance(each, SFVec4f):
            each = each.value # dereference
        if not isinstance(each, float) and not isinstance(each, int):
            # print(flush=True)
            raise X3DTypeError('SFVec4f list has contained value=' + str(each) + ' with type=' + str(type(each)) + ' which is not a valid float')
    if tupleCount != 4:
        # print(flush=True)
        raise X3DTypeError('SFVec4f ' + str(value)[:100] + ', type=' + str(type(value)) + ' has ' + str(tupleCount) + ' elements instead of 4')
    if not isValidSFVec4f(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python tuple for SFVec4f')
    return True

def isValidMFVec4f(value):
    """
    Utility function to determine type validity of a MFVec4f value.
    """
    if isinstance(value, _X3DField):
        if not isinstance(value, SFVec4f) and not isinstance(value, MFVec4f):
            # if _DEBUG: print('MFVec4f type mismatch diagnostic: value=' + str(value)[:100] + ' has type=' + str(type(value)) + ', isinstance(value, MFVec4f)=' + str(isinstance(value, MFVec4f)), flush=True)
            return False # type mismatch!
    if isinstance(value, MFVec4f):
        value = value.value # dereference value from base type
        return True
    if isinstance(value, SFVec4f):
        value = [value.value] # dereference value from this SF type, convert to list #1
        return True
    if not isinstance(value, list):
        return False
    _index = 0
    for each in value:
        _index += 1
        if len(each) % MFVec4f().TUPLE_SIZE() != 0:
            # if _DEBUG:
            print('* isValidMFVec4f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec4f().TUPLE_SIZE()=' + str(MFVec4f().TUPLE_SIZE()) + ' for value=' + str(value), flush=True)
            return False
        for element in each:
            if not isinstance(element, float) and not isinstance(element, int):
                return False
    return True

def assertValidMFVec4f(value):
    """
    Utility function to assert type validity of a MFVec4f value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* debug value.__class__=' + str(value.__class__) + ', issubclass(value.__class__, _X3DField)=' + str(issubclass(value.__class__, _X3DField)) + ', super(value.__class__)=' + str(super(value.__class__)), flush=True)
    if isinstance(value, _X3DField) and not isinstance(value, SFVec4f) and not isinstance(value, MFVec4f):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ' has type ' + str(type(value)) + ' and is not a MFVec4f')
    if isinstance(value, MFVec4f):
        value = value.value # dereference value from this base type
    if isinstance(value, SFVec4f) or not isinstance(value, list):
        value = [value.value] # dereference value from this SF type, convert to list #2
    if not isinstance(value, list):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec4f')
    # perform duplicative tests prior to isValid call in order to provide better assertion diagnostics #2
    if isinstance(value, list):
        _index = 0
        for each in value:
            if len(each) % MFVec4f().TUPLE_SIZE() != 0:
                # print(flush=True)
                raise X3DValueError('MFVec4f tuple ' + str(each) + ' has length ' + str(len(each)) + ' which is not a multiple of MFVec4f().TUPLE_SIZE()=' + str(MFVec4f().TUPLE_SIZE()) + ' for value=' + str(value)[:100])
#            if not isinstance(each, (tuple, SFVec4f)):
#                # print(flush=True)
#                raise X3DTypeError('MFVec4f element #' + str(_index) + ' with value ' + str(each) + ', type=' + str(type(each)) + ' is not a valid tuple')
            _index += 1
            if isinstance(each, tuple):
                for element in each:
                    if not isinstance(element, float) and not isinstance(element, int):
                        # print(flush=True)
                        raise X3DTypeError('MFVec4f element #' + str(_index) + ' tuple ' + str(each) + ' has value=' + str(element) + ', type=' + str(type(element)) + ' that is not a valid float')
    if not isValidMFVec4f(value):
        # print(flush=True)
        raise X3DTypeError(str(value)[:100] + ', type=' + str(type(value)) + ' is not a valid Python list for MFVec4f')
    return True


def assertValidFieldInitializationValue(name, fieldType, value, parent=''):
    """
    Utility function to assert fieldType validity of a field initialization value, otherwise raise X3DTypeError with diagnostic message.
    """
    # if _DEBUG: print('* assertValidFieldInitializationValue name=' + str(name) + ', fieldType=' + str(fieldType) + ', value=' + str(value)[:100] + ', parent=' + parent, flush=True)
    # note that ExternProtoDeclare field definitions do not have any value
    if name is None:
        print('* assertValidFieldInitializationValue improper invocation: name=' + str(name) + ', fieldType=' + str(fieldType) + ', value=' + str(value)[:100] + ', parent=' + parent + ', ignored', flush=True)
        return # ignore
    if value is None or (not(fieldType == bool) and not value):
        return # ignore
    if fieldType == 'SFString':
        assertValidSFString(value)
    elif fieldType == 'MFString':
        assertValidMFString(value)
    elif (fieldType == 'SFBool') or (fieldType == bool) or isinstance(value, bool):
        assertValidSFBool(value)
    elif fieldType == 'MFBool':
        assertValidMFBool(value)
    elif (fieldType == 'SFInt32') or (fieldType == int) or isinstance(value, int):
        assertValidSFInt32(value)
    elif fieldType == 'MFInt32':
        assertValidMFInt32(value)
    elif (fieldType == 'SFFloat') or (fieldType == float) or isinstance(value, float):
        assertValidSFFloat(value)
    elif fieldType == 'MFFloat':
        assertValidMFFloat(value)
    elif fieldType == 'SFDouble':
        assertValidSFDouble(value)
    elif fieldType == 'MFDouble':
        assertValidMFDouble(value)
    elif fieldType == 'SFTime':
        assertValidSFTime(value)
    elif fieldType == 'MFTime':
        assertValidMFTime(value)
    elif fieldType == 'SFColor':
        assertValidSFColor(value)
    elif fieldType == 'MFColorRGBA':
        assertValidMFColorRGBA(value)
    elif fieldType == 'SFRotation':
        assertValidSFRotation(value)
    elif fieldType == 'MFRotation':
        assertValidMFRotation(value)
    elif fieldType == 'SFImage':
        assertValidSFImage(value)
    elif fieldType == 'MFImage':
        assertValidMFImage(value)
    elif fieldType == 'SFNode':
        assertValidSFNode(value)
    elif fieldType == 'MFNode':
        assertValidMFNode(value)
    elif fieldType == 'SFVec2f':
        assertValidSFVec2f(value)
    elif fieldType == 'MFVec2f':
        assertValidMFVec2f(value)
    elif fieldType == 'SFVec3f':
        assertValidSFVec3f(value)
    elif fieldType == 'MFVec3f':
        assertValidMFVec3f(value)
    elif fieldType == 'SFVec4f':
        assertValidSFVec4f(value)
    elif fieldType == 'MFVec4f':
        assertValidMFVec4f(value)
    elif fieldType == 'SFVec2d':
        assertValidSFVec2d(value)
    elif fieldType == 'MFVec2d':
        assertValidMFVec2d(value)
    elif fieldType == 'SFVec3d':
        assertValidSFVec3d(value)
    elif fieldType == 'MFVec3d':
        assertValidMFVec3d(value)
    elif fieldType == 'SFVec4d':
        assertValidSFVec4d(value)
    elif fieldType == 'MFVec4d':
        assertValidMFVec4d(value)
    elif fieldType == 'SFMatrix3d':
        assertValidSFMatrix3f(value)
    elif fieldType == 'MFMatrix3f':
        assertValidMFMatrix3f(value)
    elif fieldType == 'SFMatrix4f':
        assertValidSFMatrix4f(value)
    elif fieldType == 'MFMatrix4f':
        assertValidMFMatrix4f(value)
    elif fieldType == 'SFMatrix3d':
        assertValidSFMatrix3d(value)
    elif fieldType == 'MFMatrix3d':
        assertValidMFMatrix3d(value)
    elif fieldType == 'SFMatrix4d':
        assertValidSFMatrix4d(value)
    elif fieldType == 'MFMatrix4d':
        assertValidMFMatrix4d(value)
    elif (fieldType == str)   or isinstance(value, str):
        assertValidSFString(value)
    elif str(parent) == 'fieldValue':
        return True # TODO check further if possible
    elif (fieldType == list) or isinstance(value, list):
        try:
            if isinstance(value[0], tuple):
                print('*** assertValidFieldInitializationValue TODO validate list fieldType: name=' + str(name) + ', passed fieldType=' + str(fieldType) + ', fieldType(value)=' + str(fieldType(value)) + ', value=' + str(value)[:100] + ', parent=' + parent, flush=True)
                return True # TODO check further
            initialListItemType = fieldType(value[0])
            # https://stackoverflow.com/questions/522563/accessing-the-index-in-for-loops/28072982#28072982
            # https://stackoverflow.com/questions/1952464/in-python-how-do-i-determine-if-an-object-is-iterable
            for index, each in enumerate(value):
                assertValidFieldInitializationValue(name + '[' + str(index) + ']', initialListItemType, value[index], parent)
        except TypeError:
            return True # TODO check further if possible
    elif (fieldType == tuple) or isinstance(value, tuple):
        print('*** assertValidFieldInitializationValue TODO validate tuple fieldType: name=' + str(name) + ', passed fieldType=' + str(fieldType) + ', fieldType(value)=' + str(fieldType(value)) + ', value=' + str(value)[:100] + ', parent=' + parent, flush=True)
        return True # TODO check further if possible
#       initialListItemType = fieldType(value[0])
#       for index, each in enumerate(value):
#           assertValidFieldInitializationValue(name + '[' + str(index) + '], fieldType(value[index])', value[index], parent)
    else:
        print('*** assertValidFieldInitializationValue unknown fieldType: name=' + str(name) + ', passed fieldType=' + str(fieldType) + ', fieldType(value)=' + str(fieldType(value)) + ', value=' + str(value)[:100] + ', parent=' + parent, flush=True)
###############################################

class _X3DField(object):
    """
    All X3D fields implement _X3DField abstract type.
    """
###    value = None
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return '_X3DField'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/fieldsDef.html'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#FieldTypesTable'
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide value of this field type. """
        return self.__value
    def __repl__(self):
        # if _DEBUG: print('* debug: type(self.value)=' + str(type(self.value)), flush=True)
        if isinstance(self.value, (SFString, str)):
            return "'" + self.value + "'"
        if  isinstance(self.value, tuple) and 'SF' in str(type(self)): # avoid X3DTypeError if value is not iterable
            result = '('
            for each in self.value:
                result += str(each) + ', '
                # if _DEBUG: print('* _X3DField debug: str(each)=' + str(each), flush=True)
            return result.rstrip(', ') + ')'
        if  isinstance(self.value, list) and 'MF' in str(type(self)): # avoid X3DTypeError if value is not iterable
            # isinstance(self.value, MFNode): not working, what got passed in was not an MFNode object apparently
            result = '['
            for each in self.value:
                result += str(each) + ', '
                # if _DEBUG: print('* _X3DField debug: str(each)=' + str(each), flush=True)
            return result.rstrip(', ') + ']'
        return str(self.value)
    def __str__(self):
        return self.__repl__()

def isX3DField(value):
    """
    Determine whether object is an instance of _X3DField.
    """
    return isinstance(value, _X3DField)

# Access Types

class AccessType(_X3DField):
    """
    accessType determines whether a field corresponds to event input, event output, or persistent state information. Events are strictly typed values with a corresponding timestamp. ROUTE connections must match accessType between source field and target field.

    initializeOnly: can be initialized, but cannot send or receive events. This is usually the case for fields that are considered too computationally expensive to change at run time.
    inputOutput: can be initialized, and can also send or receive events during run-time operations.
    inputOnly: cannot be initialized or included in a scene file, but can receive input event values via a ROUTE during run-time operations.
    outputOnly: cannot be initialized or included in a scene file, but can send output event values via a ROUTE during run-time operations.
    """
    SPECIFICATION_URL = 'https://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/concepts.html#FieldSemantics'
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#accessType'
    # string constants listing each allowed accessType
    initializeOnly = 'initializeOnly'
    inputOutput = 'inputOutput'
    inputOnly = 'inputOnly'
    outputOnly = 'outputOnly'


# Field Types

class FieldType(_X3DField):
    """
    The X3D Architecture specification of field types classify the possible values for a field.
    Each field in each node (i.e. each XML attribute) has a strictly defined data type.
    Multiple data types are provided for boolean, integer, floating-point and string values.
    X3D is a strongly typed language, meaning that all data must strictly conform to these data types in order for a scene to be correct.
    """
    SPECIFICATION_URL = 'https://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/fieldsDef.html'
    TOOLTIP_URL = 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#type'
    # string constants listing each allowed type
    SFBool = 'SFBool'
    MFBool = 'MFBool'
    SFColor = 'SFColor'
    MFColor = 'MFColor'
    SFColorRGBA = 'SFColorRGBA'
    MFColorRGBA = 'MFColorRGBA'
    SFDouble = 'SFDouble'
    MFDouble = 'MFDouble'
    SFFloat = 'SFFloat'
    MFFloat = 'MFFloat'
    SFImage = 'SFImage'
    MFImage = 'MFImage'
    SFInt32 = 'SFInt32'
    MFInt32 = 'MFInt32'
    SFMatrix3d = 'SFMatrix3d'
    MFMatrix3d = 'MFMatrix3d'
    SFMatrix3f = 'SFMatrix3f'
    MFMatrix3f = 'MFMatrix3f'
    SFMatrix4d = 'SFMatrix4d'
    MFMatrix4d = 'MFMatrix4d'
    SFMatrix4f = 'SFMatrix4f'
    MFMatrix4f = 'MFMatrix4f'
    SFNode = 'SFNode'
    MFNode = 'MFNode'
    SFRotation = 'SFRotation'
    MFRotation = 'MFRotation'
    SFString = 'SFString'
    MFString = 'MFString'
    SFTime = 'SFTime'
    MFTime = 'MFTime'
    SFVec2d = 'SFVec2d'
    MFVec2d = 'MFVec2d'
    SFVec2f = 'SFVec2f'
    MFVec2f = 'MFVec2f'
    SFVec3d = 'SFVec3d'
    MFVec3d = 'MFVec3d'
    SFVec3f = 'SFVec3f'
    MFVec3f = 'MFVec3f'
    SFVec4d = 'SFVec4d'
    MFVec4d = 'MFVec4d'
    SFVec4f = 'SFVec4f'
    MFVec4f = 'MFVec4f'

class SFBool(_X3DField):
    """
    Field type Python Boolean values are capitalized as True or False. SFBool is a logical type with possible values (true|false) to match the XML boolean type. Hint: XML boolean values are lower case (true|false) in order to maintain compatibility with HTML and other XML documents.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFBool'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFBoolAndMFBool'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFBool'
    def DEFAULT_VALUE(self):
        return True
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 1
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*(true|false)\s*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        value = fixBoolean(value, default=SFBool.DEFAULT_VALUE(self))
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, MFBool) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFBool(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower()
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).upper()

class MFBool(_X3DField):
    """
    Field type Python Boolean values are capitalized as True or False. MFBool is an array of boolean values. Type MFBool was previously undefined in the VRML97 Specification, but nevertheless needed for event utilities and scripting. Example use: MFBool is useful for defining a series of behavior states using a BooleanSequencer prototype. Hint: XML boolean values are lower case (true|false) in order to maintain compatibility with HTML and other XML documents.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFBool'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFBoolAndMFBool'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFBool'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 1
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*((true|false)\s*,?\s*)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        value = fixBoolean(value, default=SFBool.DEFAULT_VALUE(self))
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif not isinstance(value, list) and isValidSFBool(value):
            value = [value]
        assertValidMFBool(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFBool(value):
                if isinstance(value, SFBool):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFBool(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFBool):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFBool(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).upper().replace(',', '').replace('[', '').replace(']', '')

class SFColor(_X3DField):
    """
    Field type SFColor specifies one RGB (red-green-blue) color triple, where each color value is an RGB triple of floating point numbers in range [0,1]. The default value of an uninitialized SFColor field is (0 0 0). Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFColor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFColorAndMFColor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFColor'
    def DEFAULT_VALUE(self):
        return (0, 0, 0)
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 3
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'(\s)*(([+]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)(\s)+){2}([+]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)(\s)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, list):
            for each in value: # check that elements are not tuples
                if isinstance(each, tuple):
                    break
            else: # no tuples found, create 3-tuples
                value = [(x, y, z) for x, y, z in value]
        elif isinstance(value, MFColor) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFColor(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')

class MFColor(_X3DField):
    """
    Field type MFColor specifies zero or more SFColor RGB triples, where each color value is an RGB triple of floating point numbers in range [0,1]. The default value of an uninitialized MFColor field is the empty list. Individual SFColor array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFColor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFColorAndMFColor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFColor'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 3
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'(\s)*((([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)(\s)+){2}([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, list):
            for each in value: # check that elements are not tuples
                if isinstance(each, tuple):
                    break
            else: # no tuples found, create 3-tuples
                value = [(x, y, z) for x, y, z in value]
        elif not isinstance(value, list) and isValidSFColor(value):
            value = [value]
        assertValidMFColor(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFColor(value):
                if isinstance(value, SFColor):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFColor(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFColor):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFColor(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return '[' + str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '') + ']'

class SFColorRGBA(_X3DField):
    """
    Field type SFColorRGBA specifies one RGBA (red-green-blue-alpha) color 4-tuple, where each color value is an RGBA 4-tuple of floating point numbers in range [0,1]. Alpha (opacity) values = (1 - transparency). The default value of an uninitialized SFColorRGBA field is (0 0 0 0). Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFColorRGBA'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFColorRGBAAndMFColorRGBA'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFColorRGBA'
    def DEFAULT_VALUE(self):
        return (0, 0, 0, 0)
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 4
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'(\s)*(([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)(\s)+){3}([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)(\s)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, list):
            for each in value: # check that elements are not tuples
                if isinstance(each, tuple):
                    break
            else: # no tuples found, create 4-tuples
                value = [(x, y, z, w) for x, y, z, w in value]
        elif isinstance(value, MFColorRGBA) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFColorRGBA(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')

class MFColorRGBA(_X3DField):
    """
    Field type MFColorRGBA specifies zero or more SFColorRGBA 4-tuples, where each color value is an RGBA 4-tuple of floating point numbers in range [0,1]. Alpha (opacity) values = (1 - transparency). The default value of an uninitialized MFColor field is the empty list. Individual SFColorRGBA array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFColorRGBA'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFColorRGBAAndMFColorRGBA'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFColorRGBA'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 4
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'(\s)*((([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)(\s)+){3}([+-]?((0(\.[0-9]*)?|\.[0-9]+)|1(\.0*)?)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, list):
            for each in value: # check that elements are not tuples
                if isinstance(each, tuple):
                    break
            else: # no tuples found, create 4-tuples
                value = [(x, y, z, w) for x, y, z, w in value]
        elif not isinstance(value, list) and isValidSFColorRGBA(value):
            value = [value]
        assertValidMFColorRGBA(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFColorRGBA(value):
                if isinstance(value, SFColorRGBA):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFColorRGBA(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFColorRGBA):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFColorRGBA(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return '[' + str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '') + ']'

class SFDouble(_X3DField):
    """
    Field type SFDouble is a double-precision floating-point type. Array values are optionally separated by commas in XML syntax. See GeoVRML 1.0 Recommended Practice, Section 2.3, Limitations of Single Precision for rationale.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFDouble'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFDoubleAndMFDouble'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFDouble'
    def DEFAULT_VALUE(self):
        return 0.0
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 1
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'(\s)*([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)(\s)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, MFDouble) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFDouble(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')

class MFDouble(_X3DField):
    """
    Field type MFDouble is an array of Double values, meaning a double-precision floating-point array type. See GeoVRML 1.0 Recommended Practice, Section 2.3, Limitations of Single Precision for rationale. Array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFDouble'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFDoubleAndMFDouble'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFDouble'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 1
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'(\s)*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif not isinstance(value, list) and isValidSFDouble(value):
            value = [value]
        assertValidMFDouble(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFDouble(value):
                if isinstance(value, SFDouble):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFDouble(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFDouble):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFDouble(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return '[' + str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '') + ']'

class SFFloat(_X3DField):
    """
    Field type SFFloat is a single-precision floating-point type.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFFloat'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFFloatAndMFFloat'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFFloat'
    def DEFAULT_VALUE(self):
        return 0.0
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 1
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'(\s)*([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)(\s)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, MFFloat) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFFloat(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')

class MFFloat(_X3DField):
    """
    Field type MFFloat is an array of SFFloat values, meaning a single-precision floating-point array type. Array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFFloat'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFFloatAndMFFloat'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFFloat'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 1
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'(\s)*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif not isinstance(value, list) and isValidSFFloat(value):
            value = [value]
        assertValidMFFloat(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFFloat(value):
                if isinstance(value, SFFloat):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFFloat(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFFloat):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFFloat(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return '[' + str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '') + ']'

class SFImage(_X3DField):
    """
    Field type SFImage specifies a single uncompressed 2-dimensional pixel image. SFImage fields contain three integers representing the width, height and number of components in the image, followed by (width x height) hexadecimal or integer values representing the pixels in the image.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFImage'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFImageAndMFImage'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFImage'
    def DEFAULT_VALUE(self):
        return [0, 0, 0]
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 1
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*([+]?(0|[1-9][0-9]*)([Ee][+]?[0-9]+)?\s+){2}[+]?[0-4](\s+(0x[0-9a-fA-F]{1,16}|[+]?(0|[1-9][0-9]*)([Ee][+]?[0-9]+)?))*\s*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, MFImage) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFImage(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')

class MFImage(_X3DField):
    """
    Field type MFImage is an array of SFImage values.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFImage'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFImageAndMFImage'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFImage'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 1
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*(([+]?(0|[1-9][0-9]*)([Ee][+]?[0-9]+)?\s+){2}[+]?[0-4](\s+(0x[0-9a-fA-F]{1,16}|[+]?(0|[1-9][0-9]*)([Ee][+]?[0-9]+)?))*\s*,?\s*)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif not isinstance(value, list) and isValidSFImage(value):
            value = [value]
        assertValidMFImage(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFImage(value):
                if isinstance(value, SFImage):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFImage(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFImage):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFImage(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return '[' + str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '') + ']'

class SFInt32(_X3DField):
    """
    Field type SFInt32 specifies one 32-bit signed integer.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFInt32'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFInt32AndMFInt32'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFInt32'
    def DEFAULT_VALUE(self):
        return 0
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 1
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'(\s)*[+-]?(0|[1-9][0-9]*)([Ee][+-]?[0-9]+)?(\s)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, MFInt32) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFInt32(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')

class MFInt32(_X3DField):
    """
    Field type MFInt32 defines an array of 32-bit signed integers. Array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFInt32'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFInt32AndMFInt32'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFInt32'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 1
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'(\s)*([+-]?(0|[1-9][0-9]*)([Ee][+-]?[0-9]+)?\s*,?\s*)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif not isinstance(value, list) and isValidSFInt32(value):
            value = [value]
        assertValidMFInt32(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFInt32(value):
                if isinstance(value, SFInt32):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFInt32(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFInt32):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFInt32(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return '[' + str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '') + ']'

class SFMatrix3d(_X3DField):
    """
    Field type SFMatrix3d specifies a 3x3 matrix of double-precision floating point numbers, organized in row-major fashion. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFMatrix3d'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFMatrix3dAndMFMatrix3d'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFMatrix3d'
    def DEFAULT_VALUE(self):
        return (1, 0, 0, 0, 1, 0, 0, 0, 1)
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 9
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){8}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, MFMatrix3d) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFMatrix3d(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')

class MFMatrix3d(_X3DField):
    """
    Field type MFMatrix3d specifies zero or more 3x3 matrices of double-precision floating point numbers, organized in row-major fashion. Warning: comma characters can only appear between singleton 9-tuple values.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFMatrix3d'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFMatrix3dAndMFMatrix3d'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFMatrix3d'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 9
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){8}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif not isinstance(value, list) and isValidSFMatrix3d(value):
            value = [value]
        assertValidMFMatrix3d(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFMatrix3d(value):
                if isinstance(value, SFMatrix3d):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFMatrix3d(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFMatrix3d):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFMatrix3d(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return '[' + str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '') + ']'

class SFMatrix3f(_X3DField):
    """
    Field type SFMatrix3f specifies a 3x3 matrix of single-precision floating point numbers, organized in row-major fashion. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFMatrix3f'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFMatrix3fAndMFMatrix3f'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFMatrix3f'
    def DEFAULT_VALUE(self):
        return (1, 0, 0, 0, 1, 0, 0, 0, 1)
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 9
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){8}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, MFMatrix3f) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFMatrix3f(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')

class MFMatrix3f(_X3DField):
    """
    Field type MFMatrix3f specifies zero or more 3x3 matrices of single-precision floating point numbers, organized in row-major fashion. Warning: comma characters can only appear between singleton 9-tuple values.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFMatrix3f'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFMatrix3fAndMFMatrix3f'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFMatrix3f'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 9
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){8}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif not isinstance(value, list) and isValidSFMatrix3f(value):
            value = [value]
        assertValidMFMatrix3f(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFMatrix3f(value):
                if isinstance(value, SFMatrix3f):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFMatrix3f(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFMatrix3f):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFMatrix3f(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return '[' + str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '') + ']'

class SFMatrix4d(_X3DField):
    """
    Field type SFMatrix4d specifies a 4x4 matrix of double-precision floating point numbers, organized in row-major fashion. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFMatrix4d'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFMatrix4dAndMFMatrix4d'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFMatrix4d'
    def DEFAULT_VALUE(self):
        return (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 16
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){15}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, MFMatrix4d) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFMatrix4d(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')

class MFMatrix4d(_X3DField):
    """
    Field type MFMatrix4d specifies zero or more 4x4 matrices of double-precision floating point numbers, organized in row-major fashion. Warning: comma characters can only appear between singleton 16-tuple values.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFMatrix4d'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFMatrix4dAndMFMatrix4d'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFMatrix4d'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 16
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){15}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif not isinstance(value, list) and isValidSFMatrix4d(value):
            value = [value]
        assertValidMFMatrix4d(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFMatrix4d(value):
                if isinstance(value, SFMatrix4d):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFMatrix4d(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFMatrix4d):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFMatrix4d(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return '[' + str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '') + ']'

class SFMatrix4f(_X3DField):
    """
    Field type SFMatrix4f specifies a 4x4 matrix of single-precision floating point numbers, organized in row-major fashion. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFMatrix4f'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFMatrix4fAndMFMatrix4f'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFMatrix4f'
    def DEFAULT_VALUE(self):
        return (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 16
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){15}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, MFMatrix4f) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFMatrix4f(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')

class MFMatrix4f(_X3DField):
    """
    Field type MFMatrix4f specifies zero or more 4x4 matrices of single-precision floating point numbers, organized in row-major fashion. Warning: comma characters can only appear between singleton 16-tuple values.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFMatrix4f'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFMatrix4fAndMFMatrix4f'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFMatrix4f'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 16
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){15}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif not isinstance(value, list) and isValidSFMatrix4f(value):
            value = [value]
        assertValidMFMatrix4f(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFMatrix4f(value):
                if isinstance(value, SFMatrix4f):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFMatrix4f(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFMatrix4f):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFMatrix4f(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return '[' + str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '') + ']'

class SFNode(_X3DField):
    """
    Field type SFNode specifies an X3D node; the default empty value of an uninitialized SFNode field is sometimes described as NULL.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFNodeAndMFNode'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFNode'
    def DEFAULT_VALUE(self):
        return None
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [('value', 'None', FieldType.SFNode, AccessType.inputOutput, 'SFNode')]
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 1
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, MFNode) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFNode(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        if not self.__value is None:
            return self.__value.XML()
        return None
    def VRML(self):
        """ Provide VRML value for this field type. """
        if not self.__value is None:
            return self.__value.VRML()
        return None

class MFNode(_X3DField):
    """
    Field type MFNode specifies zero or more nodes; the default value of an MFNode field is the empty list.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFNodeAndMFNode'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFNode'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [('value', None, FieldType.MFNode, AccessType.inputOutput, 'MFNode')]
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 1
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif not isinstance(value, list) and isValidSFNode(value):
            value = [value]
        assertValidMFNode(value)
        self.__value = value
    def __repl__(self):
        result = '['
        for each in self.__value:
            result += str(each) + ', '
        return result.rstrip(', ') + ']'
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFNode(value):
                if isinstance(value, SFNode):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFNode(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFNode):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFNode(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        result = ''
        for each in self.__value:
            if not self.__value is None:
                result += each.XML() # has line break '\n' at end, which is OK
        result = result.rstrip('\n')
        return result
    def VRML(self):
        """ Provide VRML value for this field type. """
        result = ''
        for each in self.__value:
            if not self.__value is None:
                result += each.VRML() # has line break '\n' at end, which is OK
        result = result.rstrip('\n')
        return result

class SFRotation(_X3DField):
    """
    Field type SFRotation is an axis-angle 4-tuple, indicating X-Y-Z direction axis plus angle orientation about that axis. The first three values specify a normalized axis vector about which the rotation takes place, so the first three values shall be within the range [-1..+1] in order to represent a normalized unit vector. The fourth value specifies the amount of right-handed rotation about that axis in radians. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFRotation'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFRotationAndMFRotation'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFRotation'
    def DEFAULT_VALUE(self):
        return (0, 0, 1, 0)
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 4
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, list):
            for each in value: # check that elements are not tuples
                if isinstance(each, tuple):
                    break
            else: # no tuples found, create 4-tuples
                value = [(x, y, z, w) for x, y, z, w in value]
        elif isinstance(value, MFRotation) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFRotation(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')

class MFRotation(_X3DField):
    """
    Field type MFRotation is an array of SFRotation values. Individual singleton SFRotation array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFRotation'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFRotationAndMFRotation'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFRotation'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 4
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, list):
            for each in value: # check that elements are not tuples
                if isinstance(each, tuple):
                    break
            else: # no tuples found, create 4-tuples
                value = [(x, y, z, w) for x, y, z, w in value]
        elif not isinstance(value, list) and isValidSFRotation(value):
            value = [value]
        assertValidMFRotation(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFRotation(value):
                if isinstance(value, SFRotation):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFRotation(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFRotation):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFRotation(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return '[' + str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '') + ']'

class SFString(_X3DField):
    """
    Field type SFString defines a single string encoded with the UTF-8 universal character set.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFString'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFStringAndMFString'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFString'
    def DEFAULT_VALUE(self):
        return ''
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 1
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'(\s|\S)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, MFString) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFString(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value)
    def VRML(self):
        """ Provide VRML value for this field type. """
        return '"' + str(self.__value) + '"'

class MFString(_X3DField):
    """
    Field type MFString is an array of SFString values, each "quoted" and separated by whitespace. Individual SFString array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFString'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFStringAndMFString'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFString'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 1
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'(\s|\S)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif not isinstance(value, list) and isValidSFString(value):
            value = [value]
        assertValidMFString(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFString(value):
                if isinstance(value, SFString):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFString(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFString):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFString(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        result = ''
        for each in self.__value:
            result += '"' + str(each) + '"' + ' '
        result = result.rstrip(' ')
        return result
    def VRML(self):
        """ Provide VRML value for this field type. """
        result = ''
        for each in self.__value:
            result += '"' + str(each) + '"' + ' '
        result = '[' + result.rstrip(' ') + ']'
        return result

class SFTime(_X3DField):
    """
    Field type SFTime specifies a single time value, expressed as a double-precision floating point number. Typically, SFTime fields represent the number of seconds since Jan 1, 1970, 00:00:00 GMT.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFTime'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFTimeAndMFTime'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFTime'
    def DEFAULT_VALUE(self):
        return -1.0
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 1
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'(\s)*([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)(\s)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, MFTime) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFTime(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')

class MFTime(_X3DField):
    """
    Field type MFTime is an array of SFTime values. Array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFTime'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFTimeAndMFTime'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFTime'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 1
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'(\s)*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif not isinstance(value, list) and isValidSFTime(value):
            value = [value]
        assertValidMFTime(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFTime(value):
                if isinstance(value, SFTime):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFTime(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFTime):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFTime(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return '[' + str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '') + ']'

class SFVec2d(_X3DField):
    """
    Field type SFVec2d is a 2-tuple pair of SFDouble values. Hint: SFVec2d can be used to specify a 2D double-precision coordinate. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFVec2d'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFVec2dAndMFVec2d'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec2d'
    def DEFAULT_VALUE(self):
        return (0.0, 0.0)
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 2
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){1}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, MFVec2d) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFVec2d(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')

class MFVec2d(_X3DField):
    """
    Field type MFVec2d is an array of SFVec2d values. Individual singleton SFVec2d array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFVec2d'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFVec2dAndMFVec2d'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec2d'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 2
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){1}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif not isinstance(value, list) and isValidSFVec2d(value):
            value = [value]
        assertValidMFVec2d(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFVec2d(value):
                if isinstance(value, SFVec2d):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFVec2d(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFVec2d):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFVec2d(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return '[' + str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '') + ']'

class SFVec2f(_X3DField):
    """
    Field type SFVec2f is a 2-tuple pair of SFFloat values. Hint: SFVec2f can be used to specify a 2D single-precision coordinate. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFVec2f'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFVec2fAndMFVec2f'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec2f'
    def DEFAULT_VALUE(self):
        return (0.0, 0.0)
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 2
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){1}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, list):
            for each in value: # check that elements are not tuples
                if isinstance(each, tuple):
                    break
            else: # no tuples found, create 2-tuples
                value = [(x, y) for x, y, in value]
        elif isinstance(value, MFVec2f) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFVec2f(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')

class MFVec2f(_X3DField):
    """
    Field type MFVec2f is an array of SFVec2f values. Individual singleton SFVec2f array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFVec2f'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFVec2fAndMFVec2f'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec2f'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 2
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){1}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, list):
            for each in value: # check that elements are not tuples
                if isinstance(each, tuple):
                    break
            else: # no tuples found, create 2-tuples
                value = [(x, y) for x, y, in value]
        elif not isinstance(value, list) and isValidSFVec2f(value):
            value = [value]
        assertValidMFVec2f(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFVec2f(value):
                if isinstance(value, SFVec2f):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFVec2f(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFVec2f):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFVec2f(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return '[' + str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '') + ']'

class SFVec3d(_X3DField):
    """
    Field type SFVec3d is a 3-tuple triplet of SFDouble values. See GeoVRML 1.0 Recommended Practice, Section 2.3, Limitations of Single Precision. Hint: SFVec3d can be used to specify a georeferenced 3D coordinate. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFVec3d'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFVec3dAndMFVec3d'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec3d'
    def DEFAULT_VALUE(self):
        return (0.0, 0.0, 0.0)
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 3
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){2}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, MFVec3d) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFVec3d(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')

class MFVec3d(_X3DField):
    """
    Field type MFVec3d is an array of SFVec3d values. Individual singleton SFVec3d array values are optionally separated by commas in XML syntax. Original rationale for inclusion: GeoVRML 1.0 Recommended Practice, Section 2.3, Limitations of Single Precision. Hint: MFVec3d can be used to specify a list of georeferenced 3D coordinates.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFVec3d'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFVec3dAndMFVec3d'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec3d'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 3
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){2}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif not isinstance(value, list) and isValidSFVec3d(value):
            value = [value]
        assertValidMFVec3d(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFVec3d(value):
                if isinstance(value, SFVec3d):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFVec3d(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFVec3d):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFVec3d(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return '[' + str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '') + ']'

class SFVec3f(_X3DField):
    """
    Field type SFVec3f is a 3-tuple triplet of SFFloat values. Hint: SFVec3f can be used to specify a 3D coordinate or a 3D scale value. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFVec3f'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFVec3fAndMFVec3f'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec3f'
    def DEFAULT_VALUE(self):
        return (0.0, 0.0, 0.0)
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 3
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){2}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, list):
            for each in value: # check that elements are not tuples
                if isinstance(each, tuple):
                    break
            else: # no tuples found, create 3-tuples
                value = [(x, y, z) for x, y, z in value]
        elif isinstance(value, MFVec3f) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFVec3f(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')

class MFVec3f(_X3DField):
    """
    Field type MFVec3f is an array of SFVec3f values. Individual singleton SFVec3f array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFVec3f'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFVec3fAndMFVec3f'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec3f'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 3
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){2}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, list):
            for each in value: # check that elements are not tuples
                if isinstance(each, tuple):
                    break
            else: # no tuples found, create 3-tuples
                value = [(x, y, z) for x, y, z in value]
        elif not isinstance(value, list) and isValidSFVec3f(value):
            value = [value]
        assertValidMFVec3f(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFVec3f(value):
                if isinstance(value, SFVec3f):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFVec3f(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFVec3f):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFVec3f(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return '[' + str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '') + ']'

class SFVec4d(_X3DField):
    """
    Field type SFVec4d is a 4-tuple set of double-precision floating-point values, specifying a 3D homogeneous vector. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFVec4d'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFVec4dAndMFVec4d'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec4d'
    def DEFAULT_VALUE(self):
        return (0.0, 0.0, 0.0, 0.0)
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 4
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, MFVec4d) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFVec4d(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')

class MFVec4d(_X3DField):
    """
    Field type MFVec4d is zero or more SFVec4d values. Individual singleton SFVec4d array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFVec4d'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFVec4dAndMFVec4d'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec4d'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 4
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif not isinstance(value, list) and isValidSFVec4d(value):
            value = [value]
        assertValidMFVec4d(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFVec4d(value):
                if isinstance(value, SFVec4d):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFVec4d(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFVec4d):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFVec4d(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return '[' + str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '') + ']'

class SFVec4f(_X3DField):
    """
    Field type SFVec4f is a 4-tuple set of single-precision floating-point values, specifying a 3D homogeneous vector. Warning: comma characters within singleton values do not pass strict XML validation.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'SFVec4f'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFVec4fAndMFVec4f'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SFVec4f'
    def DEFAULT_VALUE(self):
        return (0.0, 0.0, 0.0, 0.0)
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return False
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 4
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*(([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, list):
            for each in value: # check that elements are not tuples
                if isinstance(each, tuple):
                    break
            else: # no tuples found, create 4-tuples
                value = [(x, y, z, w) for x, y, z, w in value]
        elif isinstance(value, MFVec4f) and isinstance(value.value, list) and len(value.value) == 1:
            print("downcasting by dereferencing simple-list value=" + str(value)[:100] + ", type=" + str(type(value)) + " as " + str(value.value[0]))
            value = value.value[0] # dereference
        elif isinstance(value, list) and len(value) == 1:
            value = value[0] # dereference
        assertValidSFVec4f(value)
        self.__value = value
    def __bool__(self):
        return len(self.__value) > 0
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return str(self.__value).lower().replace(',', '').replace('(', '').replace(')', '').replace('[', '').replace(']', '')

class MFVec4f(_X3DField):
    """
    Field type MFVec4f is zero or more SFVec4f values. Individual singleton SFVec4f array values are optionally separated by commas in XML syntax.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Field class. '''
        return 'MFVec4f'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/fieldsDef.html#SFVec4fAndMFVec4f'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MFVec4f'
    def DEFAULT_VALUE(self):
        return [] # use empty list object, don't keep resetting a mutable python DEFAULT_VALUE
    def ARRAY_TYPE(self):
        ''' Whether or not this field class is array based. '''
        return True
    def TUPLE_SIZE(self):
        ''' How many values make up each data tuple. '''
        return 4
    def REGEX_XML(self):
        ''' Regular expression for validating values, for more information see https://www.web3d.org/specifications/X3dRegularExpressions.html '''
        return r'\s*((([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s+){3}([+-]?((0|[1-9][0-9]*)(\.[0-9]*)?|\.[0-9]+)([Ee][+-]?[0-9]+)?)\s*,?\s*)*' # (includes lower-case true, false)
    # - - - - - - - - - -
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide typed value of this field instance. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        elif isinstance(value, list):
            for each in value: # check that elements are not tuples
                if isinstance(each, tuple):
                    break
            else: # no tuples found, create 4-tuples
                value = [(x, y, z, w) for x, y, z, w in value]
        elif not isinstance(value, list) and isValidSFVec4f(value):
            value = [value]
        assertValidMFVec4f(value)
        self.__value = value
    def append(self, value=None):
        """ Add to existing value list, first ensuring that a correctly typed value is applied. """
        if  not value is None:
            if isValidSFVec4f(value):
                if isinstance(value, SFVec4f):
                    value = value.value # dereference
                self.__value.append(value)
            elif isValidMFVec4f(value):
                for each in value:
                    while isinstance(each, list) and len(each) == 1:
                        each = each[0] # dereference
                    if isinstance(each, SFVec4f):
                        each = each.value # dereference
                    self.__value.append(each)
            else:
                assertValidMFVec4f(value) # report type failure
    def __bool__(self):
        return len(self.__value) > 0
    def __len__(self):
        return len(self.__value)
    def XML(self):
        """ Provide XML value for this field type. """
        return str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '')
    def VRML(self):
        """ Provide VRML value for this field type. """
        return '[' + str(self.__value).lower().replace('(', '').replace(')', '').replace(',', '').replace('[', '').replace(']', '') + ']'

###############################################

# Abstract Node Types

# Note that these package-internal class names are preceded by an underscore _ character for hidden scope, since X3D authors are not expected to use them.

class _X3DNode(object):
    """
    All instantiable nodes implement X3DNode, which corresponds to SFNode in the X3D specification.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/core.html#X3DNode'
    def __init__(self, DEF="", USE="", class_="", metadata=None, IS=None):
        self.DEF = DEF
        self.USE = USE
        self.class_ = class_
        self.IS = IS
        self.metadata = metadata
        # if _DEBUG: print('... in X3DNode __init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
    @property # getter - - - - - - - - - -
    def DEF(self):
        """ Unique ID name for this node, referenceable by other nodes. """
        return self.__DEF
    @DEF.setter
    def DEF(self, DEF):
        if  DEF is None:
            DEF = SFString.DEFAULT_VALUE(self)
        assertValidSFString(DEF)
        self.__DEF = str(DEF)
        if self.__DEF:
            self.__USE = None # DEF and USE are mutually exclusive
    @property # getter - - - - - - - - - -
    def USE(self):
        """ Reuse an already DEF-ed node ID, excluding all child nodes and all other attributes. """
        return self.__USE
    @USE.setter
    def USE(self, USE):
        if  USE is None:
            USE = SFString.DEFAULT_VALUE(self)
        assertValidSFString(USE)
        self.__USE = str(USE)
        if self.__USE:
            self.__DEF = None # DEF and USE are mutually exclusive
    @property # getter - - - - - - - - - -
    def class_(self):
        """ Space-separated list of classes, reserved for use by CSS cascading stylesheets. """
        return self.__class_
    @class_.setter
    def class_(self, class_):
        if  class_ is None:
            class_ = SFString.DEFAULT_VALUE(self)
        assertValidSFString(class_)
        self.__class_ = class_
    @property # getter - - - - - - - - - -
    def IS(self):
        """ The IS statement connects node fields defined inside a ProtoBody declaration back to corresponding ProtoInterface fields. """
        return self.__IS
    @IS.setter
    def IS(self, IS):
        if  IS is None:
            IS = SFNode.DEFAULT_VALUE(self)
        assertValidSFNode(IS)
        if not isinstance(IS, object):
            # print(flush=True)
            raise X3DTypeError(str(IS) + ' does not have a valid node type object')
        self.__IS = IS
    @property # getter - - - - - - - - - -
    def metadata(self):
        """ The metadata field can contain a single MetadataBoolean, MetadataInteger, MetadataFloat, MetadataDouble, MetadataString or MetadataSet node. """
        return self.__metadata
    @metadata.setter
    def metadata(self, metadata):
        if  metadata is None:
            metadata = SFNode.DEFAULT_VALUE(self)
        assertValidSFNode(metadata)
        if not isinstance(metadata, object):
            # print(flush=True)
            raise X3DTypeError(str(metadata) + ' does not have a valid node type object')
        self.__metadata = metadata
    def __repl__(self):
        result = self.NAME() + '('
        # TODO put DEF first, matching canonical form
        if self.FIELD_DECLARATIONS():
            for each in self.FIELD_DECLARATIONS():
                # if _DEBUG: print(self.NAME() + ' for each in self.FIELD_DECLARATIONS(): each=' + str(each))
                name = each[0]
                default = each[1]
                type_ = each[2]
                accessType = each[3]
                value = getattr(self, name)
                # if _DEBUG: print('gettattr(self, ' + str(name) + ') value="' + str(value)[:100] + '" for FIELD_DECLARATIONS ' + str(each) + ')', flush=True)
                if value != default:
                    # consider whether indentation is useful; probably not
                    # print("\n\t")
                    if  isinstance(value, list): # avoid X3DTypeError if value is not iterable
                        result += str(name) + '=['
                        for each in value:
                            # if _DEBUG: print('* X3DNode debug: str(each)=' + str(each), flush=True)
                            result += str(each) + ', '
                        result = result.rstrip(', ')
                        result += '],'
                    elif isinstance(value, str) and "'" in value:
                        result += str(name) + '=' + '"' + str(value)[:100] + '"' + ','
                    elif isinstance(value, str) and value != default:
                        result += str(name) + '=' + "'" + str(value)[:100] + "'" + ','
                    elif value != default:
                        result += str(name) + '='       + str(value)[:100]       + ','
                    # elif _DEBUG:
                    #   result += str(name) + '=' + "'" + str(value)[:100] + "'" + ','
        return result.strip().rstrip(',').rstrip(', ') + ')'
    def __str__(self):
        return self.__repl__().strip() # X3DNode


def isX3DNode(value):
    """
    Whether or not value is a concrete node (Shape WorldInfo etc.) meaning any _X3DNode object.
    """
    return isinstance(value, _X3DNode)

class _X3DChildNode(_X3DNode):
    """
    A node that implements X3DChildNode is one of the legal children for a X3DGroupingNode parent.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DChildNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/core.html#X3DChildNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DChildNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DSoundNode(_X3DChildNode):
    """
    Base type for all sound nodes.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DSoundNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#X3DSoundNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DSoundNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DSoundChannelNode(_X3DSoundNode):
    """
    Base type for all sound destination nodes, which represent the final destination of an audio signal and are what the user can ultimately hear.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DSoundChannelNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#X3DSoundChannelNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DSoundChannelNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DTimeDependentNode(_X3DChildNode):
    """
    Base type from which all time-dependent nodes are derived.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DTimeDependentNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/time.html#X3DTimeDependentNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DTimeDependentNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DGeometryNode(_X3DNode):
    """
    Geometry nodes produce renderable geometry and are contained by a Shape node.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DGeometryNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#X3DGeometryNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DGeometryNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DParametricGeometryNode(_X3DGeometryNode):
    """
    Base type for all geometry node types that are created parametrically and use control points to describe the final shape of the surface.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DParametricGeometryNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/nurbs.html#X3DParametricGeometryNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DParametricGeometryNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DAppearanceChildNode(_X3DNode):
    """
    Nodes of this type can be used as child nodes for Appearance.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DAppearanceChildNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shape.html#X3DAppearanceChildNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DAppearanceChildNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DTextureNode(_X3DAppearanceChildNode):
    """
    Base type for all nodes which specify sources for texture images.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DTextureNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texturing.html#X3DTextureNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DTextureNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DSensorNode(_X3DChildNode):
    """
    Base type for all sensors.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DSensorNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/core.html#X3DSensorNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DSensorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DPointingDeviceSensorNode(_X3DSensorNode):
    """
    Base type for all pointing device sensors.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DPointingDeviceSensorNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/pointingDeviceSensor.html#X3DPointingDeviceSensorNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DPointingDeviceSensorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DVolumeRenderStyleNode(_X3DNode):
    """
    The X3DVolumeRenderStyleNode abstract node type is the base type for all node types that specify a specific visual rendering style to be used when rendering volume data.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DVolumeRenderStyleNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/volume.html#X3DVolumeRenderStyleNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DVolumeRenderStyleNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DGeometricPropertyNode(_X3DNode):
    """
    Base type for all geometric property node types.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DGeometricPropertyNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#X3DGeometricPropertyNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DGeometricPropertyNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DFollowerNode(_X3DChildNode):
    """
    X3DFollowerNode is the abstract base class for all nodes in the Followers component.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DFollowerNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/followers.html#X3DFollowerNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DFollowerNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DBindableNode(_X3DChildNode):
    """
    Bindable nodes implement the binding stack, so that only one of each node type is active at a given time.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DBindableNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/core.html#X3DBindableNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DBindableNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DAppearanceNode(_X3DNode):
    """
    Base type for all Appearance nodes.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DAppearanceNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shape.html#X3DAppearanceNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DAppearanceNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DBackgroundNode(_X3DBindableNode):
    """
    Abstract type from which all backgrounds inherit, also defining a background binding stack.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DBackgroundNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/environmentalEffects.html#X3DBackgroundNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DBackgroundNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DChaserNode(_X3DFollowerNode):
    """
    The X3DChaserNode abstract node type calculates the output on value_changed as a finite impulse response (FIR) based on the events received on set_destination field.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DChaserNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/followers.html#X3DChaserNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DChaserNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DColorNode(_X3DGeometricPropertyNode):
    """
    Base type for color specifications in X3D.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DColorNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#X3DColorNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DColorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DComposableVolumeRenderStyleNode(_X3DVolumeRenderStyleNode):
    """
    The X3DComposableVolumeRenderStyleNode abstract node type is the base type for all node types that allow rendering styles to be sequentially composed together to form a single renderable output.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DComposableVolumeRenderStyleNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/volume.html#X3DComposableVolumeRenderStyleNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DComposableVolumeRenderStyleNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DComposedGeometryNode(_X3DGeometryNode):
    """
    Composed geometry nodes produce renderable geometry, can contain Color Coordinate Normal TextureCoordinate, and are contained by a Shape node.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DComposedGeometryNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#X3DComposedGeometryNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DComposedGeometryNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DCoordinateNode(_X3DGeometricPropertyNode):
    """
    Base type for all coordinate node types in X3D.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DCoordinateNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#X3DCoordinateNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DCoordinateNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DDamperNode(_X3DFollowerNode):
    """
    The X3DDamperNode abstract node type creates an IIR response that approaches the destination value according to the shape of the e-function only asymptotically but very quickly.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DDamperNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/followers.html#X3DDamperNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DDamperNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DDragSensorNode(_X3DPointingDeviceSensorNode):
    """
    Base type for all drag-style pointing device sensors.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DDragSensorNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/pointingDeviceSensor.html#X3DDragSensorNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DDragSensorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DEnvironmentalSensorNode(_X3DSensorNode):
    """
    Base type for the environmental sensor nodes ProximitySensor, TransformSensor and VisibilitySensor.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DEnvironmentalSensorNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/environmentalSensor.html#X3DEnvironmentalSensorNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DEnvironmentalSensorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DEnvironmentTextureNode(_X3DTextureNode):
    """
    Base type for all nodes that specify cubic environment map sources for texture images.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DEnvironmentTextureNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/environmentalTexturing#X3DEnvironmentTextureNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DEnvironmentTextureNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DFontStyleNode(_X3DNode):
    """
    Base type for all font style nodes.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DFontStyleNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/text.html#X3DFontStyleNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DFontStyleNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DGroupingNode(_X3DChildNode):
    """
    Grouping nodes can contain other nodes as children, thus making up the backbone of a scene graph.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DGroupingNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/grouping.html#X3DGroupingNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DGroupingNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DInfoNode(_X3DChildNode):
    """
    Base type for all nodes that contain only information without visual semantics.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DInfoNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/grouping.html#X3DInfoNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DInfoNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DInterpolatorNode(_X3DChildNode):
    """
    Interpolator nodes are designed for linear keyframed animation. Interpolators are driven by an input key ranging [0..1] and produce corresponding piecewise-linear output functions.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DInterpolatorNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/interpolators.html#X3DInterpolatorNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DInterpolatorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DKeyDeviceSensorNode(_X3DSensorNode):
    """
    Base type for all sensor node types that operate using key devices.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DKeyDeviceSensorNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/keyDeviceSensor.html#X3DKeyDeviceSensorNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DKeyDeviceSensorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DLayerNode(_X3DNode):
    """
    The X3DLayerNode abstract node type is the base node type for layer nodes.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DLayerNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/layering.html#X3DLayerNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DLayerNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DLayoutNode(_X3DChildNode):
    """
    X3DLayoutNode is the base node type for layout nodes.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DLayoutNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/layout.html#X3DLayoutNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DLayoutNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DLightNode(_X3DChildNode):
    """
    Light nodes provide illumination for rendering geometry in the scene. Implementing nodes must include a global field with type SFBool and accessType inputOutput.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DLightNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/lighting.html#X3DLightNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DLightNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DMaterialNode(_X3DAppearanceChildNode):
    """
    Base type for all Material nodes.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DMaterialNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shape.html#X3DMaterialNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DMaterialNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DNBodyCollidableNode(_X3DChildNode):
    """
    The X3DNBodyCollidableNode abstract node type represents objects that act as the interface between the rigid body physics, collision geometry proxy, and renderable objects in the scene graph hierarchy.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DNBodyCollidableNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rigidBodyPhysics.html#X3DNBodyCollidableNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DNBodyCollidableNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DNBodyCollisionSpaceNode(_X3DNode):
    """
    The X3DNBodyCollisionSpaceNode abstract node type represents objects that act as a self-contained spatial collection of objects that can interact through collision detection routines.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DNBodyCollisionSpaceNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rigidBodyPhysics.html#X3DNBodyCollisionSpaceNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DNBodyCollisionSpaceNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DNetworkSensorNode(_X3DSensorNode):
    """
    Base typefor all sensors that generate events based on network activity.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DNetworkSensorNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/networking.html#X3DNetworkSensorNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DNetworkSensorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DNormalNode(_X3DGeometricPropertyNode):
    """
    Base type for all normal node types in X3D.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DNormalNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#X3DNormalNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DNormalNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DNurbsControlCurveNode(_X3DNode):
    """
    Base type for all nodes that provide control curve information in 2D space.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DNurbsControlCurveNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/nurbs.html#X3DNurbsControlCurveNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DNurbsControlCurveNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DNurbsSurfaceGeometryNode(_X3DParametricGeometryNode):
    """
    Abstract geometry type for all types of NURBS surfaces.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DNurbsSurfaceGeometryNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/nurbs.html#X3DNurbsSurfaceGeometryNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DNurbsSurfaceGeometryNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DOneSidedMaterialNode(_X3DMaterialNode):
    """
    Base type for material nodes that describe how the shape looks like from one side. A different number of contanied texture nodes are allowed by each of the implementing nodes.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DOneSidedMaterialNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shape.html#X3DOneSidedMaterialNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DOneSidedMaterialNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DParticleEmitterNode(_X3DNode):
    """
    The X3DParticleEmitterNode abstract type represents any node that is an emitter of particles.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DParticleEmitterNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/particleSystems.html#X3DParticleEmitterNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DParticleEmitterNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DParticlePhysicsModelNode(_X3DNode):
    """
    The X3DParticlePhysicsModelNode abstract type represents any node that applies a form of constraints on the particles after they have been generated.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DParticlePhysicsModelNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/particleSystems.html#X3DParticlePhysicsModelNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DParticlePhysicsModelNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DPickSensorNode(_X3DSensorNode):
    """
    The X3DPickSensorNode abstract node type is the base node type that represents the lowest common denominator of picking capabilities.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DPickSensorNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/picking.html#X3DPickSensorNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DPickSensorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DProductStructureChildNode(_X3DChildNode):
    """
    Base type marking nodes that are valid product structure children for the CADGeometry component.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DProductStructureChildNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/CADGeometry.html#X3DProductStructureChildNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DProductStructureChildNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DPrototypeInstance(_X3DNode):
    """
    Base type for all prototype instances. Note that direct children nodes are disallowed, instead let fieldValue with type SFNode/MFNode contain them. Current practice is that, if desired, prototype authors must explicitly add the metadata SFNode field in the ProtoInterface.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DPrototypeInstance'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/core.html#X3DPrototypeInstance'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DPrototypeInstance __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DRigidJointNode(_X3DNode):
    """
    The X3DRigidJointNode abstract node type is the base type for all joint types.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DRigidJointNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rigidBodyPhysics.html#X3DRigidJointNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DRigidJointNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DScriptNode(_X3DChildNode):
    """
    Base type for scripting nodes (but not shader nodes).
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DScriptNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/scripting.html#X3DScriptNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DScriptNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DSequencerNode(_X3DChildNode):
    """
    Base type from which all Sequencers are derived.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DSequencerNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/eventUtilities.html#X3DSequencerNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DSequencerNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DShaderNode(_X3DAppearanceChildNode):
    """
    Base type for all nodes that specify a programmable shader.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DShaderNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shaders.html#X3DShaderNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DShaderNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DShapeNode(_X3DChildNode):
    """
    Base type for all Shape nodes.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DShapeNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shape.html#X3DShapeNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DShapeNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DSoundDestinationNode(_X3DSoundNode):
    """
    Base type for all sound destination nodes, which represent the final destination of an audio signal and are what the user can ultimately hear.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DSoundDestinationNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#X3DSoundDestinationNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DSoundDestinationNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DSoundProcessingNode(_X3DTimeDependentNode):
    """
    Base type for all sound processing nodes, which are used to enhance audio with filtering, delaying, changing gain, etc.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DSoundProcessingNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#X3DSoundProcessingNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DSoundProcessingNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DSoundSourceNode(_X3DTimeDependentNode):
    """
    Nodes implementing X3DSoundSourceNode are allowed as children of Sound node.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DSoundSourceNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#X3DSoundSourceNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DSoundSourceNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DTexture3DNode(_X3DTextureNode):
    """
    Base type for all nodes that specify 3D sources for texture images.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DTexture3DNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texture3D.html#X3DTexture3DNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DTexture3DNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DTextureProjectorNode(_X3DLightNode):
    """
    Base type for all node types that specify projective texture mapping, a form of lighting.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DTextureProjectorNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/TextureProjector.html#X3DTextureProjectorNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DTextureProjectorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DTouchSensorNode(_X3DPointingDeviceSensorNode):
    """
    Base type for all touch-style pointing device sensors.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DTouchSensorNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/pointingDeviceSensor.html#X3DTouchSensorNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DTouchSensorNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DTriggerNode(_X3DChildNode):
    """
    Base type from which all trigger nodes are derived.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DTriggerNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/eventUtilities.html#X3DTriggerNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DTriggerNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DVertexAttributeNode(_X3DGeometricPropertyNode):
    """
    Base type for all nodes that specify per-vertex attribute information to the shader.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DVertexAttributeNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shaders.html#X3DVertexAttributeNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DVertexAttributeNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DViewpointNode(_X3DBindableNode):
    """
    Node type X3DViewpointNode defines a specific location in the local coordinate system from which the user may view the scene, and also defines a viewpoint binding stack.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DViewpointNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/navigation.html#X3DViewpointNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DViewpointNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DViewportNode(_X3DGroupingNode):
    """
    The X3DViewportNode abstract node type is the base node type for viewport nodes.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DViewportNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/layering.html#X3DViewportNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DViewportNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DVolumeDataNode(_X3DChildNode):
    """
    The X3DVolumeDataNode abstract node type is the base type for all node types that describe volumetric data to be rendered.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DVolumeDataNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/volume.html#X3DVolumeDataNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DVolumeDataNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DTextureTransformNode(_X3DAppearanceChildNode):
    """
    Base type for all nodes which specify a transformation of texture coordinates.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DTextureTransformNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texturing.html#X3DTextureTransformNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DTextureTransformNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DSingleTextureTransformNode(_X3DTextureTransformNode):
    """
    Base type for all texture transform nodes which specify texture coordinate transformation for a single texture.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DSingleTextureTransformNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texturing.html#X3DSingleTextureTransformNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DSingleTextureTransformNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DTextureCoordinateNode(_X3DGeometricPropertyNode):
    """
    Base type for all nodes which specify texture coordinates.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DTextureCoordinateNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texturing.html#X3DTextureCoordinateNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DTextureCoordinateNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DSingleTextureCoordinateNode(_X3DTextureCoordinateNode):
    """
    Base type for all texture coordinate nodes which specify texture coordinates for a single texture.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DSingleTextureCoordinateNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texturing.html#X3DSingleTextureCoordinateNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DSingleTextureCoordinateNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DSingleTextureNode(_X3DTextureNode):
    """
    Base type for all texture node types that define a single texture. A single texture can be used to influence a parameter of various material nodes in the Shape component, and it can be a child of MultiTexture.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DSingleTextureNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texturing.html#X3DSingleTextureNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DSingleTextureNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DTexture2DNode(_X3DSingleTextureNode):
    """
    Base type for all nodes which specify 2D sources for texture images.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DTexture2DNode'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texturing.html#X3DTexture2DNode'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractNodeType X3DTexture2DNode __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

###############################################

# Abstract Object Types

# Note that these package-internal class names are preceded by an underscore _ character since X3D authors are not expected to use them

class _X3DBoundedObject(_X3DNode):
    """
    X3DBoundedObject indicates that bounding box values can be provided (or computed) to encompass this node and any children.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DBoundedObject'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/grouping.html#X3DBoundedObject'

class _X3DFogObject(_X3DNode):
    """
    Abstract type describing a node that influences the lighting equation through the use of fog semantics.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DFogObject'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/environmentalEffects.html#X3DFogOjbect'

class _X3DMetadataObject(_X3DNode):
    """
    Each node inheriting the X3DMetadataObject interface contains a single array of strictly typed values: MFBool, MFInt32, MFFloat, MFDouble, MFString, or MFNode, the latter having children that are all Metadata nodes.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DMetadataObject'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/core.html#X3DMetadataObject'
    def __init__(self, DEF, USE, class_, IS, metadata):
        # if _DEBUG: print('... in AbstractObjectType X3DMetadataObject __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only

class _X3DPickableObject(_X3DNode):
    """
    The X3DPickableObject abstract interface marks a node as being capable of having customized picking performed on its contents or children.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DPickableObject'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/picking.html#X3DPickableObject'

class _X3DProgrammableShaderObject(_X3DNode):
    """
    Base type for all nodes that specify arbitrary fields for interfacing with per-object attribute values.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DProgrammableShaderObject'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shaders.html#X3DProgrammableShaderObject'

class _X3DUrlObject(_X3DNode):
    """
    X3DUrlObject indicates that a node has content loaded from a Uniform Resource Locator (URL) and can be tracked via a LoadSensor. Such child nodes have containerField='watchList' to indicate their relationship to the parent LoadSensor node.
    """
    def NAME(self):
        ''' Name of this X3D Abstract Type class. '''
        return '_X3DUrlObject'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/networking.html#X3DUrlObject'

###############################################

# Statements

class _X3DStatement(object):
    """
    All X3D statements implement _X3DStatement abstract type.
    """
    def NAME(self):
        ''' Name of this X3D Statement class. '''
        return '_X3DStatement'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/documents/specifications/19775-1/V3.3/Part01/components/core.html#AbstractX3DStructure'
    def __repl__(self):
        result = self.NAME() + '('
        # if _DEBUG: print(self.NAME() + ' self.FIELD_DECLARATIONS() : ' + str(self.FIELD_DECLARATIONS() ))
        if self.FIELD_DECLARATIONS():
            for each in self.FIELD_DECLARATIONS():
                # if _DEBUG: print(self.NAME() + ' for each in self.FIELD_DECLARATIONS(): each=' + str(each))
                name = each[0]
                default = each[1]
                type_ = each[2]
                accessType = each[3]
                value = getattr(self, name)
                # if _DEBUG: print('gettattr(self, ' + str(name) + ') value="' + str(value)[:100] + '" for FIELD_DECLARATIONS ' + str(each) + ')', flush=True)
                if value != default:
                    if  isinstance(value, list): # avoid X3DTypeError if value is not iterable
                        result += str(name) + '=['
                        for each in value:
                            result += str(each) + ', '
                            # if _DEBUG: print('* _X3DStatement debug: str(each)=' + str(each), flush=True)
                        result = result.rstrip(', ')
                        result += '],'
                    elif isinstance(value, str) and "'" in value:
                        result += str(name) + '=' + '"' + str(value)[:100] + '"' + ','
                    elif isinstance(value, str) and value != default:
                        result += str(name) + '=' + "'" + str(value)[:100] + "'" + ','
                    elif value != default:
                        result += str(name) + '='       + str(value)[:100]       + ','
                    # elif _DEBUG:
        #   result += str(name) + '=' + "'" + str(value)[:100] + "'" + ','
        return result.strip().rstrip(',').rstrip(', ') + ')'
    def __str__(self):
        return self.__repl__().strip() # _X3DStatement

def isX3DStatement(value):
    """
    Whether or not value is an _X3DStatement object.
    """
    return isinstance(value, _X3DStatement)

class Comment(_X3DStatement):
    """
    X3D statement containing zero or more comment strings.
    """
    # immutable constant functions - - - - - - - - - -
    def NAME(self):
        ''' Name of this X3D Statement class. '''
        return 'Comment'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return ''
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return []
    def REGEX_XML(self):
        return r'(\s|\S)*' # (includes lower-case true, false)
    def __init__(self, value=None):
        self.value = value
    @property # getter - - - - - - - - - -
    def value(self):
        """ Provide list of comment strings. """
        return self.__value
    @value.setter
    def value(self, value):
        """ The value setter only allows correctly typed values. """
        if  value is None:
            value = self.DEFAULT_VALUE()
        self.__value = str(value)
    # immutable constant functions - - - - - - - - - -
    def DEFAULT_VALUE(self):
        return ''
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        result = ''
        indent = '  ' * indentLevel
        if self.value:
            result = indent + '<!-- ' + self.value + ' -->' + '\n'
        return result
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        result = ''
        indent = '  ' * indentLevel
        if self.value:
            result = '\n' + indent + '# ' + self.value
        return result

def isComment(value):
    """
    Whether or not value is an _X3DComment object.
    """
    return isinstance(value, _X3DComment)

class component(_X3DStatement):
    """
    Functional summary: each added component statement indicates needed scene functionality support above the given X3D profile.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'component'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/concepts.html#Components'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#component'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('level', 1, FieldType.SFInt32, AccessType.inputOutput, 'component'),
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'component')]
    def __init__(self,
                 level=1,
                 name=''):
        self.level = level
        self.name = name
    @property # getter - - - - - - - - - -
    def level(self):
        """Necessary level of support for this scene, as defined in corresponding Support table for a given node's component."""
        return self.__level
    @level.setter
    def level(self, level):
        if  level is None:
            level = 1 # default
        assertValidSFInt32(level)
        assertGreaterThanEquals('level', level, 1)
        assertLessThanEquals('level', level, 5)
        self.__level = level
    @property # getter - - - - - - - - - -
    def name(self):
        """Provides name of this component, as defined in corresponding X3D Specification component Introduction."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        assertValidComponentName('name', name)
        self.__name = name
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return False
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function component.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<component'
        if self.level != 1:
            result += " level='" + SFInt32(self.level).XML() + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></component>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            result += indent + '</component>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        result += 'COMPONENT ' + self.name + ':' + str(self.level) + '\n'
#       print('VRML serialization complete.', flush=True)
        return result

class connect(_X3DStatement):
    """
    Functional summary: connect statements define event-routing connections between node fields defined inside a ProtoBody declaration back to corresponding ProtoInterface fields.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'connect'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#IS_ConnectStatementSyntax'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#connect'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('nodeField', '', FieldType.SFString, AccessType.inputOutput, 'connect'),
            ('protoField', '', FieldType.SFString, AccessType.inputOutput, 'connect')]
    def __init__(self,
                 nodeField='',
                 protoField=''):
        self.nodeField = nodeField
        self.protoField = protoField
    @property # getter - - - - - - - - - -
    def nodeField(self):
        """Name of field within this node which IS CONNECTed to the ancestor ProtoDeclare field definition."""
        return self.__nodeField
    @nodeField.setter
    def nodeField(self, nodeField):
        if  nodeField is None:
            nodeField = SFString.DEFAULT_VALUE(self)
        assertValidSFString(nodeField)
        self.__nodeField = nodeField
    @property # getter - - - - - - - - - -
    def protoField(self):
        """Name of parent ProtoDeclare field definition connecting to field in this node."""
        return self.__protoField
    @protoField.setter
    def protoField(self, protoField):
        if  protoField is None:
            protoField = SFString.DEFAULT_VALUE(self)
        assertValidSFString(protoField)
        self.__protoField = protoField
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return False
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function connect.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<connect'
        if self.nodeField:
            result += " nodeField='" + self.nodeField + "'"
        if self.protoField:
            result += " protoField='" + self.protoField + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></connect>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            result += indent + '</connect>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function connect.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'connect' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'connect' + ' {'
        if self.nodeField:
            result += " nodeField " +  '"' + self.nodeField + '"' + ""
        if self.protoField:
            result += " protoField " +  '"' + self.protoField + '"' + ""
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class EXPORT(_X3DStatement):
    """
    Functional summary: EXPORT exposes a local node for ROUTE passing of event values when the current Scene is included via Inline by a parent external world. These connections allow event values to be exchanged via ROUTE statements between a parent model and a child Inline model.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'EXPORT'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/concepts.html#EXPORTSemantics'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#EXPORT'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('AS', '', FieldType.SFString, AccessType.inputOutput, 'EXPORT'),
            ('localDEF', '', FieldType.SFString, AccessType.inputOutput, 'EXPORT')]
    def __init__(self,
                 AS='',
                 localDEF=''):
        self.AS = AS
        self.localDEF = localDEF
    @property # getter - - - - - - - - - -
    def AS(self):
        """rename localDEF node AS a different name when exporting."""
        return self.__AS
    @AS.setter
    def AS(self, AS):
        if  AS is None:
            AS = SFString.DEFAULT_VALUE(self)
        assertValidSFString(AS)
        self.__AS = AS
    @property # getter - - - - - - - - - -
    def localDEF(self):
        """localDEF is the DEF name of the local node to be EXPORTed."""
        return self.__localDEF
    @localDEF.setter
    def localDEF(self, localDEF):
        if  localDEF is None:
            localDEF = SFString.DEFAULT_VALUE(self)
        assertValidSFString(localDEF)
        self.__localDEF = localDEF
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return False
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function EXPORT.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<EXPORT'
        if self.AS:
            result += " AS='" + self.AS + "'"
        if self.localDEF:
            result += " localDEF='" + self.localDEF + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></EXPORT>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            result += indent + '</EXPORT>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function EXPORT.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'EXPORT' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'EXPORT' + ' {'
        if self.AS:
            result += " AS " +  '"' + self.AS + '"' + ""
        if self.localDEF:
            result += " localDEF " +  '"' + self.localDEF + '"' + ""
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ExternProtoDeclare(_X3DStatement):
    """
    ExternProtoDeclare refers to a ProtoDeclare node declaration provided in another file. ExternProtoDeclare interfaces are defined by field statements (and without IS/connect statements).
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ExternProtoDeclare'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/concepts.html#Externalprototypesemantics'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ExternProtoDeclare'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('appinfo', '', FieldType.SFString, AccessType.inputOutput, 'ExternProtoDeclare'),
            ('documentation', '', FieldType.SFString, AccessType.inputOutput, 'ExternProtoDeclare'),
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'ExternProtoDeclare'),
            ('url', list(), FieldType.MFString, AccessType.inputOutput, 'ExternProtoDeclare'),
            ('field', list(), FieldType.MFNode, AccessType.inputOutput, 'ExternProtoDeclare')]
    def __init__(self,
                 appinfo='',
                 documentation='',
                 name='',
                 url=list(),
                 field=None):
        self.appinfo = appinfo
        self.documentation = documentation
        self.name = name
        self.url = url
        self.field = field
    @property # getter - - - - - - - - - -
    def appinfo(self):
        """Application information to provide simple description usable as a tooltip, similar to XML Schema appinfo tag."""
        return self.__appinfo
    @appinfo.setter
    def appinfo(self, appinfo):
        if  appinfo is None:
            appinfo = SFString.DEFAULT_VALUE(self)
        assertValidSFString(appinfo)
        self.__appinfo = appinfo
    @property # getter - - - - - - - - - -
    def documentation(self):
        """Documentation url for further information, similar to XML Schema documentation tag."""
        return self.__documentation
    @documentation.setter
    def documentation(self, documentation):
        if  documentation is None:
            documentation = SFString.DEFAULT_VALUE(self)
        assertValidSFString(documentation)
        self.__documentation = documentation
    @property # getter - - - - - - - - - -
    def name(self):
        """name of the ExternProtoDeclare (External Prototype Declaration) being referenced."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def url(self):
        """Location and filename of ProtoDeclare source declaration of interest."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE(self)
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def field(self):
        """Include a field statement for each field declaration in the corresponding original ProtoDeclare."""
        return self.__field
    @field.setter
    def field(self, field):
        if  field is None:
            field = MFNode.DEFAULT_VALUE(self)
        # TODO type-aware checks for field
        if field: # walk each child in MFNode list, if any
            for each in field:
                assertValidFieldInitializationValue(each.name, type(each.value), each.value, parent='ExternProtoDeclare/field')
        self.__field = field
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.field
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ExternProtoDeclare.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ExternProtoDeclare'
        if self.appinfo:
            result += " appinfo='" + self.appinfo + "'"
        if self.documentation:
            result += " documentation='" + self.documentation + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.url != list():
            result += " url='" + MFString(self.url).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ExternProtoDeclare>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            ### if self.field: # walk each child in MFNode list, if any
            ### print('* ExternProtoDeclare found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(field)=' + str(len(self.field)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.field:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ExternProtoDeclare>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ExternProtoDeclare.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ExternProtoDeclare' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ExternProtoDeclare' + ' {'
        if self.appinfo:
            result += " appinfo " +  '"' + self.appinfo + '"' + ""
        if self.documentation:
            result += " documentation " +  '"' + self.documentation + '"' + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if self.url != list():
            result += " url " + MFString(self.url).VRML() + ""
        if self.field: # walk each child in MFNode list, if any
            for each in self.field:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class field(_X3DStatement):
    """
    Functional summary: a field statement defines an interface attribute or node. Each field statement can contain either attribute-value or node content.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'field'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#NodeAndFieldStatementSyntax'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#field'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('accessType', '', FieldType.SFString, AccessType.inputOutput, 'field'),
            ('appinfo', '', FieldType.SFString, AccessType.inputOutput, 'field'),
            ('documentation', '', FieldType.SFString, AccessType.inputOutput, 'field'),
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'field'),
            ('type', '', FieldType.SFString, AccessType.inputOutput, 'field'),
            ('value', '', FieldType.SFString, AccessType.inputOutput, 'field'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'field')]
    def __init__(self,
                 accessType='',
                 appinfo='',
                 documentation='',
                 name='',
                 type='',
                 value='',
                 children=None):
        self.accessType = accessType
        self.appinfo = appinfo
        self.documentation = documentation
        self.name = name
        self.type = type
        self.value = value
        self.children = children
    @property # getter - - - - - - - - - -
    def accessType(self):
        """Event-model semantics for field set/get capabilities."""
        return self.__accessType
    @accessType.setter
    def accessType(self, accessType):
        if  accessType is None:
            accessType = SFString.DEFAULT_VALUE(self)
        assertValidSFString(accessType)
        assertValidAccessType('accessType', accessType)
        self.__accessType = accessType
    @property # getter - - - - - - - - - -
    def appinfo(self):
        """Application information to provide simple description usable as a tooltip, similar to XML Schema appinfo tag."""
        return self.__appinfo
    @appinfo.setter
    def appinfo(self, appinfo):
        if  appinfo is None:
            appinfo = SFString.DEFAULT_VALUE(self)
        assertValidSFString(appinfo)
        self.__appinfo = appinfo
    @property # getter - - - - - - - - - -
    def documentation(self):
        """Documentation url for further information, similar to XML Schema documentation tag."""
        return self.__documentation
    @documentation.setter
    def documentation(self, documentation):
        if  documentation is None:
            documentation = SFString.DEFAULT_VALUE(self)
        assertValidSFString(documentation)
        self.__documentation = documentation
    @property # getter - - - - - - - - - -
    def name(self):
        """Name of this field declaration."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def type(self):
        """Base type of this field variable."""
        return self.__type
    @type.setter
    def type(self, type):
        if  type is None:
            type = SFString.DEFAULT_VALUE(self)
        assertValidSFString(type)
        assertValidFieldType('type', type)
        self.__type = type
    @property # getter - - - - - - - - - -
    def value(self):
        """Provide default initialization value for this field variable (which may be re-initialized later by instantiation value of a named ProtoInstance fieldValue)."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = SFString.DEFAULT_VALUE(self)
        assertValidFieldInitializationValue(self.name, self.type, value, parent='field/@value')
        self.__value = value
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function field.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<field'
        if self.accessType:
            result += " accessType='" + self.accessType + "'"
        if self.appinfo:
            result += " appinfo='" + self.appinfo + "'"
        if self.documentation:
            result += " documentation='" + self.documentation + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.type:
            result += " type='" + self.type + "'"
        if self.value:
            result += " value='" + str(self.value) + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></field>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* field found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</field>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function field.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'field' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'field' + ' {'
        if self.accessType:
            result += " accessType " +  '"' + self.accessType + '"' + ""
        if self.appinfo:
            result += " appinfo " +  '"' + self.appinfo + '"' + ""
        if self.documentation:
            result += " documentation " +  '"' + self.documentation + '"' + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if self.type:
            result += " type " +  '"' + self.type + '"' + ""
        if self.value:
            result += " value " +  '"' + self.value + '"' + ""
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class fieldValue(_X3DStatement):
    """
    Functional summary: a fieldValue statement re-initializes the default value of a field in a ProtoInstance. Each fieldValue statement can contain either attribute-value or node content.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'fieldValue'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#ProtoInstanceAndFieldValueStatement'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#fieldValue'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'fieldValue'),
            ('value', '', FieldType.SFString, AccessType.inputOutput, 'fieldValue'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'fieldValue')]
    def __init__(self,
                 name='',
                 value='',
                 children=None):
        self.name = name
        self.value = value
        self.children = children
    @property # getter - - - - - - - - - -
    def name(self):
        """Name of the ProtoInstance field being re-initialized (corresponding to field name already defined in ProtoDeclare or ExternProtoDeclare)."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def value(self):
        """Initial value for this field, which overrides default initialization value defined in original ProtoDeclare field."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = SFString.DEFAULT_VALUE(self)
        assertValidFieldInitializationValue(self.name, type(value), value, parent='fieldValue')
        self.__value = value
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function fieldValue.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<fieldValue'
        if self.name:
            result += " name='" + self.name + "'"
        if self.value:
            result += " value='" + str(self.value) + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></fieldValue>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* fieldValue found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</fieldValue>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function fieldValue.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'fieldValue' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'fieldValue' + ' {'
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if self.value:
            result += " value " +  '"' + self.value + '"' + ""
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class head(_X3DStatement):
    """
    Functional summary: each X3D scene includes a head statement that can contain component, unit and meta statements.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'head'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#Header'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#head'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [('children', None, FieldType.MFNode, AccessType.inputOutput, 'head')]
    def __init__(self, children=None):
        self.children = children
    @property # getter - - - - - - - - - -
    def children(self):
        """ The head statement has children consisting of component, unit and meta statements. """
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return bool(self.children)
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function head.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<head'
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></head>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.__children: # walk each child in MFNode list, if any
                ## print('* head found self.children, now invoking XML(' + str(indentLevel+1) + ')', flush=True)
                # order is significant for component, unit, meta statements
                for each in self.children:
                    if isinstance(each, component):
                        result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
                for each in self.children:
                    if isinstance(each, unit):
                        result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
                for each in self.children:
                    if isinstance(each, meta):
                        result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</head>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        if self.children: # walk each child in MFNode list, if any
            ## print('* head found self.children, now invoking VRML(' + str(indentLevel+1) + ', ' + VRML97 + ')', flush=True)
            # order is significant for component, unit, meta statements
            for each in self.children:
                if isinstance(each, component):
                    result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
            for each in self.children:
                if isinstance(each, unit):
                    result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
            for each in self.children:
                if isinstance(each, meta):
                    result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
#       print('VRML serialization complete.', flush=True)
        return result

class IMPORT(_X3DStatement):
    """
    Functional summary: IMPORT provides ROUTE access to a node that has a corresponding EXPORT statement within an Inline scene. These connections allow event values to be exchanged via ROUTE statements between a parent model and a child Inline model.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'IMPORT'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/concepts.html#IMPORTSemantics'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IMPORT'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('AS', '', FieldType.SFString, AccessType.inputOutput, 'IMPORT'),
            ('importedDEF', '', FieldType.SFString, AccessType.inputOutput, 'IMPORT'),
            ('inlineDEF', '', FieldType.SFString, AccessType.inputOutput, 'IMPORT')]
    def __init__(self,
                 AS='',
                 importedDEF='',
                 inlineDEF=''):
        self.AS = AS
        self.importedDEF = importedDEF
        self.inlineDEF = inlineDEF
    @property # getter - - - - - - - - - -
    def AS(self):
        """map importedDEF name AS a new name in current scene."""
        return self.__AS
    @AS.setter
    def AS(self, AS):
        if  AS is None:
            AS = SFString.DEFAULT_VALUE(self)
        assertValidSFString(AS)
        self.__AS = AS
    @property # getter - - - - - - - - - -
    def importedDEF(self):
        """importedDEF is DEF name of the node of interest that is contained in the remote inlineDEF scene."""
        return self.__importedDEF
    @importedDEF.setter
    def importedDEF(self, importedDEF):
        if  importedDEF is None:
            importedDEF = SFString.DEFAULT_VALUE(self)
        assertValidSFString(importedDEF)
        self.__importedDEF = importedDEF
    @property # getter - - - - - - - - - -
    def inlineDEF(self):
        """inlineDEF is the DEF name of Inline node in the same scene as this IMPORT statement."""
        return self.__inlineDEF
    @inlineDEF.setter
    def inlineDEF(self, inlineDEF):
        if  inlineDEF is None:
            inlineDEF = SFString.DEFAULT_VALUE(self)
        assertValidSFString(inlineDEF)
        self.__inlineDEF = inlineDEF
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return False
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function IMPORT.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<IMPORT'
        if self.AS:
            result += " AS='" + self.AS + "'"
        if self.importedDEF:
            result += " importedDEF='" + self.importedDEF + "'"
        if self.inlineDEF:
            result += " inlineDEF='" + self.inlineDEF + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></IMPORT>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            result += indent + '</IMPORT>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function IMPORT.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'IMPORT' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'IMPORT' + ' {'
        if self.AS:
            result += " AS " +  '"' + self.AS + '"' + ""
        if self.importedDEF:
            result += " importedDEF " +  '"' + self.importedDEF + '"' + ""
        if self.inlineDEF:
            result += " inlineDEF " +  '"' + self.inlineDEF + '"' + ""
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class IS(_X3DStatement):
    """
    Functional summary: the IS statement connects node fields defined inside a ProtoBody declaration back to corresponding ProtoInterface fields. IS/connect statements can be added if the parent node is within a ProtoBody and connect statements define correspondences between prototype fields and built-in node fields.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'IS'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/concepts.html#PROTOdefinitionsemantics'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IS'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('connect', list(), FieldType.MFNode, AccessType.inputOutput, 'IS')]
    def __init__(self,
                 connect=None):
        self.connect = connect
    @property # getter - - - - - - - - - -
    def connect(self):
        """When inside a ProtoBody declaration and an IS statement, add a connect statement to define event-routing connections between a parent node's field to a corresponding ProtoInterface field."""
        return self.__connect
    @connect.setter
    def connect(self, connect):
        if  connect is None:
            connect = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(connect)
        self.__connect = connect
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.connect
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function IS.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<IS'
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></IS>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            ### if self.connect: # walk each child in MFNode list, if any
            ### print('* IS found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(connect)=' + str(len(self.connect)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.connect:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</IS>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function IS.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'IS' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'IS' + ' {'
        if self.connect: # walk each child in MFNode list, if any
            for each in self.connect:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class meta(_X3DStatement):
    """
    Functional summary: the meta statement provides metadata information about a scene, where name and content attributes provide attribute=value metadata pairs.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'meta'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#Header'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#meta'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('content', '', FieldType.SFString, AccessType.inputOutput, 'meta'),
            ('dir', '', FieldType.SFString, AccessType.inputOutput, 'meta'),
            ('httpequiv', '', FieldType.SFString, AccessType.inputOutput, 'meta'),
            ('lang', '', FieldType.SFString, AccessType.inputOutput, 'meta'),
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'meta'),
            ('scheme', '', FieldType.SFString, AccessType.inputOutput, 'meta')]
    def __init__(self,
                 content='',
                 dir='',
                 httpequiv='',
                 lang='',
                 name='',
                 scheme=''):
        self.content = content
        self.dir = dir
        self.httpequiv = httpequiv
        self.lang = lang
        self.name = name
        self.scheme = scheme
    @property # getter - - - - - - - - - -
    def content(self):
        """The content attribute provides metadata information relevant to the name attribute provided."""
        return self.__content
    @content.setter
    def content(self, content):
        if  content is None:
            content = SFString.DEFAULT_VALUE(self)
        assertValidSFString(content)
        self.__content = content
    @property # getter - - - - - - - - - -
    def dir(self):
        """Direction for weak/neutral text (ltr=left-to-right, rtl=right-to-left)."""
        return self.__dir
    @dir.setter
    def dir(self, dir):
        if  dir is None:
            dir = SFString.DEFAULT_VALUE(self)
        assertValidSFString(dir)
        assertValidMetaDirection('dir', dir)
        self.__dir = dir
    @property # getter - - - - - - - - - -
    def httpequiv(self):
        return self.__httpequiv
    @httpequiv.setter
    def httpequiv(self, httpequiv):
        if  httpequiv is None:
            httpequiv = SFString.DEFAULT_VALUE(self)
        assertValidSFString(httpequiv)
        self.__httpequiv = httpequiv
    @property # getter - - - - - - - - - -
    def lang(self):
        """Language code, as per [IETF BCP47/RFC5646] https://www."""
        return self.__lang
    @lang.setter
    def lang(self, lang):
        if  lang is None:
            lang = SFString.DEFAULT_VALUE(self)
        assertValidSFString(lang)
        self.__lang = lang
    @property # getter - - - - - - - - - -
    def name(self):
        """Keyword name of the meta attribute, following the same naming conventions as HTML's meta tag."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def scheme(self):
        """The scheme attribute allows authors to provide user agents more context for the correct interpretation of meta information."""
        return self.__scheme
    @scheme.setter
    def scheme(self, scheme):
        if  scheme is None:
            scheme = SFString.DEFAULT_VALUE(self)
        assertValidSFString(scheme)
        self.__scheme = scheme
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return False
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function meta.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<meta'
        if self.content:
            result += " content='" + self.content + "'"
        if self.dir:
            result += " dir='" + self.dir + "'"
        if self.httpequiv:
            result += " httpequiv='" + self.httpequiv + "'"
        if self.lang:
            result += " lang='" + self.lang + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.scheme:
            result += " scheme='" + self.scheme + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></meta>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            result += indent + '</meta>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        result += 'META "' + self.name + '" "' + self.content + '"' + '\n'
#       print('VRML serialization complete.', flush=True)
        return result

class ProtoBody(_X3DStatement):
    """
    ProtoBody contains the definition nodes for new Prototype nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ProtoBody'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#PrototypeAndFieldDeclarationSyntax'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProtoBody'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'ProtoBody')]
    def __init__(self,
                 children=None):
        self.children = children
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ProtoBody.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ProtoBody'
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ProtoBody>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* ProtoBody found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ProtoBody>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ProtoBody.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ProtoBody' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ProtoBody' + ' {'
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ProtoDeclare(_X3DStatement):
    """
    ProtoDeclare defines new Prototype nodes. Nested ProtoDeclares and ProtoInstances are allowed by the specification.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ProtoDeclare'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#PrototypeAndFieldDeclarationSyntax'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProtoDeclare'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('appinfo', '', FieldType.SFString, AccessType.inputOutput, 'ProtoDeclare'),
            ('documentation', '', FieldType.SFString, AccessType.inputOutput, 'ProtoDeclare'),
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'ProtoDeclare'),
            ('ProtoBody', None, FieldType.SFNode, AccessType.inputOutput, 'ProtoDeclare'),
            ('ProtoInterface', None, FieldType.SFNode, AccessType.inputOutput, 'ProtoDeclare')]
    def __init__(self,
                 appinfo='',
                 documentation='',
                 name='',
                 ProtoBody=None,
                 ProtoInterface=None):
        self.appinfo = appinfo
        self.documentation = documentation
        self.name = name
        self.ProtoBody = ProtoBody
        self.ProtoInterface = ProtoInterface
    @property # getter - - - - - - - - - -
    def appinfo(self):
        """Application information to provide simple description usable as a tooltip, similar to XML Schema appinfo tag."""
        return self.__appinfo
    @appinfo.setter
    def appinfo(self, appinfo):
        if  appinfo is None:
            appinfo = SFString.DEFAULT_VALUE(self)
        assertValidSFString(appinfo)
        self.__appinfo = appinfo
    @property # getter - - - - - - - - - -
    def documentation(self):
        """Documentation url for further information, similar to XML Schema documentation tag."""
        return self.__documentation
    @documentation.setter
    def documentation(self, documentation):
        if  documentation is None:
            documentation = SFString.DEFAULT_VALUE(self)
        assertValidSFString(documentation)
        self.__documentation = documentation
    @property # getter - - - - - - - - - -
    def name(self):
        """name of this prototype being declared."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def ProtoBody(self):
        """Include one ProtoBody statements after the ProtoInterface statement."""
        return self.__ProtoBody
    @ProtoBody.setter
    def ProtoBody(self, ProtoBody):
        if  ProtoBody is None:
            ProtoBody = None # default
        assertValidSFNode(ProtoBody)
        if not isinstance(ProtoBody, object):
            # print(flush=True)
            raise X3DTypeError(str(ProtoBody) + ' does not have a valid node type object')
        self.__ProtoBody = ProtoBody
    @property # getter - - - - - - - - - -
    def ProtoInterface(self):
        """Include an optional ProtoInterface statement if this ProtoDeclare has field declarations."""
        return self.__ProtoInterface
    @ProtoInterface.setter
    def ProtoInterface(self, ProtoInterface):
        if  ProtoInterface is None:
            ProtoInterface = None # default
        assertValidSFNode(ProtoInterface)
        if not isinstance(ProtoInterface, object):
            # print(flush=True)
            raise X3DTypeError(str(ProtoInterface) + ' does not have a valid node type object')
        self.__ProtoInterface = ProtoInterface
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.ProtoBody or self.ProtoInterface
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ProtoDeclare.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ProtoDeclare'
        if self.appinfo:
            result += " appinfo='" + self.appinfo + "'"
        if self.documentation:
            result += " documentation='" + self.documentation + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ProtoDeclare>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.ProtoBody: # output this SFNode
                result += self.ProtoBody.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.ProtoInterface: # output this SFNode
                result += self.ProtoInterface.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ProtoDeclare>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ProtoDeclare.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ProtoDeclare' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ProtoDeclare' + ' {'
        if self.appinfo:
            result += " appinfo " +  '"' + self.appinfo + '"' + ""
        if self.documentation:
            result += " documentation " +  '"' + self.documentation + '"' + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if self.ProtoBody: # output this SFNode
            result += '\n' + '  ' + indent + 'ProtoBody ' + self.ProtoBody.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.ProtoInterface: # output this SFNode
            result += '\n' + '  ' + indent + 'ProtoInterface ' + self.ProtoInterface.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ProtoInterface(_X3DStatement):
    """
    ProtoInterface defines fields for new Prototype nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ProtoInterface'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#PrototypeAndFieldDeclarationSyntax'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProtoInterface'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('field', list(), FieldType.MFNode, AccessType.inputOutput, 'ProtoInterface')]
    def __init__(self,
                 field=None):
        self.field = field
    @property # getter - - - - - - - - - -
    def field(self):
        """Include a field statement for each field declaration in this ProtoDeclare's ProtoInterface."""
        return self.__field
    @field.setter
    def field(self, field):
        if  field is None:
            field = MFNode.DEFAULT_VALUE(self)
        # TODO type-aware checks for field
        if field: # walk each child in MFNode list, if any
            for each in field:
                assertValidFieldInitializationValue(each.name, each.type, each.value, parent='ProtoInterface')
        self.__field = field
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.field
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ProtoInterface.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ProtoInterface'
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ProtoInterface>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            ### if self.field: # walk each child in MFNode list, if any
            ### print('* ProtoInterface found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(field)=' + str(len(self.field)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.field:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ProtoInterface>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ProtoInterface.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ProtoInterface' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ProtoInterface' + ' {'
        if self.field: # walk each child in MFNode list, if any
            for each in self.field:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ROUTE(_X3DStatement):
    """
    ROUTE connects output fields of event-producing nodes to input fields of event-consuming nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ROUTE'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/concepts.html#ModifyingObjectsRoutes'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ROUTE'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('fromField', '', FieldType.SFString, AccessType.inputOutput, 'ROUTE'),
            ('fromNode', '', FieldType.SFString, AccessType.inputOutput, 'ROUTE'),
            ('toField', '', FieldType.SFString, AccessType.inputOutput, 'ROUTE'),
            ('toNode', '', FieldType.SFString, AccessType.inputOutput, 'ROUTE')]
    def __init__(self,
                 fromField='',
                 fromNode='',
                 toField='',
                 toNode=''):
        self.fromField = fromField
        self.fromNode = fromNode
        self.toField = toField
        self.toNode = toNode
    @property # getter - - - - - - - - - -
    def fromField(self):
        """fromField is the field name in the source node which is originating an event."""
        return self.__fromField
    @fromField.setter
    def fromField(self, fromField):
        if  fromField is None:
            fromField = SFString.DEFAULT_VALUE(self)
        assertValidSFString(fromField)
        self.__fromField = fromField
    @property # getter - - - - - - - - - -
    def fromNode(self):
        """fromNode is the DEF name of the node originating an event."""
        return self.__fromNode
    @fromNode.setter
    def fromNode(self, fromNode):
        if  fromNode is None:
            fromNode = SFString.DEFAULT_VALUE(self)
        assertValidSFString(fromNode)
        self.__fromNode = fromNode
    @property # getter - - - - - - - - - -
    def toField(self):
        """toField is the field name in the destination node which is receiving an event."""
        return self.__toField
    @toField.setter
    def toField(self, toField):
        if  toField is None:
            toField = SFString.DEFAULT_VALUE(self)
        assertValidSFString(toField)
        self.__toField = toField
    @property # getter - - - - - - - - - -
    def toNode(self):
        """toNode is the DEF name of the destination node receiving an event."""
        return self.__toNode
    @toNode.setter
    def toNode(self, toNode):
        if  toNode is None:
            toNode = SFString.DEFAULT_VALUE(self)
        assertValidSFString(toNode)
        self.__toNode = toNode
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return False
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ROUTE.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ROUTE'
        if self.fromField:
            result += " fromField='" + self.fromField + "'"
        if self.fromNode:
            result += " fromNode='" + self.fromNode + "'"
        if self.toField:
            result += " toField='" + self.toField + "'"
        if self.toNode:
            result += " toNode='" + self.toNode + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ROUTE>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            result += indent + '</ROUTE>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ROUTE.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ROUTE' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ROUTE' + ' {'
        if self.fromField:
            result += " fromField " +  '"' + self.fromField + '"' + ""
        if self.fromNode:
            result += " fromNode " +  '"' + self.fromNode + '"' + ""
        if self.toField:
            result += " toField " +  '"' + self.toField + '"' + ""
        if self.toNode:
            result += " toNode " +  '"' + self.toNode + '"' + ""
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Scene(_X3DStatement):
    """
    Scene is the implicit root node of the X3D scene graph.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Scene'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#Header'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Scene'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'Scene')]
    def __init__(self,
                 children=None):
        self.children = children
    @property # getter - - - - - - - - - -
    def children(self):
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Scene.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Scene'
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Scene>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* Scene found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Scene>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=0, VRML97=VRML97)
#       print('VRML serialization complete.', flush=True)
        return result

class unit(_X3DStatement):
    """
    Functional summary: unit statement defines data-conversion factors for typed values defined in a scene.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'unit'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/core.html#UNITStatement'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#unit'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('category', '', FieldType.SFString, AccessType.initializeOnly, 'unit'),
            ('conversionFactor', 1.0, FieldType.SFDouble, AccessType.inputOutput, 'unit'),
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'unit')]
    def __init__(self,
                 category='',
                 conversionFactor=1.0,
                 name=''):
        self.category = category
        self.conversionFactor = conversionFactor
        self.name = name
    @property # getter - - - - - - - - - -
    def category(self):
        """Base-unit category as defined in X3D Specification."""
        return self.__category
    @category.setter
    def category(self, category):
        if  category is None:
            category = SFString.DEFAULT_VALUE(self)
        assertValidSFString(category)
        assertValidUnitCategory('category', category)
        self.__category = category
    @property # getter - - - - - - - - - -
    def conversionFactor(self):
        """[0,+infinity) Positive double-precision factor that converts new base unit to default base unit."""
        return self.__conversionFactor
    @conversionFactor.setter
    def conversionFactor(self, conversionFactor):
        if  conversionFactor is None:
            conversionFactor = 1.0 # default
        assertValidSFDouble(conversionFactor)
        assertPositive('conversionFactor', conversionFactor)
        self.__conversionFactor = conversionFactor
    @property # getter - - - - - - - - - -
    def name(self):
        """Author-defined name for this unit conversionFactor value (for example, FeetToMeters)."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return False
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function unit.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<unit'
        if self.category:
            result += " category='" + self.category + "'"
        if self.conversionFactor != 1.0:
            result += " conversionFactor='" + SFDouble(self.conversionFactor).XML() + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></unit>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            result += indent + '</unit>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        result += 'UNIT ' + self.category + ' ' + self.name + ' ' + str(self.conversionFactor) + '\n'
#       print('VRML serialization complete.', flush=True)
        return result

class X3D(_X3DNode):
    """
    X3D is the root node for an Extensible 3D (X3D) Graphics model.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'X3D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#Header'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#X3D'
    XML_HEADER = '<?xml version="1.0" encoding="UTF-8"?>'
    XML_DOCTYPE_X3D_3_0 = '<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.0//EN" "https://www.web3d.org/specifications/x3d-3.0.dtd">'
    XML_DOCTYPE_X3D_3_1 = '<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.1//EN" "https://www.web3d.org/specifications/x3d-3.1.dtd">'
    XML_DOCTYPE_X3D_3_2 = '<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.2//EN" "https://www.web3d.org/specifications/x3d-3.2.dtd">'
    XML_DOCTYPE_X3D_3_3 = '<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 3.3//EN" "https://www.web3d.org/specifications/x3d-3.3.dtd">'
    XML_DOCTYPE_X3D_4_0 = '<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 4.0//EN" "https://www.web3d.org/specifications/x3d-4.0.dtd">'
    XML_DOCTYPE_X3D_4_1 = '<!DOCTYPE X3D PUBLIC "ISO//Web3D//DTD X3D 4.1//EN" "https://www.web3d.org/specifications/x3d-4.1.dtd">'
    X3D_XML_SCHEMA_ATTRIBUTES_3_0 = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-3.0.xsd'"
    X3D_XML_SCHEMA_ATTRIBUTES_3_1 = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-3.1.xsd'"
    X3D_XML_SCHEMA_ATTRIBUTES_3_2 = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-3.2.xsd'"
    X3D_XML_SCHEMA_ATTRIBUTES_3_3 = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-3.3.xsd'"
    X3D_XML_SCHEMA_ATTRIBUTES_4_0 = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-4.0.xsd'"
    X3D_XML_SCHEMA_ATTRIBUTES_4_1 = "xmlns:xsd='http://www.w3.org/2001/XMLSchema-instance' xsd:noNamespaceSchemaLocation='https://www.web3d.org/specifications/x3d-4.1.xsd'"
    VRML97_HEADER = '#VRML V2.0 utf8'
    CLASSIC_VRML_HEADER_PREFIX = '#VRML V' # followed by X3D version number
    CLASSIC_VRML_HEADER_SUFFIX = ' utf8'
    X3DOM_HEADER = """<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- =================================================================== -->
<!-- embedded X3D scene appears after html/head/script and style entries -->
<!-- =================================================================== -->
<html>
   <head>
      <title></title>
      <meta http-equiv="X-UA-Compatible" content="chrome=1,IE=edge"/>
      <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<!-- Numbered X3DOM release versions: https://doc.x3dom.org/download -->
<!-- Developer X3DOM release version: https://doc.x3dom.org/download/dev -->
<link rel="stylesheet"
            type="text/css"
            href="https://x3dom.org/release/x3dom.css"/>
      <script type="text/javascript" src="https://x3dom.org/release/x3dom-full.js"/>
      <meta name="warning"
            content="Webfonts must be loaded prior to using Text node in X3D scene... see https://x3dom.org/x3dom/example/x3dom_text.html"/>
      <!-- X3DOM needs Web Fonts when an X3D Text node is included -->
      <!-- adapted from https://x3dom.org/x3dom/example/x3dom_text.html and http://web.mit.edu/jmorzins/www/fonts.html -->
      <style type="text/css">
/* ============================================================================= */
@font-face {
  font-family: 'SERIF'; /* default original */
  font-style: normal;
  font-weight: 700;
  src: local('Roman'), url('Roman.ttf') format('truetype');
}
@font-face {
  font-family: 'SERIF'; /* default alternate */
  font-style: normal;
  font-weight: 700;
  src: local('Times New Roman'), local('TimesNewRoman'), url('Times New Roman.ttf') format('truetype');
}
/* ============================================================================= */
@font-face {
  font-family: 'SANS'; /* default original */
  font-style: normal;
  font-weight: 400;
  src: local('Arial'), url('Arial.ttf') format('truetype');
}
@font-face {
  font-family: 'SANS'; /* default alternate */
  font-style: normal;
  font-weight: 400;
  src: local('Helvetica'), url('Helvetica.ttf') format('truetype');
}
/* ============================================================================= */
@font-face {
  font-family: 'TYPEWRITER'; /* default original */
  font-style: normal;
  font-weight: 900;
  src: local('Courier'), url('Courier.ttf') format('truetype');
}
@font-face {
  font-family: 'TYPEWRITER'; /* default alternate */
  font-style: normal;
  font-weight: 900;
  src: local('Courier New'), url('Courier New.ttf') format('truetype');
}
/* ============================================================================= */
</style>
   </head>
   <body>"""
    X3DOM_FOOTER = """
   </body>
</html>
"""
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('profile', 'Immersive', FieldType.SFString, AccessType.inputOutput, 'X3D'),
            ('version', '4.0', FieldType.SFString, AccessType.inputOutput, 'X3D'),
            ('head', None, FieldType.SFNode, AccessType.inputOutput, 'X3D'),
            ('Scene', None, FieldType.SFNode, AccessType.inputOutput, 'X3D')]
    def __init__(self,
                 profile='Immersive',
                 version='4.0',
                 head=None,
                 Scene=None):
        self.profile = profile
        self.version = version
        self.head = head
        self.Scene = Scene
    @property # getter - - - - - - - - - -
    def profile(self):
        """profile attribute is required and defines the player or tool support needed for this model."""
        return self.__profile
    @profile.setter
    def profile(self, profile):
        if  profile is None:
            profile = 'Immersive' # default
        assertValidSFString(profile)
        assertValidProfileName('profile', profile)
        self.__profile = profile
    @property # getter - - - - - - - - - -
    def version(self):
        """Default is highest value matching schema and DOCTYPE in the scene."""
        return self.__version
    @version.setter
    def version(self, version):
        if  version is None:
            version = '4.0' # default
        assertValidSFString(version)
        assertValidX3dVersion('version', version)
        self.__version = version
    @property # getter - - - - - - - - - -
    def head(self):
        """Include a head element to contain component, unit or meta statements for this X3D model."""
        return self.__head
    @head.setter
    def head(self, head):
        if  head is None:
            head = None # default
        assertValidSFNode(head)
        if not isinstance(head, object):
            # print(flush=True)
            raise X3DTypeError(str(head) + ' does not have a valid node type object')
        self.__head = head
    @property # getter - - - - - - - - - -
    def Scene(self):
        """Include a Scene element to contain scene-graph nodes for this X3D model."""
        return self.__Scene
    @Scene.setter
    def Scene(self, Scene):
        if  Scene is None:
            Scene = None # default
        assertValidSFNode(Scene)
        if not isinstance(Scene, object):
            # print(flush=True)
            raise X3DTypeError(str(Scene) + ' does not have a valid node type object')
        self.__Scene = Scene
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.head or self.Scene
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function X3D.XML(indentLevel=' + str(indentLevel) + '), indent="' + indent + '"' + '\n'
        result += indent + self.XML_HEADER + '\n'
        if self.version == '3.0':
            result += indent + self.XML_DOCTYPE_X3D_3_0 + '\n'
        elif self.version == '3.1':
            result += indent + self.XML_DOCTYPE_X3D_3_1 + '\n'
        elif self.version == '3.2':
            result += indent + self.XML_DOCTYPE_X3D_3_2 + '\n'
        elif self.version == '3.3':
            result += indent + self.XML_DOCTYPE_X3D_3_3 + '\n'
        elif self.version == '4.0':
            result += indent + self.XML_DOCTYPE_X3D_4_0 + '\n'
        elif self.version == '4.1':
            result += indent + self.XML_DOCTYPE_X3D_4_1 + '\n'
        result += indent + "<X3D profile='" + self.profile +"' version='" + self.version +"' "
        if self.version == '3.0':
            result += self.X3D_XML_SCHEMA_ATTRIBUTES_3_0
        elif self.version == '3.1':
            result += self.X3D_XML_SCHEMA_ATTRIBUTES_3_1
        elif self.version == '3.2':
            result += self.X3D_XML_SCHEMA_ATTRIBUTES_3_2
        elif self.version == '3.3':
            result += self.X3D_XML_SCHEMA_ATTRIBUTES_3_3
        elif self.version == '4.0':
            result += self.X3D_XML_SCHEMA_ATTRIBUTES_4_0
        elif self.version == '4.1':
            result += self.X3D_XML_SCHEMA_ATTRIBUTES_4_1
        result += '>' + '\n' # finish open tag
        if self.head and self.head.hasChild():
            result += str(self.head.XML(indentLevel=indentLevel+1, syntax=syntax))
        if self.Scene and self.Scene.hasChild():
            result += str(self.Scene.XML(indentLevel=indentLevel+1, syntax=syntax))
        result += '</X3D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def VRML97(self, indentLevel=0):
        """ Provide VRML97 output serialization suitable for .wrl file. """
        return VRML(self, indentLevel=0, VRML97=True)
    # output function - - - - - - - - - -
    def ClassicVRML(self, indentLevel=0):
        """ Provide ClassicVRML output serialization suitable for .x3dv file. """
        return VRML(self, indentLevel=0, VRML97=False)
    # output function - - - - - - - - - -
#    def X_ITE(self): #TODO
#        """ Provide X_ITE output serialization suitable for .html file. """
#        return X3D.X_ITE_HEADER + result + self.XML(indentLevel=0, syntax="XML") + X3D.X_ITE_FOOTER:
    # output function - - - - - - - - - -
    def X3DOM(self, indentLevel=0):
        """ Provide X3DOM output serialization suitable for .html file. """
        return X3D.X3DOM_HEADER + self.XML(indentLevel=0, syntax="HTML5") + X3D.X3DOM_FOOTER
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        if VRML97:
            result += self.VRML97_HEADER + '\n'
            result += '# X3D-to-VRML97 serialization autogenerated by X3DPSAIL x3d.py' + '\n'
        else:
            result += self.CLASSIC_VRML_HEADER_PREFIX + str(self.version) + self.CLASSIC_VRML_HEADER_SUFFIX + '\n'
        result += '# X3D-to-ClassicVRML serialization autogenerated by X3DPSAIL x3d.py' + '\n'
        result += '\n'
        if not VRML97:
            result += 'PROFILE '
            if not self.profile or VRML97:
                result += 'IMMERSIVE' + '\n'
            else:
                result += self.profile + '\n'
        if self.head and self.head.hasChild():
            result += str(self.head.VRML(indentLevel=indentLevel+1, VRML97=VRML97))
        if self.Scene and self.Scene.hasChild():
            result += str(self.Scene.VRML(indentLevel=indentLevel+1, VRML97=VRML97))
        result += '\n'
#       print('VRML serialization complete.', flush=True)
        return result

###############################################

# Concrete Nodes

def isX3DNode(value):
    return isinstance(value, _X3DNode)

class AcousticProperties(_X3DAppearanceChildNode):
    """
    AcousticProperties specifies the interaction of sound waves with characteristics of geometric objects in the scene.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'AcousticProperties'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shape.html#AcousticProperties'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#AcousticProperties'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('absorption', 0, FieldType.SFFloat, AccessType.inputOutput, 'AcousticProperties'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'AcousticProperties'),
            ('diffuse', 0, FieldType.SFFloat, AccessType.inputOutput, 'AcousticProperties'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'AcousticProperties'),
            ('refraction', 0, FieldType.SFFloat, AccessType.inputOutput, 'AcousticProperties'),
            ('specular', 0, FieldType.SFFloat, AccessType.inputOutput, 'AcousticProperties'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 absorption=0,
                 description='',
                 diffuse=0,
                 enabled=True,
                 refraction=0,
                 specular=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode AcousticProperties __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.absorption = absorption
        self.description = description
        self.diffuse = diffuse
        self.enabled = enabled
        self.refraction = refraction
        self.specular = specular
    @property # getter - - - - - - - - - -
    def absorption(self):
        """[0,1] specifies the sound absorption coefficient of a surface, meaning the ratio of sound intensity not reflected by a surface."""
        return self.__absorption
    @absorption.setter
    def absorption(self, absorption):
        if  absorption is None:
            absorption = 0 # default
        assertValidSFFloat(absorption)
        assertZeroToOne('absorption', absorption)
        self.__absorption = absorption
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def diffuse(self):
        """[0,1] diffuse coefficient of sound reflection indicuating how mutch of incident sound energy is reflected back in multiple directions."""
        return self.__diffuse
    @diffuse.setter
    def diffuse(self, diffuse):
        if  diffuse is None:
            diffuse = 0 # default
        assertValidSFFloat(diffuse)
        assertZeroToOne('diffuse', diffuse)
        self.__diffuse = diffuse
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def refraction(self):
        """[0,1] sound refraction coefficient of a medium, which determines change in propagation direction of sound wave when obliquely crossing boundary between two mediums where its speed is different."""
        return self.__refraction
    @refraction.setter
    def refraction(self, refraction):
        if  refraction is None:
            refraction = 0 # default
        assertValidSFFloat(refraction)
        assertZeroToOne('refraction', refraction)
        self.__refraction = refraction
    @property # getter - - - - - - - - - -
    def specular(self):
        """[0,1] specular coefficient of sound reflection striking a plane surface, directly reflected back into space, where angle of reflection equals angle of incidence."""
        return self.__specular
    @specular.setter
    def specular(self, specular):
        if  specular is None:
            specular = 0 # default
        assertValidSFFloat(specular)
        assertZeroToOne('specular', specular)
        self.__specular = specular
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function AcousticProperties.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<AcousticProperties'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.absorption != 0:
            result += " absorption='" + SFFloat(self.absorption).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.diffuse != 0:
            result += " diffuse='" + SFFloat(self.diffuse).XML() + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.refraction != 0:
            result += " refraction='" + SFFloat(self.refraction).XML() + "'"
        if self.specular != 0:
            result += " specular='" + SFFloat(self.specular).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></AcousticProperties>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</AcousticProperties>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function AcousticProperties.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'AcousticProperties' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'AcousticProperties' + ' {'
        if self.absorption != 0:
            result += " absorption " + SFFloat(self.absorption).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.diffuse != 0:
            result += " diffuse " + SFFloat(self.diffuse).VRML() + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.refraction != 0:
            result += " refraction " + SFFloat(self.refraction).VRML() + ""
        if self.specular != 0:
            result += " specular " + SFFloat(self.specular).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Analyser(_X3DSoundProcessingNode):
    """
    Analyser provides real-time frequency and time-domain analysis information, without any change to the input.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Analyser'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#Analyser'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Analyser'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('channelCountMode', 'max', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('channelInterpretation', 'speakers', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('fftSize', 2048, FieldType.SFInt32, AccessType.inputOutput, 'Analyser'),
            ('frequencyBinCount', 1024, FieldType.SFInt32, AccessType.inputOutput, 'Analyser'),
            ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('maxDecibels', -30, FieldType.SFFloat, AccessType.inputOutput, 'Analyser'),
            ('minDecibels', -100, FieldType.SFFloat, AccessType.inputOutput, 'Analyser'),
            ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('smoothingTimeConstant', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'Analyser'),
            ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('tailTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 channelCountMode='max',
                 channelInterpretation='speakers',
                 description='',
                 enabled=True,
                 fftSize=2048,
                 frequencyBinCount=1024,
                 gain=1,
                 maxDecibels=-30,
                 minDecibels=-100,
                 pauseTime=0,
                 resumeTime=0,
                 smoothingTimeConstant=0.8,
                 startTime=0,
                 stopTime=0,
                 tailTime=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Analyser __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.fftSize = fftSize
        self.frequencyBinCount = frequencyBinCount
        self.gain = gain
        self.maxDecibels = maxDecibels
        self.minDecibels = minDecibels
        self.pauseTime = pauseTime
        self.resumeTime = resumeTime
        self.smoothingTimeConstant = smoothingTimeConstant
        self.startTime = startTime
        self.stopTime = stopTime
        self.tailTime = tailTime
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'max' # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'speakers' # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def fftSize(self):
        """(0,+infinity) fftSize represents size of Fast Fourier Transform (FFT) used to determine frequency domain."""
        return self.__fftSize
    @fftSize.setter
    def fftSize(self, fftSize):
        if  fftSize is None:
            fftSize = 2048 # default
        assertValidSFInt32(fftSize)
        assertNonNegative('fftSize', fftSize)
        self.__fftSize = fftSize
    @property # getter - - - - - - - - - -
    def frequencyBinCount(self):
        """(0,+infinity) frequencyBinCount is half of fftSize and generally equates to number of data values available for the visualization."""
        return self.__frequencyBinCount
    @frequencyBinCount.setter
    def frequencyBinCount(self, frequencyBinCount):
        if  frequencyBinCount is None:
            frequencyBinCount = 1024 # default
        assertValidSFInt32(frequencyBinCount)
        assertNonNegative('frequencyBinCount', frequencyBinCount)
        self.__frequencyBinCount = frequencyBinCount
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1 # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def maxDecibels(self):
        """(-infinity,+infinity) maxDecibels represents maximum power value in scaling range for FFT analysis data."""
        return self.__maxDecibels
    @maxDecibels.setter
    def maxDecibels(self, maxDecibels):
        if  maxDecibels is None:
            maxDecibels = -30 # default
        assertValidSFFloat(maxDecibels)
        self.__maxDecibels = maxDecibels
    @property # getter - - - - - - - - - -
    def minDecibels(self):
        """(-infinity,+infinity) minDecibels represents minimum power value in scaling range for FFT analysis data."""
        return self.__minDecibels
    @minDecibels.setter
    def minDecibels(self, minDecibels):
        if  minDecibels is None:
            minDecibels = -100 # default
        assertValidSFFloat(minDecibels)
        self.__minDecibels = minDecibels
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0 # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0 # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def smoothingTimeConstant(self):
        """(0,+infinity) smoothingTimeConstant represents averaging constant during last analysis frame."""
        return self.__smoothingTimeConstant
    @smoothingTimeConstant.setter
    def smoothingTimeConstant(self, smoothingTimeConstant):
        if  smoothingTimeConstant is None:
            smoothingTimeConstant = 0.8 # default
        assertValidSFFloat(smoothingTimeConstant)
        assertNonNegative('smoothingTimeConstant', smoothingTimeConstant)
        self.__smoothingTimeConstant = smoothingTimeConstant
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0 # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0 # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def tailTime(self):
        """[0,+infinity) tailTime is duration of time that a node continues to provide output signal after the input signal becomes silent."""
        return self.__tailTime
    @tailTime.setter
    def tailTime(self, tailTime):
        if  tailTime is None:
            tailTime = 0 # default
        assertValidSFTime(tailTime)
        assertNonNegative('tailTime', tailTime)
        self.__tailTime = tailTime
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Analyser.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Analyser'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.channelCountMode != 'max':
            result += " channelCountMode='" + self.channelCountMode + "'"
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation='" + self.channelInterpretation + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.fftSize != 2048:
            result += " fftSize='" + SFInt32(self.fftSize).XML() + "'"
        if self.frequencyBinCount != 1024:
            result += " frequencyBinCount='" + SFInt32(self.frequencyBinCount).XML() + "'"
        if self.gain != 1:
            result += " gain='" + SFFloat(self.gain).XML() + "'"
        if self.maxDecibels != -30:
            result += " maxDecibels='" + SFFloat(self.maxDecibels).XML() + "'"
        if self.minDecibels != -100:
            result += " minDecibels='" + SFFloat(self.minDecibels).XML() + "'"
        if self.pauseTime != 0:
            result += " pauseTime='" + SFTime(self.pauseTime).XML() + "'"
        if self.resumeTime != 0:
            result += " resumeTime='" + SFTime(self.resumeTime).XML() + "'"
        if self.smoothingTimeConstant != 0.8:
            result += " smoothingTimeConstant='" + SFFloat(self.smoothingTimeConstant).XML() + "'"
        if self.startTime != 0:
            result += " startTime='" + SFTime(self.startTime).XML() + "'"
        if self.stopTime != 0:
            result += " stopTime='" + SFTime(self.stopTime).XML() + "'"
        if self.tailTime != 0:
            result += " tailTime='" + SFTime(self.tailTime).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Analyser>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Analyser>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Analyser.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Analyser' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Analyser' + ' {'
        if self.channelCountMode != 'max':
            result += " channelCountMode " +  '"' + self.channelCountMode + '"' + ""
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation " +  '"' + self.channelInterpretation + '"' + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.fftSize != 2048:
            result += " fftSize " + SFInt32(self.fftSize).VRML() + ""
        if self.frequencyBinCount != 1024:
            result += " frequencyBinCount " + SFInt32(self.frequencyBinCount).VRML() + ""
        if self.gain != 1:
            result += " gain " + SFFloat(self.gain).VRML() + ""
        if self.maxDecibels != -30:
            result += " maxDecibels " + SFFloat(self.maxDecibels).VRML() + ""
        if self.minDecibels != -100:
            result += " minDecibels " + SFFloat(self.minDecibels).VRML() + ""
        if self.pauseTime != 0:
            result += " pauseTime " + SFTime(self.pauseTime).VRML() + ""
        if self.resumeTime != 0:
            result += " resumeTime " + SFTime(self.resumeTime).VRML() + ""
        if self.smoothingTimeConstant != 0.8:
            result += " smoothingTimeConstant " + SFFloat(self.smoothingTimeConstant).VRML() + ""
        if self.startTime != 0:
            result += " startTime " + SFTime(self.startTime).VRML() + ""
        if self.stopTime != 0:
            result += " stopTime " + SFTime(self.stopTime).VRML() + ""
        if self.tailTime != 0:
            result += " tailTime " + SFTime(self.tailTime).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Anchor(_X3DGroupingNode, _X3DUrlObject):
    """
    Anchor is a Grouping node that can contain most nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Anchor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/networking.html#Anchor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Anchor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DUrlObject'),
            ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
            ('parameter', list(), FieldType.MFString, AccessType.inputOutput, 'Anchor'),
            ('refresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
            ('url', list(), FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 description='',
                 load=True,
                 parameter=list(),
                 refresh=0,
                 url=list(),
                 visible=True,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Anchor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.description = description
        self.load = load
        self.parameter = parameter
        self.refresh = refresh
        self.url = url
        self.visible = visible
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def load(self):
        """The load field has no effect, Anchor operation is only triggered by user selection."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def parameter(self):
        """If provided, parameter tells the X3D player where to to redirect the loaded url."""
        return self.__parameter
    @parameter.setter
    def parameter(self, parameter):
        if  parameter is None:
            parameter = MFString.DEFAULT_VALUE(self)
        assertValidMFString(parameter)
        self.__parameter = parameter
    @property # getter - - - - - - - - - -
    def refresh(self):
        """The refresh field has no effect, Anchor operation is only triggered by user selection."""
        return self.__refresh
    @refresh.setter
    def refresh(self, refresh):
        if  refresh is None:
            refresh = 0 # default
        assertValidSFTime(refresh)
        assertNonNegative('refresh', refresh)
        self.__refresh = refresh
    @property # getter - - - - - - - - - -
    def url(self):
        """Address of replacement world, or #ViewpointDEFName within the current scene, or alternate Web resource, activated by the user selecting Shape geometry within the Anchor children nodes."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE(self)
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Anchor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Anchor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.load: # default=true
            result += " load='" + SFBool(self.load).XML() + "'"
        if self.parameter != list():
            result += " parameter='" + MFString(self.parameter).XML() + "'"
        if self.refresh != 0:
            result += " refresh='" + SFTime(self.refresh).XML() + "'"
        if self.url != list():
            result += " url='" + MFString(self.url).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Anchor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* Anchor found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Anchor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Anchor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Anchor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Anchor' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.load: # default=true
            result += " load " + SFBool(self.load).VRML() + ""
        if self.parameter != list():
            result += " parameter " + MFString(self.parameter).VRML() + ""
        if self.refresh != 0:
            result += " refresh " + SFTime(self.refresh).VRML() + ""
        if self.url != list():
            result += " url " + MFString(self.url).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Appearance(_X3DAppearanceNode):
    """
    Appearance specifies the visual properties of geometry by containing the Material, ImageTexture/MovieTexture/PixelTexture, FillProperties, LineProperties, programmable shader nodes (ComposedShader, PackagedShader, ProgramShader) and TextureTransform nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Appearance'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shape.html#Appearance'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Appearance'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('acousticProperties', None, FieldType.SFNode, AccessType.inputOutput, 'Appearance'),
            ('fillProperties', None, FieldType.SFNode, AccessType.inputOutput, 'Appearance'),
            ('lineProperties', None, FieldType.SFNode, AccessType.inputOutput, 'Appearance'),
            ('material', None, FieldType.SFNode, AccessType.inputOutput, 'Appearance'),
            ('pointProperties', None, FieldType.SFNode, AccessType.inputOutput, 'Appearance'),
            ('texture', None, FieldType.SFNode, AccessType.inputOutput, 'Appearance'),
            ('textureTransform', None, FieldType.SFNode, AccessType.inputOutput, 'Appearance'),
            ('shaders', list(), FieldType.MFNode, AccessType.inputOutput, 'Appearance'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 acousticProperties=None,
                 fillProperties=None,
                 lineProperties=None,
                 material=None,
                 pointProperties=None,
                 texture=None,
                 textureTransform=None,
                 shaders=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Appearance __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.acousticProperties = acousticProperties
        self.fillProperties = fillProperties
        self.lineProperties = lineProperties
        self.material = material
        self.pointProperties = pointProperties
        self.texture = texture
        self.textureTransform = textureTransform
        self.shaders = shaders
    @property # getter - - - - - - - - - -
    def acousticProperties(self):
        """[AcousticProperties] Single contained acousticProperties node that specifies additional acoustic attributes applied to associated surface geometry."""
        return self.__acousticProperties
    @acousticProperties.setter
    def acousticProperties(self, acousticProperties):
        if  acousticProperties is None:
            acousticProperties = None # default
        assertValidSFNode(acousticProperties)
        if not isinstance(acousticProperties, object):
            # print(flush=True)
            raise X3DTypeError(str(acousticProperties) + ' does not have a valid node type object')
        self.__acousticProperties = acousticProperties
    @property # getter - - - - - - - - - -
    def fillProperties(self):
        """[FillProperties] Single contained FillProperties node that specifies additional visual attributes applied to polygonal areas of corresponding geometry, on top of whatever other appearance is already defined."""
        return self.__fillProperties
    @fillProperties.setter
    def fillProperties(self, fillProperties):
        if  fillProperties is None:
            fillProperties = None # default
        assertValidSFNode(fillProperties)
        if not isinstance(fillProperties, object):
            # print(flush=True)
            raise X3DTypeError(str(fillProperties) + ' does not have a valid node type object')
        self.__fillProperties = fillProperties
    @property # getter - - - - - - - - - -
    def lineProperties(self):
        """[LineProperties] Single contained LineProperties node that specifies additional visual attributes applied to corresponding line geometry."""
        return self.__lineProperties
    @lineProperties.setter
    def lineProperties(self, lineProperties):
        if  lineProperties is None:
            lineProperties = None # default
        assertValidSFNode(lineProperties)
        if not isinstance(lineProperties, object):
            # print(flush=True)
            raise X3DTypeError(str(lineProperties) + ' does not have a valid node type object')
        self.__lineProperties = lineProperties
    @property # getter - - - - - - - - - -
    def material(self):
        """[X3DMaterialNode] Single contained Material node that specifies visual attributes for lighting response (color types, transparency, etc."""
        return self.__material
    @material.setter
    def material(self, material):
        if  material is None:
            material = None # default
        assertValidSFNode(material)
        if not isinstance(material, object):
            # print(flush=True)
            raise X3DTypeError(str(material) + ' does not have a valid node type object')
        self.__material = material
    @property # getter - - - - - - - - - -
    def pointProperties(self):
        return self.__pointProperties
    @pointProperties.setter
    def pointProperties(self, pointProperties):
        if  pointProperties is None:
            pointProperties = None # default
        assertValidSFNode(pointProperties)
        if not isinstance(pointProperties, object):
            # print(flush=True)
            raise X3DTypeError(str(pointProperties) + ' does not have a valid node type object')
        self.__pointProperties = pointProperties
    @property # getter - - - - - - - - - -
    def texture(self):
        """[X3DTextureNode] Single contained texture node (ImageTexture, MovieTexture, PixelTexture, MultiTexture) that maps image(s) to surface geometry."""
        return self.__texture
    @texture.setter
    def texture(self, texture):
        if  texture is None:
            texture = None # default
        assertValidSFNode(texture)
        if not isinstance(texture, object):
            # print(flush=True)
            raise X3DTypeError(str(texture) + ' does not have a valid node type object')
        self.__texture = texture
    @property # getter - - - - - - - - - -
    def textureTransform(self):
        """[X3DTextureTransformNode] Single contained TextureTransform node that defines 2D transformation applied to texture coordinates."""
        return self.__textureTransform
    @textureTransform.setter
    def textureTransform(self, textureTransform):
        if  textureTransform is None:
            textureTransform = None # default
        assertValidSFNode(textureTransform)
        if not isinstance(textureTransform, object):
            # print(flush=True)
            raise X3DTypeError(str(textureTransform) + ' does not have a valid node type object')
        self.__textureTransform = textureTransform
    @property # getter - - - - - - - - - -
    def shaders(self):
        """[X3DShaderNode] Zero or more contained programmable shader nodes (ComposedShader, PackagedShader, ProgramShader) that specify, in order of preference, author-programmed rendering characteristics."""
        return self.__shaders
    @shaders.setter
    def shaders(self, shaders):
        if  shaders is None:
            shaders = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(shaders)
        self.__shaders = shaders
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.shaders or self.acousticProperties or self.fillProperties or self.IS or self.lineProperties or self.material or self.metadata or self.pointProperties or self.texture or self.textureTransform
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Appearance.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Appearance'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Appearance>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.acousticProperties: # output this SFNode
                result += self.acousticProperties.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.fillProperties: # output this SFNode
                result += self.fillProperties.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.lineProperties: # output this SFNode
                result += self.lineProperties.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.material: # output this SFNode
                result += self.material.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.pointProperties: # output this SFNode
                result += self.pointProperties.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.texture: # output this SFNode
                result += self.texture.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.textureTransform: # output this SFNode
                result += self.textureTransform.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.shaders: # walk each child in MFNode list, if any
            ### print('* Appearance found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(shaders)=' + str(len(self.shaders)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.shaders:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Appearance>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Appearance.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Appearance' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Appearance' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.acousticProperties: # output this SFNode
            result += '\n' + '  ' + indent + 'acousticProperties ' + self.acousticProperties.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.fillProperties: # output this SFNode
            result += '\n' + '  ' + indent + 'fillProperties ' + self.fillProperties.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.lineProperties: # output this SFNode
            result += '\n' + '  ' + indent + 'lineProperties ' + self.lineProperties.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.material: # output this SFNode
            result += '\n' + '  ' + indent + 'material ' + self.material.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.pointProperties: # output this SFNode
            result += '\n' + '  ' + indent + 'pointProperties ' + self.pointProperties.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texture: # output this SFNode
            result += '\n' + '  ' + indent + 'texture ' + self.texture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.textureTransform: # output this SFNode
            result += '\n' + '  ' + indent + 'textureTransform ' + self.textureTransform.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.shaders: # walk each child in MFNode list, if any
            for each in self.shaders:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Arc2D(_X3DGeometryNode):
    """
    Arc2D is a line-based geometry node that defines a linear circular arc with center (0,0) in X-Y plane, with angles measured starting at positive x-axis and sweeping towards positive y-axis.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Arc2D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geometry2D.html#Arc2D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Arc2D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('endAngle', 1.570796, FieldType.SFFloat, AccessType.initializeOnly, 'Arc2D'),
            ('radius', 1, FieldType.SFFloat, AccessType.initializeOnly, 'Arc2D'),
            ('startAngle', 0, FieldType.SFFloat, AccessType.initializeOnly, 'Arc2D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 endAngle=1.570796,
                 radius=1,
                 startAngle=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Arc2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.endAngle = endAngle
        self.radius = radius
        self.startAngle = startAngle
    @property # getter - - - - - - - - - -
    def endAngle(self):
        """[0,2pi] Arc extends from startAngle counterclockwise to endAngle, in radians."""
        return self.__endAngle
    @endAngle.setter
    def endAngle(self, endAngle):
        if  endAngle is None:
            endAngle = 1.570796 # default
        assertValidSFFloat(endAngle)
        assertGreaterThan('endAngle', endAngle, -6.2832)
        assertLessThan('endAngle', endAngle, 6.2832)
        self.__endAngle = endAngle
    @property # getter - - - - - - - - - -
    def radius(self):
        """(0,+infinity) circle radius, of which the arc is a portion."""
        return self.__radius
    @radius.setter
    def radius(self, radius):
        if  radius is None:
            radius = 1 # default
        assertValidSFFloat(radius)
        assertPositive('radius', radius)
        self.__radius = radius
    @property # getter - - - - - - - - - -
    def startAngle(self):
        """[0,2pi] Arc extends from startAngle counterclockwise to endAngle, in radians."""
        return self.__startAngle
    @startAngle.setter
    def startAngle(self, startAngle):
        if  startAngle is None:
            startAngle = 0 # default
        assertValidSFFloat(startAngle)
        assertGreaterThan('startAngle', startAngle, -6.2832)
        assertLessThan('startAngle', startAngle, 6.2832)
        self.__startAngle = startAngle
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Arc2D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Arc2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.endAngle != 1.570796:
            result += " endAngle='" + SFFloat(self.endAngle).XML() + "'"
        if self.radius != 1:
            result += " radius='" + SFFloat(self.radius).XML() + "'"
        if self.startAngle != 0:
            result += " startAngle='" + SFFloat(self.startAngle).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Arc2D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Arc2D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Arc2D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Arc2D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Arc2D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.endAngle != 1.570796:
            result += " endAngle " + SFFloat(self.endAngle).VRML() + ""
        if self.radius != 1:
            result += " radius " + SFFloat(self.radius).VRML() + ""
        if self.startAngle != 0:
            result += " startAngle " + SFFloat(self.startAngle).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ArcClose2D(_X3DGeometryNode):
    """
    ArcClose2D is a polygonal geometry node that defines a linear circular arc, closed by PIE or CHORD line segments, with center (0,0) in X-Y plane, with angles measured starting at positive x-axis and sweeping towards positive y-axis.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ArcClose2D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geometry2D.html#ArcClose2D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ArcClose2D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('closureType', 'PIE', FieldType.SFString, AccessType.initializeOnly, 'ArcClose2D'),
            ('endAngle', 1.570796, FieldType.SFFloat, AccessType.initializeOnly, 'ArcClose2D'),
            ('radius', 1, FieldType.SFFloat, AccessType.initializeOnly, 'ArcClose2D'),
            ('solid', False, FieldType.SFBool, AccessType.initializeOnly, 'ArcClose2D'),
            ('startAngle', 0, FieldType.SFFloat, AccessType.initializeOnly, 'ArcClose2D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 closureType='PIE',
                 endAngle=1.570796,
                 radius=1,
                 solid=False,
                 startAngle=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ArcClose2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.closureType = closureType
        self.endAngle = endAngle
        self.radius = radius
        self.solid = solid
        self.startAngle = startAngle
    @property # getter - - - - - - - - - -
    def closureType(self):
        """Defines whether pair of line segments connect to center (PIE), or single line-segment chord connects arc endpoints (CHORD)."""
        return self.__closureType
    @closureType.setter
    def closureType(self, closureType):
        if  closureType is None:
            closureType = 'PIE' # default
        assertValidSFString(closureType)
        assertValidClosureType('closureType', closureType)
        self.__closureType = closureType
    @property # getter - - - - - - - - - -
    def endAngle(self):
        """[0,2pi] Arc extends from startAngle counterclockwise to endAngle, in radians."""
        return self.__endAngle
    @endAngle.setter
    def endAngle(self, endAngle):
        if  endAngle is None:
            endAngle = 1.570796 # default
        assertValidSFFloat(endAngle)
        assertGreaterThan('endAngle', endAngle, -6.2832)
        assertLessThan('endAngle', endAngle, 6.2832)
        self.__endAngle = endAngle
    @property # getter - - - - - - - - - -
    def radius(self):
        """(0,+infinity) circle radius, of which the arc is a portion."""
        return self.__radius
    @radius.setter
    def radius(self, radius):
        if  radius is None:
            radius = 1 # default
        assertValidSFFloat(radius)
        assertPositive('radius', radius)
        self.__radius = radius
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = False # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def startAngle(self):
        """[0,2pi] Arc extends from startAngle counterclockwise to endAngle, in radians."""
        return self.__startAngle
    @startAngle.setter
    def startAngle(self, startAngle):
        if  startAngle is None:
            startAngle = 0 # default
        assertValidSFFloat(startAngle)
        assertGreaterThan('startAngle', startAngle, -6.2832)
        assertLessThan('startAngle', startAngle, 6.2832)
        self.__startAngle = startAngle
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ArcClose2D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ArcClose2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.closureType != 'PIE':
            result += " closureType='" + self.closureType + "'"
        if self.endAngle != 1.570796:
            result += " endAngle='" + SFFloat(self.endAngle).XML() + "'"
        if self.radius != 1:
            result += " radius='" + SFFloat(self.radius).XML() + "'"
        if self.solid: # default=false
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if self.startAngle != 0:
            result += " startAngle='" + SFFloat(self.startAngle).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ArcClose2D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ArcClose2D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ArcClose2D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ArcClose2D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ArcClose2D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.closureType != 'PIE':
            result += " closureType " +  '"' + self.closureType + '"' + ""
        if self.endAngle != 1.570796:
            result += " endAngle " + SFFloat(self.endAngle).VRML() + ""
        if self.radius != 1:
            result += " radius " + SFFloat(self.radius).VRML() + ""
        if self.solid: # default=false
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.startAngle != 0:
            result += " startAngle " + SFFloat(self.startAngle).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class AudioClip(_X3DSoundSourceNode, _X3DUrlObject):
    """
    AudioClip provides audio data used by parent Sound nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'AudioClip'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#AudioClip'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#AudioClip'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundSourceNode'),
            ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundSourceNode'),
            ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
            ('loop', False, FieldType.SFBool, AccessType.inputOutput, 'AudioClip'),
            ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('pitch', 1.0, FieldType.SFFloat, AccessType.inputOutput, 'AudioClip'),
            ('refresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
            ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('url', list(), FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 enabled=True,
                 gain=1,
                 load=True,
                 loop=False,
                 pauseTime=0,
                 pitch=1.0,
                 refresh=0,
                 resumeTime=0,
                 startTime=0,
                 stopTime=0,
                 url=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode AudioClip __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.load = load
        self.loop = loop
        self.pauseTime = pauseTime
        self.pitch = pitch
        self.refresh = refresh
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.url = url
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1 # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def loop(self):
        """Repeat indefinitely when loop=true, repeat only once when loop=false."""
        return self.__loop
    @loop.setter
    def loop(self, loop):
        if  loop is None:
            loop = False # default
        assertValidSFBool(loop)
        self.__loop = loop
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0 # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def pitch(self):
        """(0,+infinity) Multiplier for the rate at which sampled sound is played."""
        return self.__pitch
    @pitch.setter
    def pitch(self, pitch):
        if  pitch is None:
            pitch = 1.0 # default
        assertValidSFFloat(pitch)
        assertPositive('pitch', pitch)
        self.__pitch = pitch
    @property # getter - - - - - - - - - -
    def refresh(self):
        """refresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__refresh
    @refresh.setter
    def refresh(self, refresh):
        if  refresh is None:
            refresh = 0 # default
        assertValidSFTime(refresh)
        assertNonNegative('refresh', refresh)
        self.__refresh = refresh
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0 # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0 # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0 # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def url(self):
        """Location and filename of sound file or stream."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE(self)
        assertValidMFString(url)
        self.__url = url
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function AudioClip.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<AudioClip'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.gain != 1:
            result += " gain='" + SFFloat(self.gain).XML() + "'"
        if not self.load: # default=true
            result += " load='" + SFBool(self.load).XML() + "'"
        if self.loop: # default=false
            result += " loop='" + SFBool(self.loop).XML() + "'"
        if self.pauseTime != 0:
            result += " pauseTime='" + SFTime(self.pauseTime).XML() + "'"
        if self.pitch != 1.0:
            result += " pitch='" + SFFloat(self.pitch).XML() + "'"
        if self.refresh != 0:
            result += " refresh='" + SFTime(self.refresh).XML() + "'"
        if self.resumeTime != 0:
            result += " resumeTime='" + SFTime(self.resumeTime).XML() + "'"
        if self.startTime != 0:
            result += " startTime='" + SFTime(self.startTime).XML() + "'"
        if self.stopTime != 0:
            result += " stopTime='" + SFTime(self.stopTime).XML() + "'"
        if self.url != list():
            result += " url='" + MFString(self.url).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></AudioClip>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</AudioClip>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function AudioClip.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'AudioClip' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'AudioClip' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.gain != 1:
            result += " gain " + SFFloat(self.gain).VRML() + ""
        if not self.load: # default=true
            result += " load " + SFBool(self.load).VRML() + ""
        if self.loop: # default=false
            result += " loop " + SFBool(self.loop).VRML() + ""
        if self.pauseTime != 0:
            result += " pauseTime " + SFTime(self.pauseTime).VRML() + ""
        if self.pitch != 1.0:
            result += " pitch " + SFFloat(self.pitch).VRML() + ""
        if self.refresh != 0:
            result += " refresh " + SFTime(self.refresh).VRML() + ""
        if self.resumeTime != 0:
            result += " resumeTime " + SFTime(self.resumeTime).VRML() + ""
        if self.startTime != 0:
            result += " startTime " + SFTime(self.startTime).VRML() + ""
        if self.stopTime != 0:
            result += " stopTime " + SFTime(self.stopTime).VRML() + ""
        if self.url != list():
            result += " url " + MFString(self.url).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class AudioDestination(_X3DSoundDestinationNode):
    """
    AudioDestination node represents the final audio destination and is what user ultimately hears, typically from the speakers of user device.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'AudioDestination'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#AudioDestination'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#AudioDestination'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('channelCountMode', 'max', FieldType.SFString, AccessType.inputOutput, 'X3DSoundDestinationNode'),
            ('channelInterpretation', 'speakers', FieldType.SFString, AccessType.inputOutput, 'X3DSoundDestinationNode'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSoundNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundNode'),
            ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundDestinationNode'),
            ('maxChannelCount', 2, FieldType.SFInt32, AccessType.inputOutput, 'AudioDestination'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 channelCountMode='max',
                 channelInterpretation='speakers',
                 description='',
                 enabled=True,
                 gain=1,
                 maxChannelCount=2,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode AudioDestination __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.maxChannelCount = maxChannelCount
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'max' # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'speakers' # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1 # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def maxChannelCount(self):
        """[0,+infinity) [maxChannelCount."""
        return self.__maxChannelCount
    @maxChannelCount.setter
    def maxChannelCount(self, maxChannelCount):
        if  maxChannelCount is None:
            maxChannelCount = 2 # default
        assertValidSFInt32(maxChannelCount)
        assertNonNegative('maxChannelCount', maxChannelCount)
        self.__maxChannelCount = maxChannelCount
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function AudioDestination.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<AudioDestination'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.channelCountMode != 'max':
            result += " channelCountMode='" + self.channelCountMode + "'"
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation='" + self.channelInterpretation + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.gain != 1:
            result += " gain='" + SFFloat(self.gain).XML() + "'"
        if self.maxChannelCount != 2:
            result += " maxChannelCount='" + SFInt32(self.maxChannelCount).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></AudioDestination>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</AudioDestination>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function AudioDestination.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'AudioDestination' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'AudioDestination' + ' {'
        if self.channelCountMode != 'max':
            result += " channelCountMode " +  '"' + self.channelCountMode + '"' + ""
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation " +  '"' + self.channelInterpretation + '"' + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.gain != 1:
            result += " gain " + SFFloat(self.gain).VRML() + ""
        if self.maxChannelCount != 2:
            result += " maxChannelCount " + SFInt32(self.maxChannelCount).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Background(_X3DBackgroundNode):
    """
    Background simulates ground and sky, using vertical arrays of wraparound color values.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Background'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/environmentalEffects.html#Background'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Background'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('backUrl', list(), FieldType.MFString, AccessType.inputOutput, 'Background'),
            ('bottomUrl', list(), FieldType.MFString, AccessType.inputOutput, 'Background'),
            ('frontUrl', list(), FieldType.MFString, AccessType.inputOutput, 'Background'),
            ('groundAngle', list(), FieldType.MFFloat, AccessType.inputOutput, 'X3DBackgroundNode'),
            ('groundColor', list(), FieldType.MFColor, AccessType.inputOutput, 'X3DBackgroundNode'),
            ('leftUrl', list(), FieldType.MFString, AccessType.inputOutput, 'Background'),
            ('rightUrl', list(), FieldType.MFString, AccessType.inputOutput, 'Background'),
            ('skyAngle', list(), FieldType.MFFloat, AccessType.inputOutput, 'X3DBackgroundNode'),
            ('skyColor', [(0, 0, 0)], FieldType.MFColor, AccessType.inputOutput, 'X3DBackgroundNode'),
            ('topUrl', list(), FieldType.MFString, AccessType.inputOutput, 'Background'),
            ('transparency', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DBackgroundNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 backUrl=list(),
                 bottomUrl=list(),
                 frontUrl=list(),
                 groundAngle=list(),
                 groundColor=list(),
                 leftUrl=list(),
                 rightUrl=list(),
                 skyAngle=list(),
                 skyColor=[(0, 0, 0)],
                 topUrl=list(),
                 transparency=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Background __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.backUrl = backUrl
        self.bottomUrl = bottomUrl
        self.frontUrl = frontUrl
        self.groundAngle = groundAngle
        self.groundColor = groundColor
        self.leftUrl = leftUrl
        self.rightUrl = rightUrl
        self.skyAngle = skyAngle
        self.skyColor = skyColor
        self.topUrl = topUrl
        self.transparency = transparency
    @property # getter - - - - - - - - - -
    def backUrl(self):
        """Image background panorama between ground/sky backdrop and scene's geometry."""
        return self.__backUrl
    @backUrl.setter
    def backUrl(self, backUrl):
        if  backUrl is None:
            backUrl = MFString.DEFAULT_VALUE(self)
        assertValidMFString(backUrl)
        self.__backUrl = backUrl
    @property # getter - - - - - - - - - -
    def bottomUrl(self):
        """Image background panorama between ground/sky backdrop and scene's geometry."""
        return self.__bottomUrl
    @bottomUrl.setter
    def bottomUrl(self, bottomUrl):
        if  bottomUrl is None:
            bottomUrl = MFString.DEFAULT_VALUE(self)
        assertValidMFString(bottomUrl)
        self.__bottomUrl = bottomUrl
    @property # getter - - - - - - - - - -
    def frontUrl(self):
        """Image background panorama between ground/sky backdrop and scene's geometry."""
        return self.__frontUrl
    @frontUrl.setter
    def frontUrl(self, frontUrl):
        if  frontUrl is None:
            frontUrl = MFString.DEFAULT_VALUE(self)
        assertValidMFString(frontUrl)
        self.__frontUrl = frontUrl
    @property # getter - - - - - - - - - -
    def groundAngle(self):
        """[0,pi/2] The angle array values increase from 0."""
        return self.__groundAngle
    @groundAngle.setter
    def groundAngle(self, groundAngle):
        if  groundAngle is None:
            groundAngle = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(groundAngle)
        assertGreaterThanEquals('groundAngle', groundAngle, 0)
        assertLessThanEquals('groundAngle', groundAngle, 1.5708)
        self.__groundAngle = groundAngle
    @property # getter - - - - - - - - - -
    def groundColor(self):
        """Color of the ground at the various angles on the ground partial sphere."""
        return self.__groundColor
    @groundColor.setter
    def groundColor(self, groundColor):
        if  groundColor is None:
            groundColor = MFColor.DEFAULT_VALUE(self)
        assertValidMFColor(groundColor)
        assertZeroToOne('groundColor', groundColor)
        self.__groundColor = groundColor
    @property # getter - - - - - - - - - -
    def leftUrl(self):
        """Image background panorama between ground/sky backdrop and scene's geometry."""
        return self.__leftUrl
    @leftUrl.setter
    def leftUrl(self, leftUrl):
        if  leftUrl is None:
            leftUrl = MFString.DEFAULT_VALUE(self)
        assertValidMFString(leftUrl)
        self.__leftUrl = leftUrl
    @property # getter - - - - - - - - - -
    def rightUrl(self):
        """Image background panorama between ground/sky backdrop and scene's geometry."""
        return self.__rightUrl
    @rightUrl.setter
    def rightUrl(self, rightUrl):
        if  rightUrl is None:
            rightUrl = MFString.DEFAULT_VALUE(self)
        assertValidMFString(rightUrl)
        self.__rightUrl = rightUrl
    @property # getter - - - - - - - - - -
    def skyAngle(self):
        """[0,pi] The angle array values increase from 0."""
        return self.__skyAngle
    @skyAngle.setter
    def skyAngle(self, skyAngle):
        if  skyAngle is None:
            skyAngle = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(skyAngle)
        assertGreaterThanEquals('skyAngle', skyAngle, 0)
        assertLessThanEquals('skyAngle', skyAngle, 3.1416)
        self.__skyAngle = skyAngle
    @property # getter - - - - - - - - - -
    def skyColor(self):
        """Color of the sky at various angles on the sky sphere."""
        return self.__skyColor
    @skyColor.setter
    def skyColor(self, skyColor):
        if  skyColor is None:
            skyColor = [(0, 0, 0)] # default
        assertValidMFColor(skyColor)
        assertZeroToOne('skyColor', skyColor)
        self.__skyColor = skyColor
    @property # getter - - - - - - - - - -
    def topUrl(self):
        """Image background panorama between ground/sky backdrop and scene's geometry."""
        return self.__topUrl
    @topUrl.setter
    def topUrl(self, topUrl):
        if  topUrl is None:
            topUrl = MFString.DEFAULT_VALUE(self)
        assertValidMFString(topUrl)
        self.__topUrl = topUrl
    @property # getter - - - - - - - - - -
    def transparency(self):
        """[0,1] how "clear" the background is, allows underlying page to show through: 1."""
        return self.__transparency
    @transparency.setter
    def transparency(self, transparency):
        if  transparency is None:
            transparency = 0 # default
        assertValidSFFloat(transparency)
        assertZeroToOne('transparency', transparency)
        self.__transparency = transparency
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Background.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Background'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.backUrl != list():
            result += " backUrl='" + MFString(self.backUrl).XML() + "'"
        if self.bottomUrl != list():
            result += " bottomUrl='" + MFString(self.bottomUrl).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.frontUrl != list():
            result += " frontUrl='" + MFString(self.frontUrl).XML() + "'"
        if self.groundAngle != list():
            result += " groundAngle='" + MFFloat(self.groundAngle).XML() + "'"
        if self.groundColor != list():
            result += " groundColor='" + MFColor(self.groundColor).XML() + "'"
        if self.leftUrl != list():
            result += " leftUrl='" + MFString(self.leftUrl).XML() + "'"
        if self.rightUrl != list():
            result += " rightUrl='" + MFString(self.rightUrl).XML() + "'"
        if self.skyAngle != list():
            result += " skyAngle='" + MFFloat(self.skyAngle).XML() + "'"
        if self.skyColor != [(0, 0, 0)]:
            result += " skyColor='" + MFColor(self.skyColor).XML() + "'"
        if self.topUrl != list():
            result += " topUrl='" + MFString(self.topUrl).XML() + "'"
        if self.transparency != 0:
            result += " transparency='" + SFFloat(self.transparency).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Background>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Background>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Background.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Background' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Background' + ' {'
        if self.backUrl != list():
            result += " backUrl " + MFString(self.backUrl).VRML() + ""
        if self.bottomUrl != list():
            result += " bottomUrl " + MFString(self.bottomUrl).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.frontUrl != list():
            result += " frontUrl " + MFString(self.frontUrl).VRML() + ""
        if self.groundAngle != list():
            result += " groundAngle " + MFFloat(self.groundAngle).VRML() + ""
        if self.groundColor != list():
            result += " groundColor " + MFColor(self.groundColor).VRML() + ""
        if self.leftUrl != list():
            result += " leftUrl " + MFString(self.leftUrl).VRML() + ""
        if self.rightUrl != list():
            result += " rightUrl " + MFString(self.rightUrl).VRML() + ""
        if self.skyAngle != list():
            result += " skyAngle " + MFFloat(self.skyAngle).VRML() + ""
        if self.skyColor != [(0, 0, 0)]:
            result += " skyColor " + MFColor(self.skyColor).VRML() + ""
        if self.topUrl != list():
            result += " topUrl " + MFString(self.topUrl).VRML() + ""
        if self.transparency != 0:
            result += " transparency " + SFFloat(self.transparency).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class BallJoint(_X3DRigidJointNode):
    """
    BallJoint represents an unconstrained joint between two bodies that pivot about a common anchor point.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'BallJoint'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rigidBodyPhysics.html#BallJoint'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BallJoint'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('anchorPoint', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'BallJoint'),
            ('forceOutput', ["NONE"], FieldType.MFString, AccessType.inputOutput, 'X3DRigidJointNode'),
            ('body1', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
            ('body2', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 anchorPoint=(0, 0, 0),
                 forceOutput=["NONE"],
                 body1=None,
                 body2=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode BallJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.anchorPoint = anchorPoint
        self.forceOutput = forceOutput
        self.body1 = body1
        self.body2 = body2
    @property # getter - - - - - - - - - -
    def anchorPoint(self):
        """anchorPoint is joint center, specified in world coordinates."""
        return self.__anchorPoint
    @anchorPoint.setter
    def anchorPoint(self, anchorPoint):
        if  anchorPoint is None:
            anchorPoint = (0, 0, 0) # default
        assertValidSFVec3f(anchorPoint)
        self.__anchorPoint = anchorPoint
    @property # getter - - - - - - - - - -
    def forceOutput(self):
        """forceOutput controls which output fields are generated for the next frame."""
        return self.__forceOutput
    @forceOutput.setter
    def forceOutput(self, forceOutput):
        if  forceOutput is None:
            forceOutput = ["NONE"] # default
        assertValidMFString(forceOutput)
        self.__forceOutput = forceOutput
    @property # getter - - - - - - - - - -
    def body1(self):
        return self.__body1
    @body1.setter
    def body1(self, body1):
        if  body1 is None:
            body1 = None # default
        assertValidSFNode(body1)
        if not isinstance(body1, object):
            # print(flush=True)
            raise X3DTypeError(str(body1) + ' does not have a valid node type object')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        return self.__body2
    @body2.setter
    def body2(self, body2):
        if  body2 is None:
            body2 = None # default
        assertValidSFNode(body2)
        if not isinstance(body2, object):
            # print(flush=True)
            raise X3DTypeError(str(body2) + ' does not have a valid node type object')
        self.__body2 = body2
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.body1 or self.body2 or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function BallJoint.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<BallJoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.anchorPoint != (0, 0, 0):
            result += " anchorPoint='" + SFVec3f(self.anchorPoint).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.forceOutput != ["NONE"]:
            result += " forceOutput='" + MFString(self.forceOutput).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></BallJoint>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.body1: # output this SFNode
                result += self.body1.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.body2: # output this SFNode
                result += self.body2.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</BallJoint>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function BallJoint.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'BallJoint' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'BallJoint' + ' {'
        if self.anchorPoint != (0, 0, 0):
            result += " anchorPoint " + SFVec3f(self.anchorPoint).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.forceOutput != ["NONE"]:
            result += " forceOutput " + MFString(self.forceOutput).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.body1: # output this SFNode
            result += '\n' + '  ' + indent + 'body1 ' + self.body1.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.body2: # output this SFNode
            result += '\n' + '  ' + indent + 'body2 ' + self.body2.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Billboard(_X3DGroupingNode):
    """
    Billboard is a Grouping node that can contain most nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Billboard'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/navigation.html#Billboard'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Billboard'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('axisOfRotation', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'Billboard'),
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 axisOfRotation=(0, 1, 0),
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 visible=True,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Billboard __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.axisOfRotation = axisOfRotation
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.visible = visible
        self.children = children
    @property # getter - - - - - - - - - -
    def axisOfRotation(self):
        """axisOfRotation direction is relative to local coordinate system."""
        return self.__axisOfRotation
    @axisOfRotation.setter
    def axisOfRotation(self, axisOfRotation):
        if  axisOfRotation is None:
            axisOfRotation = (0, 1, 0) # default
        assertValidSFVec3f(axisOfRotation)
        self.__axisOfRotation = axisOfRotation
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Billboard.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Billboard'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.axisOfRotation != (0, 1, 0):
            result += " axisOfRotation='" + SFVec3f(self.axisOfRotation).XML() + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Billboard>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* Billboard found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Billboard>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Billboard.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Billboard' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Billboard' + ' {'
        if self.axisOfRotation != (0, 1, 0):
            result += " axisOfRotation " + SFVec3f(self.axisOfRotation).VRML() + ""
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class BiquadFilter(_X3DSoundProcessingNode):
    """
    BiquadFilter node.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'BiquadFilter'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#BiquadFilter'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BiquadFilter'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('channelCountMode', 'max', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('channelInterpretation', 'speakers', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('detune', 0, FieldType.SFFloat, AccessType.inputOutput, 'BiquadFilter'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('frequency', 350, FieldType.SFFloat, AccessType.inputOutput, 'BiquadFilter'),
            ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('qualityFactor', 1, FieldType.SFFloat, AccessType.inputOutput, 'BiquadFilter'),
            ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('tailTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('type', 'lowpass', FieldType.SFString, AccessType.inputOutput, 'BiquadFilter'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 channelCountMode='max',
                 channelInterpretation='speakers',
                 description='',
                 detune=0,
                 enabled=True,
                 frequency=350,
                 gain=1,
                 pauseTime=0,
                 qualityFactor=1,
                 resumeTime=0,
                 startTime=0,
                 stopTime=0,
                 tailTime=0,
                 type='lowpass',
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode BiquadFilter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.detune = detune
        self.enabled = enabled
        self.frequency = frequency
        self.gain = gain
        self.pauseTime = pauseTime
        self.qualityFactor = qualityFactor
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.tailTime = tailTime
        self.type = type
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'max' # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'speakers' # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def detune(self):
        """(0,+infinity) The detune field forms a compound field together with playbackRate that together determine a computedPlaybackRate value."""
        return self.__detune
    @detune.setter
    def detune(self, detune):
        if  detune is None:
            detune = 0 # default
        assertValidSFFloat(detune)
        assertNonNegative('detune', detune)
        self.__detune = detune
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def frequency(self):
        """[0,+infinity) frequency at which the BiquadFilterNode operates, in Hz."""
        return self.__frequency
    @frequency.setter
    def frequency(self, frequency):
        if  frequency is None:
            frequency = 350 # default
        assertValidSFFloat(frequency)
        assertNonNegative('frequency', frequency)
        self.__frequency = frequency
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1 # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0 # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def qualityFactor(self):
        """[0,+infinity) qualityFactor is Quality Factor (Q) of the respective filter algorithm."""
        return self.__qualityFactor
    @qualityFactor.setter
    def qualityFactor(self, qualityFactor):
        if  qualityFactor is None:
            qualityFactor = 1 # default
        assertValidSFFloat(qualityFactor)
        assertNonNegative('qualityFactor', qualityFactor)
        self.__qualityFactor = qualityFactor
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0 # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0 # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0 # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def tailTime(self):
        """[0,+infinity) tailTime is duration of time that a node continues to provide output signal after the input signal becomes silent."""
        return self.__tailTime
    @tailTime.setter
    def tailTime(self, tailTime):
        if  tailTime is None:
            tailTime = 0 # default
        assertValidSFTime(tailTime)
        assertNonNegative('tailTime', tailTime)
        self.__tailTime = tailTime
    @property # getter - - - - - - - - - -
    def type(self):
        """type selects which BiquadFilter algorithm is used."""
        return self.__type
    @type.setter
    def type(self, type):
        if  type is None:
            type = 'lowpass' # default
        assertValidSFString(type)
        assertValidBiquadTypeFilter('type', type)
        self.__type = type
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function BiquadFilter.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<BiquadFilter'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.channelCountMode != 'max':
            result += " channelCountMode='" + self.channelCountMode + "'"
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation='" + self.channelInterpretation + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.detune != 0:
            result += " detune='" + SFFloat(self.detune).XML() + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.frequency != 350:
            result += " frequency='" + SFFloat(self.frequency).XML() + "'"
        if self.gain != 1:
            result += " gain='" + SFFloat(self.gain).XML() + "'"
        if self.pauseTime != 0:
            result += " pauseTime='" + SFTime(self.pauseTime).XML() + "'"
        if self.qualityFactor != 1:
            result += " qualityFactor='" + SFFloat(self.qualityFactor).XML() + "'"
        if self.resumeTime != 0:
            result += " resumeTime='" + SFTime(self.resumeTime).XML() + "'"
        if self.startTime != 0:
            result += " startTime='" + SFTime(self.startTime).XML() + "'"
        if self.stopTime != 0:
            result += " stopTime='" + SFTime(self.stopTime).XML() + "'"
        if self.tailTime != 0:
            result += " tailTime='" + SFTime(self.tailTime).XML() + "'"
        if self.type != 'lowpass':
            result += " type='" + self.type + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></BiquadFilter>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</BiquadFilter>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function BiquadFilter.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'BiquadFilter' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'BiquadFilter' + ' {'
        if self.channelCountMode != 'max':
            result += " channelCountMode " +  '"' + self.channelCountMode + '"' + ""
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation " +  '"' + self.channelInterpretation + '"' + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.detune != 0:
            result += " detune " + SFFloat(self.detune).VRML() + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.frequency != 350:
            result += " frequency " + SFFloat(self.frequency).VRML() + ""
        if self.gain != 1:
            result += " gain " + SFFloat(self.gain).VRML() + ""
        if self.pauseTime != 0:
            result += " pauseTime " + SFTime(self.pauseTime).VRML() + ""
        if self.qualityFactor != 1:
            result += " qualityFactor " + SFFloat(self.qualityFactor).VRML() + ""
        if self.resumeTime != 0:
            result += " resumeTime " + SFTime(self.resumeTime).VRML() + ""
        if self.startTime != 0:
            result += " startTime " + SFTime(self.startTime).VRML() + ""
        if self.stopTime != 0:
            result += " stopTime " + SFTime(self.stopTime).VRML() + ""
        if self.tailTime != 0:
            result += " tailTime " + SFTime(self.tailTime).VRML() + ""
        if self.type != 'lowpass':
            result += " type " +  '"' + self.type + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class BlendedVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    BlendedVolumeStyle combines rendering of two voxel data sets into one by blending voxel values.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'BlendedVolumeStyle'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/volume.html#BlendedVolumeStyle'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BlendedVolumeStyle'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
            ('weightConstant1', 0.5, FieldType.SFFloat, AccessType.inputOutput, 'BlendedVolumeStyle'),
            ('weightConstant2', 0.5, FieldType.SFFloat, AccessType.inputOutput, 'BlendedVolumeStyle'),
            ('weightFunction1', 'CONSTANT', FieldType.SFString, AccessType.inputOutput, 'BlendedVolumeStyle'),
            ('weightFunction2', 'CONSTANT', FieldType.SFString, AccessType.inputOutput, 'BlendedVolumeStyle'),
            ('renderStyle', None, FieldType.SFNode, AccessType.inputOutput, 'BlendedVolumeStyle'),
            ('voxels', None, FieldType.SFNode, AccessType.inputOutput, 'BlendedVolumeStyle'),
            ('weightTransferFunction1', None, FieldType.SFNode, AccessType.inputOutput, 'BlendedVolumeStyle'),
            ('weightTransferFunction2', None, FieldType.SFNode, AccessType.inputOutput, 'BlendedVolumeStyle'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 enabled=True,
                 weightConstant1=0.5,
                 weightConstant2=0.5,
                 weightFunction1='CONSTANT',
                 weightFunction2='CONSTANT',
                 renderStyle=None,
                 voxels=None,
                 weightTransferFunction1=None,
                 weightTransferFunction2=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode BlendedVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.weightConstant1 = weightConstant1
        self.weightConstant2 = weightConstant2
        self.weightFunction1 = weightFunction1
        self.weightFunction2 = weightFunction2
        self.renderStyle = renderStyle
        self.voxels = voxels
        self.weightTransferFunction1 = weightTransferFunction1
        self.weightTransferFunction2 = weightTransferFunction2
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def weightConstant1(self):
        """[0,1] weightConstant1 is used when weightFunction1=CONSTANT."""
        return self.__weightConstant1
    @weightConstant1.setter
    def weightConstant1(self, weightConstant1):
        if  weightConstant1 is None:
            weightConstant1 = 0.5 # default
        assertValidSFFloat(weightConstant1)
        assertZeroToOne('weightConstant1', weightConstant1)
        self.__weightConstant1 = weightConstant1
    @property # getter - - - - - - - - - -
    def weightConstant2(self):
        """[0,1] weightConstant2 is used when weightFunction2=CONSTANT."""
        return self.__weightConstant2
    @weightConstant2.setter
    def weightConstant2(self, weightConstant2):
        if  weightConstant2 is None:
            weightConstant2 = 0.5 # default
        assertValidSFFloat(weightConstant2)
        assertZeroToOne('weightConstant2', weightConstant2)
        self.__weightConstant2 = weightConstant2
    @property # getter - - - - - - - - - -
    def weightFunction1(self):
        """specifies 2D textures used to determine weight values when weight function is set to TABLE."""
        return self.__weightFunction1
    @weightFunction1.setter
    def weightFunction1(self, weightFunction1):
        if  weightFunction1 is None:
            weightFunction1 = 'CONSTANT' # default
        assertValidSFString(weightFunction1)
        assertValidVolumeRenderingWeightFunction('weightFunction1', weightFunction1)
        self.__weightFunction1 = weightFunction1
    @property # getter - - - - - - - - - -
    def weightFunction2(self):
        """specifies 2D textures used to determine weight values when weight function is set to TABLE."""
        return self.__weightFunction2
    @weightFunction2.setter
    def weightFunction2(self, weightFunction2):
        if  weightFunction2 is None:
            weightFunction2 = 'CONSTANT' # default
        assertValidSFString(weightFunction2)
        assertValidVolumeRenderingWeightFunction('weightFunction2', weightFunction2)
        self.__weightFunction2 = weightFunction2
    @property # getter - - - - - - - - - -
    def renderStyle(self):
        """[X3DComposableVolumeRenderStyleNode] Single contained X3DComposableVolumeRenderStyleNode node that defines specific rendering technique for data in the voxels field, and the result is blended with parent VolumeData or SegmentedVoliumeData node."""
        return self.__renderStyle
    @renderStyle.setter
    def renderStyle(self, renderStyle):
        if  renderStyle is None:
            renderStyle = None # default
        assertValidSFNode(renderStyle)
        if not isinstance(renderStyle, object):
            # print(flush=True)
            raise X3DTypeError(str(renderStyle) + ' does not have a valid node type object')
        self.__renderStyle = renderStyle
    @property # getter - - - - - - - - - -
    def voxels(self):
        """[X3DTexture3DNode] Single contained X3DTexture3DNode (ComposedTexture3D, ImageTexture3D, PixelTexture3D) that provides second set of raw voxel information utilized by corresponding rendering styles."""
        return self.__voxels
    @voxels.setter
    def voxels(self, voxels):
        if  voxels is None:
            voxels = None # default
        assertValidSFNode(voxels)
        if not isinstance(voxels, object):
            # print(flush=True)
            raise X3DTypeError(str(voxels) + ' does not have a valid node type object')
        self.__voxels = voxels
    @property # getter - - - - - - - - - -
    def weightTransferFunction1(self):
        return self.__weightTransferFunction1
    @weightTransferFunction1.setter
    def weightTransferFunction1(self, weightTransferFunction1):
        if  weightTransferFunction1 is None:
            weightTransferFunction1 = None # default
        assertValidSFNode(weightTransferFunction1)
        if not isinstance(weightTransferFunction1, object):
            # print(flush=True)
            raise X3DTypeError(str(weightTransferFunction1) + ' does not have a valid node type object')
        self.__weightTransferFunction1 = weightTransferFunction1
    @property # getter - - - - - - - - - -
    def weightTransferFunction2(self):
        return self.__weightTransferFunction2
    @weightTransferFunction2.setter
    def weightTransferFunction2(self, weightTransferFunction2):
        if  weightTransferFunction2 is None:
            weightTransferFunction2 = None # default
        assertValidSFNode(weightTransferFunction2)
        if not isinstance(weightTransferFunction2, object):
            # print(flush=True)
            raise X3DTypeError(str(weightTransferFunction2) + ' does not have a valid node type object')
        self.__weightTransferFunction2 = weightTransferFunction2
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.renderStyle or self.voxels or self.weightTransferFunction1 or self.weightTransferFunction2
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function BlendedVolumeStyle.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<BlendedVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.weightConstant1 != 0.5:
            result += " weightConstant1='" + SFFloat(self.weightConstant1).XML() + "'"
        if self.weightConstant2 != 0.5:
            result += " weightConstant2='" + SFFloat(self.weightConstant2).XML() + "'"
        if self.weightFunction1 != 'CONSTANT':
            result += " weightFunction1='" + self.weightFunction1 + "'"
        if self.weightFunction2 != 'CONSTANT':
            result += " weightFunction2='" + self.weightFunction2 + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></BlendedVolumeStyle>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.renderStyle: # output this SFNode
                result += self.renderStyle.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.voxels: # output this SFNode
                result += self.voxels.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.weightTransferFunction1: # output this SFNode
                result += self.weightTransferFunction1.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.weightTransferFunction2: # output this SFNode
                result += self.weightTransferFunction2.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</BlendedVolumeStyle>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function BlendedVolumeStyle.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'BlendedVolumeStyle' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'BlendedVolumeStyle' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.weightConstant1 != 0.5:
            result += " weightConstant1 " + SFFloat(self.weightConstant1).VRML() + ""
        if self.weightConstant2 != 0.5:
            result += " weightConstant2 " + SFFloat(self.weightConstant2).VRML() + ""
        if self.weightFunction1 != 'CONSTANT':
            result += " weightFunction1 " +  '"' + self.weightFunction1 + '"' + ""
        if self.weightFunction2 != 'CONSTANT':
            result += " weightFunction2 " +  '"' + self.weightFunction2 + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.renderStyle: # output this SFNode
            result += '\n' + '  ' + indent + 'renderStyle ' + self.renderStyle.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.voxels: # output this SFNode
            result += '\n' + '  ' + indent + 'voxels ' + self.voxels.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.weightTransferFunction1: # output this SFNode
            result += '\n' + '  ' + indent + 'weightTransferFunction1 ' + self.weightTransferFunction1.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.weightTransferFunction2: # output this SFNode
            result += '\n' + '  ' + indent + 'weightTransferFunction2 ' + self.weightTransferFunction2.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class BooleanFilter(_X3DChildNode):
    """
    BooleanFilter selectively passes true, false or negated events.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'BooleanFilter'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/eventUtilities.html#BooleanFilter'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BooleanFilter'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode BooleanFilter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function BooleanFilter.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<BooleanFilter'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></BooleanFilter>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</BooleanFilter>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function BooleanFilter.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'BooleanFilter' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'BooleanFilter' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class BooleanSequencer(_X3DSequencerNode):
    """
    BooleanSequencer generates periodic discrete Boolean values.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'BooleanSequencer'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/eventUtilities.html#BooleanSequencer'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BooleanSequencer'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('key', list(), FieldType.MFFloat, AccessType.inputOutput, 'X3DSequencerNode'),
            ('keyValue', list(), FieldType.MFBool, AccessType.inputOutput, 'BooleanSequencer'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode BooleanSequencer __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear sequencing, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFBool.DEFAULT_VALUE(self)
        assertValidMFBool(keyValue)
        self.__keyValue = keyValue
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function BooleanSequencer.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<BooleanSequencer'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + MFFloat(self.key).XML() + "'"
        if self.keyValue != list():
            result += " keyValue='" + MFBool(self.keyValue).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></BooleanSequencer>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</BooleanSequencer>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function BooleanSequencer.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'BooleanSequencer' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'BooleanSequencer' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.key != list():
            result += " key " + MFFloat(self.key).VRML() + ""
        if self.keyValue != list():
            result += " keyValue " + MFBool(self.keyValue).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class BooleanToggle(_X3DChildNode):
    """
    BooleanToggle maintains state and negates output when a true input is provided.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'BooleanToggle'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/eventUtilities.html#BooleanToggle'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BooleanToggle'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('toggle', False, FieldType.SFBool, AccessType.inputOutput, 'BooleanToggle'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 toggle=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode BooleanToggle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.toggle = toggle
    @property # getter - - - - - - - - - -
    def toggle(self):
        """Persistent state value that gets toggled or reset."""
        return self.__toggle
    @toggle.setter
    def toggle(self, toggle):
        if  toggle is None:
            toggle = False # default
        assertValidSFBool(toggle)
        self.__toggle = toggle
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function BooleanToggle.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<BooleanToggle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.toggle: # default=false
            result += " toggle='" + SFBool(self.toggle).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></BooleanToggle>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</BooleanToggle>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function BooleanToggle.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'BooleanToggle' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'BooleanToggle' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.toggle: # default=false
            result += " toggle " + SFBool(self.toggle).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class BooleanTrigger(_X3DTriggerNode):
    """
    BooleanTrigger converts time events to boolean true events.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'BooleanTrigger'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/eventUtilities.html#BooleanTrigger'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BooleanTrigger'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode BooleanTrigger __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function BooleanTrigger.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<BooleanTrigger'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></BooleanTrigger>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</BooleanTrigger>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function BooleanTrigger.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'BooleanTrigger' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'BooleanTrigger' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class BoundaryEnhancementVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    BoundaryEnhancementVolumeStyle provides boundary enhancement for the volume rendering style.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'BoundaryEnhancementVolumeStyle'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/volume.html#BoundaryEnhancementVolumeStyle'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BoundaryEnhancementVolumeStyle'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('boundaryOpacity', 0.9, FieldType.SFFloat, AccessType.inputOutput, 'BoundaryEnhancementVolumeStyle'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
            ('opacityFactor', 2, FieldType.SFFloat, AccessType.inputOutput, 'BoundaryEnhancementVolumeStyle'),
            ('retainedOpacity', 0.2, FieldType.SFFloat, AccessType.inputOutput, 'BoundaryEnhancementVolumeStyle'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 boundaryOpacity=0.9,
                 enabled=True,
                 opacityFactor=2,
                 retainedOpacity=0.2,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode BoundaryEnhancementVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.boundaryOpacity = boundaryOpacity
        self.enabled = enabled
        self.opacityFactor = opacityFactor
        self.retainedOpacity = retainedOpacity
    @property # getter - - - - - - - - - -
    def boundaryOpacity(self):
        """[0,+infinity) boundaryOpacity k_gs is the factored amount of the gradient enhancement to use."""
        return self.__boundaryOpacity
    @boundaryOpacity.setter
    def boundaryOpacity(self, boundaryOpacity):
        if  boundaryOpacity is None:
            boundaryOpacity = 0.9 # default
        assertValidSFFloat(boundaryOpacity)
        assertZeroToOne('boundaryOpacity', boundaryOpacity)
        self.__boundaryOpacity = boundaryOpacity
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def opacityFactor(self):
        """[0,+infinity) opacityFactor k_ge is the power function to control the slope of the opacity curve to highlight the set of data."""
        return self.__opacityFactor
    @opacityFactor.setter
    def opacityFactor(self, opacityFactor):
        if  opacityFactor is None:
            opacityFactor = 2 # default
        assertValidSFFloat(opacityFactor)
        assertNonNegative('opacityFactor', opacityFactor)
        self.__opacityFactor = opacityFactor
    @property # getter - - - - - - - - - -
    def retainedOpacity(self):
        """[0,1] retainedOpacity k_gc is the amount of initial opacity to mix into the output."""
        return self.__retainedOpacity
    @retainedOpacity.setter
    def retainedOpacity(self, retainedOpacity):
        if  retainedOpacity is None:
            retainedOpacity = 0.2 # default
        assertValidSFFloat(retainedOpacity)
        assertZeroToOne('retainedOpacity', retainedOpacity)
        self.__retainedOpacity = retainedOpacity
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function BoundaryEnhancementVolumeStyle.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<BoundaryEnhancementVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.boundaryOpacity != 0.9:
            result += " boundaryOpacity='" + SFFloat(self.boundaryOpacity).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.opacityFactor != 2:
            result += " opacityFactor='" + SFFloat(self.opacityFactor).XML() + "'"
        if self.retainedOpacity != 0.2:
            result += " retainedOpacity='" + SFFloat(self.retainedOpacity).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></BoundaryEnhancementVolumeStyle>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</BoundaryEnhancementVolumeStyle>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function BoundaryEnhancementVolumeStyle.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'BoundaryEnhancementVolumeStyle' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'BoundaryEnhancementVolumeStyle' + ' {'
        if self.boundaryOpacity != 0.9:
            result += " boundaryOpacity " + SFFloat(self.boundaryOpacity).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.opacityFactor != 2:
            result += " opacityFactor " + SFFloat(self.opacityFactor).VRML() + ""
        if self.retainedOpacity != 0.2:
            result += " retainedOpacity " + SFFloat(self.retainedOpacity).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class BoundedPhysicsModel(_X3DParticlePhysicsModelNode):
    """
    BoundedPhysicsModel provides user-defined geometrical boundaries for particle motion.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'BoundedPhysicsModel'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/particleSystems.html#BoundedPhysicsModel'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BoundedPhysicsModel'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DParticlePhysicsModelNode'),
            ('geometry', None, FieldType.SFNode, AccessType.inputOutput, 'BoundedPhysicsModel'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 enabled=True,
                 geometry=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode BoundedPhysicsModel __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.geometry = geometry
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def geometry(self):
        """[X3DGeometryNode] Single contained geometry node provides the geometry used for each particle when the parent ParticleSystem node has geometryType=GEOMETRY."""
        return self.__geometry
    @geometry.setter
    def geometry(self, geometry):
        if  geometry is None:
            geometry = None # default
        assertValidSFNode(geometry)
        if not isinstance(geometry, object):
            # print(flush=True)
            raise X3DTypeError(str(geometry) + ' does not have a valid node type object')
        self.__geometry = geometry
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.geometry or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function BoundedPhysicsModel.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<BoundedPhysicsModel'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></BoundedPhysicsModel>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.geometry: # output this SFNode
                result += self.geometry.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</BoundedPhysicsModel>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function BoundedPhysicsModel.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'BoundedPhysicsModel' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'BoundedPhysicsModel' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.geometry: # output this SFNode
            result += '\n' + '  ' + indent + 'geometry ' + self.geometry.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Box(_X3DGeometryNode):
    """
    Box is a geometry node specifying a rectangular cuboid.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Box'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geometry3D.html#Box'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Box'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('size', (2, 2, 2), FieldType.SFVec3f, AccessType.initializeOnly, 'Box'),
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'Box'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 size=(2, 2, 2),
                 solid=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Box __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.size = size
        self.solid = solid
    @property # getter - - - - - - - - - -
    def size(self):
        """(0,+infinity) size x y z in meters."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = (2, 2, 2) # default
        assertValidSFVec3f(size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Box.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Box'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.size != (2, 2, 2):
            result += " size='" + SFVec3f(self.size).XML() + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Box>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Box>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Box.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Box' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Box' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.size != (2, 2, 2):
            result += " size " + SFVec3f(self.size).VRML() + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class BufferAudioSource(_X3DSoundSourceNode):
    """
    BufferAudioSource node represents a memory-resident audio asset that can contain one or more channels.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'BufferAudioSource'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#BufferAudioSource'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#BufferAudioSource'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('buffer', list(), FieldType.MFFloat, AccessType.inputOutput, 'BufferAudioSource'),
            ('bufferDuration', 0, FieldType.SFTime, AccessType.inputOutput, 'BufferAudioSource'),
            ('channelCountMode', 'max', FieldType.SFString, AccessType.inputOutput, 'BufferAudioSource'),
            ('channelInterpretation', 'speakers', FieldType.SFString, AccessType.inputOutput, 'BufferAudioSource'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('detune', 0, FieldType.SFFloat, AccessType.inputOutput, 'BufferAudioSource'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundSourceNode'),
            ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundSourceNode'),
            ('loop', False, FieldType.SFBool, AccessType.inputOutput, 'BufferAudioSource'),
            ('loopEnd', 0, FieldType.SFFloat, AccessType.inputOutput, 'BufferAudioSource'),
            ('loopStart', 0, FieldType.SFFloat, AccessType.inputOutput, 'BufferAudioSource'),
            ('numberOfChannels', 0, FieldType.SFInt32, AccessType.inputOutput, 'BufferAudioSource'),
            ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('playbackRate', 1, FieldType.SFFloat, AccessType.inputOutput, 'BufferAudioSource'),
            ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('sampleRate', 0, FieldType.SFFloat, AccessType.inputOutput, 'BufferAudioSource'),
            ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 buffer=list(),
                 bufferDuration=0,
                 channelCountMode='max',
                 channelInterpretation='speakers',
                 description='',
                 detune=0,
                 enabled=True,
                 gain=1,
                 loop=False,
                 loopEnd=0,
                 loopStart=0,
                 numberOfChannels=0,
                 pauseTime=0,
                 playbackRate=1,
                 resumeTime=0,
                 sampleRate=0,
                 startTime=0,
                 stopTime=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode BufferAudioSource __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.buffer = buffer
        self.bufferDuration = bufferDuration
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.detune = detune
        self.enabled = enabled
        self.gain = gain
        self.loop = loop
        self.loopEnd = loopEnd
        self.loopStart = loopStart
        self.numberOfChannels = numberOfChannels
        self.pauseTime = pauseTime
        self.playbackRate = playbackRate
        self.resumeTime = resumeTime
        self.sampleRate = sampleRate
        self.startTime = startTime
        self.stopTime = stopTime
    @property # getter - - - - - - - - - -
    def buffer(self):
        """buffer is a memory-resident audio asset that can contain one or more channels."""
        return self.__buffer
    @buffer.setter
    def buffer(self, buffer):
        if  buffer is None:
            buffer = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(buffer)
        assertGreaterThanEquals('buffer', buffer, -1)
        assertLessThanEquals('buffer', buffer, 1)
        self.__buffer = buffer
    @property # getter - - - - - - - - - -
    def bufferDuration(self):
        """[0,+infinity) bufferDuration is duration in seconds to use from buffer field."""
        return self.__bufferDuration
    @bufferDuration.setter
    def bufferDuration(self, bufferDuration):
        if  bufferDuration is None:
            bufferDuration = 0 # default
        assertValidSFTime(bufferDuration)
        assertNonNegative('bufferDuration', bufferDuration)
        self.__bufferDuration = bufferDuration
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'max' # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'speakers' # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def detune(self):
        """(0,+infinity) The detune field forms a compound field together with playbackRate that together determine a computedPlaybackRate value."""
        return self.__detune
    @detune.setter
    def detune(self, detune):
        if  detune is None:
            detune = 0 # default
        assertValidSFFloat(detune)
        assertNonNegative('detune', detune)
        self.__detune = detune
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1 # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def loop(self):
        """Repeat indefinitely when loop=true, repeat only once when loop=false."""
        return self.__loop
    @loop.setter
    def loop(self, loop):
        if  loop is None:
            loop = False # default
        assertValidSFBool(loop)
        self.__loop = loop
    @property # getter - - - - - - - - - -
    def loopEnd(self):
        """[0,+infinity) loopEnd field is optional playhead position where looping ends if loop=true."""
        return self.__loopEnd
    @loopEnd.setter
    def loopEnd(self, loopEnd):
        if  loopEnd is None:
            loopEnd = 0 # default
        assertValidSFFloat(loopEnd)
        assertNonNegative('loopEnd', loopEnd)
        self.__loopEnd = loopEnd
    @property # getter - - - - - - - - - -
    def loopStart(self):
        """[0,+infinity) loopStart field is optional playhead position where looping begins if loop=true."""
        return self.__loopStart
    @loopStart.setter
    def loopStart(self, loopStart):
        if  loopStart is None:
            loopStart = 0 # default
        assertValidSFFloat(loopStart)
        assertNonNegative('loopStart', loopStart)
        self.__loopStart = loopStart
    @property # getter - - - - - - - - - -
    def numberOfChannels(self):
        """[0,+infinity) numberOfChannels is number of audio channels found in this buffer source."""
        return self.__numberOfChannels
    @numberOfChannels.setter
    def numberOfChannels(self, numberOfChannels):
        if  numberOfChannels is None:
            numberOfChannels = 0 # default
        assertValidSFInt32(numberOfChannels)
        assertNonNegative('numberOfChannels', numberOfChannels)
        self.__numberOfChannels = numberOfChannels
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0 # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def playbackRate(self):
        """(-infinity,+infinity) playbackRate field is speed at which to render the audio stream, and forms a compound field together with detune field Hint: negative values play in reverse."""
        return self.__playbackRate
    @playbackRate.setter
    def playbackRate(self, playbackRate):
        if  playbackRate is None:
            playbackRate = 1 # default
        assertValidSFFloat(playbackRate)
        self.__playbackRate = playbackRate
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0 # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def sampleRate(self):
        """(-infinity,+infinity) sampleRate field is sample-frames per second."""
        return self.__sampleRate
    @sampleRate.setter
    def sampleRate(self, sampleRate):
        if  sampleRate is None:
            sampleRate = 0 # default
        assertValidSFFloat(sampleRate)
        assertNonNegative('sampleRate', sampleRate)
        self.__sampleRate = sampleRate
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0 # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0 # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function BufferAudioSource.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<BufferAudioSource'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.buffer != list():
            result += " buffer='" + MFFloat(self.buffer).XML() + "'"
        if self.bufferDuration != 0:
            result += " bufferDuration='" + SFTime(self.bufferDuration).XML() + "'"
        if self.channelCountMode != 'max':
            result += " channelCountMode='" + self.channelCountMode + "'"
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation='" + self.channelInterpretation + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.detune != 0:
            result += " detune='" + SFFloat(self.detune).XML() + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.gain != 1:
            result += " gain='" + SFFloat(self.gain).XML() + "'"
        if self.loop: # default=false
            result += " loop='" + SFBool(self.loop).XML() + "'"
        if self.loopEnd != 0:
            result += " loopEnd='" + SFFloat(self.loopEnd).XML() + "'"
        if self.loopStart != 0:
            result += " loopStart='" + SFFloat(self.loopStart).XML() + "'"
        if self.numberOfChannels != 0:
            result += " numberOfChannels='" + SFInt32(self.numberOfChannels).XML() + "'"
        if self.pauseTime != 0:
            result += " pauseTime='" + SFTime(self.pauseTime).XML() + "'"
        if self.playbackRate != 1:
            result += " playbackRate='" + SFFloat(self.playbackRate).XML() + "'"
        if self.resumeTime != 0:
            result += " resumeTime='" + SFTime(self.resumeTime).XML() + "'"
        if self.sampleRate != 0:
            result += " sampleRate='" + SFFloat(self.sampleRate).XML() + "'"
        if self.startTime != 0:
            result += " startTime='" + SFTime(self.startTime).XML() + "'"
        if self.stopTime != 0:
            result += " stopTime='" + SFTime(self.stopTime).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></BufferAudioSource>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</BufferAudioSource>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function BufferAudioSource.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'BufferAudioSource' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'BufferAudioSource' + ' {'
        if self.buffer != list():
            result += " buffer " + MFFloat(self.buffer).VRML() + ""
        if self.bufferDuration != 0:
            result += " bufferDuration " + SFTime(self.bufferDuration).VRML() + ""
        if self.channelCountMode != 'max':
            result += " channelCountMode " +  '"' + self.channelCountMode + '"' + ""
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation " +  '"' + self.channelInterpretation + '"' + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.detune != 0:
            result += " detune " + SFFloat(self.detune).VRML() + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.gain != 1:
            result += " gain " + SFFloat(self.gain).VRML() + ""
        if self.loop: # default=false
            result += " loop " + SFBool(self.loop).VRML() + ""
        if self.loopEnd != 0:
            result += " loopEnd " + SFFloat(self.loopEnd).VRML() + ""
        if self.loopStart != 0:
            result += " loopStart " + SFFloat(self.loopStart).VRML() + ""
        if self.numberOfChannels != 0:
            result += " numberOfChannels " + SFInt32(self.numberOfChannels).VRML() + ""
        if self.pauseTime != 0:
            result += " pauseTime " + SFTime(self.pauseTime).VRML() + ""
        if self.playbackRate != 1:
            result += " playbackRate " + SFFloat(self.playbackRate).VRML() + ""
        if self.resumeTime != 0:
            result += " resumeTime " + SFTime(self.resumeTime).VRML() + ""
        if self.sampleRate != 0:
            result += " sampleRate " + SFFloat(self.sampleRate).VRML() + ""
        if self.startTime != 0:
            result += " startTime " + SFTime(self.startTime).VRML() + ""
        if self.stopTime != 0:
            result += " stopTime " + SFTime(self.stopTime).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class CADAssembly(_X3DGroupingNode, _X3DProductStructureChildNode):
    """
    CADAssembly holds a set of Computer-Aided Design (CAD) assemblies or parts grouped together.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'CADAssembly'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/CADGeometry.html#CADAssembly'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CADAssembly'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DProductStructureChildNode'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 name='',
                 visible=True,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CADAssembly __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.name = name
        self.visible = visible
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def name(self):
        """Optional name for this particular CAD node."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function CADAssembly.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<CADAssembly'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></CADAssembly>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* CADAssembly found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</CADAssembly>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function CADAssembly.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'CADAssembly' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'CADAssembly' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class CADFace(_X3DProductStructureChildNode, _X3DBoundedObject):
    """
    CADFace holds geometry representing one face in a Computer-Aided Design (CAD) CADPart.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'CADFace'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/CADGeometry.html#CADFace'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CADFace'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DProductStructureChildNode'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('shape', None, FieldType.SFNode, AccessType.inputOutput, 'CADFace'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 name='',
                 visible=True,
                 shape=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CADFace __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.name = name
        self.visible = visible
        self.shape = shape
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def name(self):
        """Optional name for this particular CAD node."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def shape(self):
        """[X3DShapeNode|LOD|Transform] Contained Shape for this CADPart."""
        return self.__shape
    @shape.setter
    def shape(self, shape):
        if  shape is None:
            shape = None # default
        assertValidSFNode(shape)
        if not isinstance(shape, object):
            # print(flush=True)
            raise X3DTypeError(str(shape) + ' does not have a valid node type object')
        self.__shape = shape
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.shape
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function CADFace.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<CADFace'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></CADFace>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.shape: # output this SFNode
                result += self.shape.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</CADFace>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function CADFace.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'CADFace' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'CADFace' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.shape: # output this SFNode
            result += '\n' + '  ' + indent + 'shape ' + self.shape.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class CADLayer(_X3DGroupingNode):
    """
    CADLayer nodes define a hierarchy that shows layer structure for a Computer-Aided Design (CAD) model.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'CADLayer'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/CADGeometry.html#CADLayer'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CADLayer'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'CADLayer'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 name='',
                 visible=True,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CADLayer __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.name = name
        self.visible = visible
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def name(self):
        """Optional name for this particular CAD node."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function CADLayer.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<CADLayer'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></CADLayer>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* CADLayer found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</CADLayer>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function CADLayer.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'CADLayer' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'CADLayer' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class CADPart(_X3DProductStructureChildNode, _X3DGroupingNode):
    """
    CADPart is an atomic part that defines both coordinate-system location and the faces that constitute a part in a Computer-Aided Design (CAD) model.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'CADPart'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/CADGeometry.html#CADPart'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CADPart'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'CADPart'),
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DProductStructureChildNode'),
            ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'CADPart'),
            ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'CADPart'),
            ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'CADPart'),
            ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'CADPart'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'CADPart'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 center=(0, 0, 0),
                 name='',
                 rotation=(0, 0, 1, 0),
                 scale=(1, 1, 1),
                 scaleOrientation=(0, 0, 1, 0),
                 translation=(0, 0, 0),
                 visible=True,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CADPart __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.center = center
        self.name = name
        self.rotation = rotation
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.translation = translation
        self.visible = visible
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        """Translation offset from origin of local coordinate system, applied prior to rotation or scaling."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0) # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def name(self):
        """Optional name for this particular CAD node."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def rotation(self):
        """Orientation (axis, angle in radians) of children relative to local coordinate system."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0) # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        """Non-uniform x-y-z scale of child coordinate system, adjusted by center and scaleOrientation."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = (1, 1, 1) # default
        assertValidSFVec3f(scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        """Preliminary rotation of coordinate system before scaling (to allow scaling around arbitrary orientations)."""
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation):
        if  scaleOrientation is None:
            scaleOrientation = (0, 0, 1, 0) # default
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def translation(self):
        """Position (x, y, z in meters) of children relative to local coordinate system."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0) # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function CADPart.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<CADPart'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.center != (0, 0, 0):
            result += " center='" + SFVec3f(self.center).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + SFRotation(self.rotation).XML() + "'"
        if self.scale != (1, 1, 1):
            result += " scale='" + SFVec3f(self.scale).XML() + "'"
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation='" + SFRotation(self.scaleOrientation).XML() + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + SFVec3f(self.translation).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></CADPart>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* CADPart found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</CADPart>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function CADPart.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'CADPart' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'CADPart' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.center != (0, 0, 0):
            result += " center " + SFVec3f(self.center).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if self.rotation != (0, 0, 1, 0):
            result += " rotation " + SFRotation(self.rotation).VRML() + ""
        if self.scale != (1, 1, 1):
            result += " scale " + SFVec3f(self.scale).VRML() + ""
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation " + SFRotation(self.scaleOrientation).VRML() + ""
        if self.translation != (0, 0, 0):
            result += " translation " + SFVec3f(self.translation).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class CartoonVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    CartoonVolumeStyle generates cartoon-style non-photorealistic rendering of associated volumetric data.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'CartoonVolumeStyle'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/volume.html#CartoonVolumeStyle'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CartoonVolumeStyle'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('colorSteps', 4, FieldType.SFInt32, AccessType.inputOutput, 'CartoonVolumeStyle'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
            ('orthogonalColor', (1, 1, 1, 1), FieldType.SFColorRGBA, AccessType.inputOutput, 'CartoonVolumeStyle'),
            ('parallelColor', (0, 0, 0, 1), FieldType.SFColorRGBA, AccessType.inputOutput, 'CartoonVolumeStyle'),
            ('surfaceNormals', None, FieldType.SFNode, AccessType.inputOutput, 'CartoonVolumeStyle'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 colorSteps=4,
                 enabled=True,
                 orthogonalColor=(1, 1, 1, 1),
                 parallelColor=(0, 0, 0, 1),
                 surfaceNormals=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CartoonVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.colorSteps = colorSteps
        self.enabled = enabled
        self.orthogonalColor = orthogonalColor
        self.parallelColor = parallelColor
        self.surfaceNormals = surfaceNormals
    @property # getter - - - - - - - - - -
    def colorSteps(self):
        """[1,64] Number of distinct colors taken from interpolated colors and used to render the object."""
        return self.__colorSteps
    @colorSteps.setter
    def colorSteps(self, colorSteps):
        if  colorSteps is None:
            colorSteps = 4 # default
        assertValidSFInt32(colorSteps)
        assertGreaterThanEquals('colorSteps', colorSteps, 1)
        assertLessThanEquals('colorSteps', colorSteps, 64)
        self.__colorSteps = colorSteps
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def orthogonalColor(self):
        """[0,1] orthogonalColor is used for surface normals that are orthogonal (perpendicular) to viewer's current location."""
        return self.__orthogonalColor
    @orthogonalColor.setter
    def orthogonalColor(self, orthogonalColor):
        if  orthogonalColor is None:
            orthogonalColor = (1, 1, 1, 1) # default
        assertValidSFColorRGBA(orthogonalColor)
        assertZeroToOne('orthogonalColor', orthogonalColor)
        self.__orthogonalColor = orthogonalColor
    @property # getter - - - - - - - - - -
    def parallelColor(self):
        """[0,1] parallelColor is used for surface normals that are orthogonal to viewer's current location."""
        return self.__parallelColor
    @parallelColor.setter
    def parallelColor(self, parallelColor):
        if  parallelColor is None:
            parallelColor = (0, 0, 0, 1) # default
        assertValidSFColorRGBA(parallelColor)
        assertZeroToOne('parallelColor', parallelColor)
        self.__parallelColor = parallelColor
    @property # getter - - - - - - - - - -
    def surfaceNormals(self):
        return self.__surfaceNormals
    @surfaceNormals.setter
    def surfaceNormals(self, surfaceNormals):
        if  surfaceNormals is None:
            surfaceNormals = None # default
        assertValidSFNode(surfaceNormals)
        if not isinstance(surfaceNormals, object):
            # print(flush=True)
            raise X3DTypeError(str(surfaceNormals) + ' does not have a valid node type object')
        self.__surfaceNormals = surfaceNormals
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.surfaceNormals
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function CartoonVolumeStyle.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<CartoonVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.colorSteps != 4:
            result += " colorSteps='" + SFInt32(self.colorSteps).XML() + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.orthogonalColor != (1, 1, 1, 1):
            result += " orthogonalColor='" + SFColorRGBA(self.orthogonalColor).XML() + "'"
        if self.parallelColor != (0, 0, 0, 1):
            result += " parallelColor='" + SFColorRGBA(self.parallelColor).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></CartoonVolumeStyle>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.surfaceNormals: # output this SFNode
                result += self.surfaceNormals.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</CartoonVolumeStyle>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function CartoonVolumeStyle.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'CartoonVolumeStyle' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'CartoonVolumeStyle' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.colorSteps != 4:
            result += " colorSteps " + SFInt32(self.colorSteps).VRML() + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.orthogonalColor != (1, 1, 1, 1):
            result += " orthogonalColor " + SFColorRGBA(self.orthogonalColor).VRML() + ""
        if self.parallelColor != (0, 0, 0, 1):
            result += " parallelColor " + SFColorRGBA(self.parallelColor).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.surfaceNormals: # output this SFNode
            result += '\n' + '  ' + indent + 'surfaceNormals ' + self.surfaceNormals.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ChannelMerger(_X3DSoundChannelNode):
    """
    ChannelMerger unites different input channels into a single output channel.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ChannelMerger'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#ChannelMerger'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ChannelMerger'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('channelCountMode', 'max', FieldType.SFString, AccessType.inputOutput, 'X3DSoundChannelNode'),
            ('channelInterpretation', 'speakers', FieldType.SFString, AccessType.inputOutput, 'X3DSoundChannelNode'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSoundNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundNode'),
            ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundChannelNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 channelCountMode='max',
                 channelInterpretation='speakers',
                 description='',
                 enabled=True,
                 gain=1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ChannelMerger __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.gain = gain
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'max' # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'speakers' # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1 # default
        assertValidSFFloat(gain)
        self.__gain = gain
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ChannelMerger.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ChannelMerger'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.channelCountMode != 'max':
            result += " channelCountMode='" + self.channelCountMode + "'"
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation='" + self.channelInterpretation + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.gain != 1:
            result += " gain='" + SFFloat(self.gain).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ChannelMerger>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ChannelMerger>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ChannelMerger.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ChannelMerger' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ChannelMerger' + ' {'
        if self.channelCountMode != 'max':
            result += " channelCountMode " +  '"' + self.channelCountMode + '"' + ""
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation " +  '"' + self.channelInterpretation + '"' + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.gain != 1:
            result += " gain " + SFFloat(self.gain).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ChannelSelector(_X3DSoundChannelNode):
    """
    ChannelSelector selects a single channel output from all input channels.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ChannelSelector'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#ChannelSelector'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ChannelSelector'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('channelCountMode', 'max', FieldType.SFString, AccessType.inputOutput, 'X3DSoundChannelNode'),
            ('channelInterpretation', 'speakers', FieldType.SFString, AccessType.inputOutput, 'X3DSoundChannelNode'),
            ('channelSelection', 0, FieldType.SFInt32, AccessType.inputOutput, 'ChannelSelector'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSoundNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundNode'),
            ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundChannelNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 channelCountMode='max',
                 channelInterpretation='speakers',
                 channelSelection=0,
                 description='',
                 enabled=True,
                 gain=1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ChannelSelector __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.channelSelection = channelSelection
        self.description = description
        self.enabled = enabled
        self.gain = gain
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'max' # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'speakers' # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def channelSelection(self):
        """[0,+infinity) channelSelection is single channel of interest from those provided by input nodes."""
        return self.__channelSelection
    @channelSelection.setter
    def channelSelection(self, channelSelection):
        if  channelSelection is None:
            channelSelection = 0 # default
        assertValidSFInt32(channelSelection)
        assertNonNegative('channelSelection', channelSelection)
        self.__channelSelection = channelSelection
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1 # default
        assertValidSFFloat(gain)
        self.__gain = gain
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ChannelSelector.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ChannelSelector'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.channelCountMode != 'max':
            result += " channelCountMode='" + self.channelCountMode + "'"
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation='" + self.channelInterpretation + "'"
        if self.channelSelection != 0:
            result += " channelSelection='" + SFInt32(self.channelSelection).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.gain != 1:
            result += " gain='" + SFFloat(self.gain).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ChannelSelector>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ChannelSelector>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ChannelSelector.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ChannelSelector' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ChannelSelector' + ' {'
        if self.channelCountMode != 'max':
            result += " channelCountMode " +  '"' + self.channelCountMode + '"' + ""
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation " +  '"' + self.channelInterpretation + '"' + ""
        if self.channelSelection != 0:
            result += " channelSelection " + SFInt32(self.channelSelection).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.gain != 1:
            result += " gain " + SFFloat(self.gain).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ChannelSplitter(_X3DSoundChannelNode):
    """
    ChannelSplitter separates the different channels of a single audio source into a set of monophonic output channels.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ChannelSplitter'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#ChannelSplitter'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ChannelSplitter'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('channelCountMode', 'max', FieldType.SFString, AccessType.inputOutput, 'X3DSoundChannelNode'),
            ('channelInterpretation', 'speakers', FieldType.SFString, AccessType.inputOutput, 'X3DSoundChannelNode'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSoundNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundNode'),
            ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundChannelNode'),
            ('outputs', list(), FieldType.MFNode, AccessType.inputOutput, 'ChannelSplitter'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 channelCountMode='max',
                 channelInterpretation='speakers',
                 description='',
                 enabled=True,
                 gain=1,
                 outputs=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ChannelSplitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.outputs = outputs
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'max' # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'speakers' # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1 # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def outputs(self):
        """[X3DSoundChannelNode|X3DSoundProcessingNode|X3DSoundSourceNode] The outputs field is a set of output nodes receiving the split channels, and making up a section of the audio graph."""
        return self.__outputs
    @outputs.setter
    def outputs(self, outputs):
        if  outputs is None:
            outputs = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(outputs)
        self.__outputs = outputs
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.outputs or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ChannelSplitter.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ChannelSplitter'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.channelCountMode != 'max':
            result += " channelCountMode='" + self.channelCountMode + "'"
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation='" + self.channelInterpretation + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.gain != 1:
            result += " gain='" + SFFloat(self.gain).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ChannelSplitter>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.outputs: # walk each child in MFNode list, if any
            ### print('* ChannelSplitter found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(outputs)=' + str(len(self.outputs)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.outputs:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ChannelSplitter>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ChannelSplitter.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ChannelSplitter' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ChannelSplitter' + ' {'
        if self.channelCountMode != 'max':
            result += " channelCountMode " +  '"' + self.channelCountMode + '"' + ""
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation " +  '"' + self.channelInterpretation + '"' + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.gain != 1:
            result += " gain " + SFFloat(self.gain).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.outputs: # walk each child in MFNode list, if any
            for each in self.outputs:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Circle2D(_X3DGeometryNode):
    """
    Circle2D is a geometry node that defines a linear X-Y circle with center (0,0) in X-Y plane.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Circle2D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geometry2D.html#Circle2D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Circle2D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('radius', 1, FieldType.SFFloat, AccessType.initializeOnly, 'Circle2D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 radius=1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Circle2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.radius = radius
    @property # getter - - - - - - - - - -
    def radius(self):
        """(0,+infinity) circle radius."""
        return self.__radius
    @radius.setter
    def radius(self, radius):
        if  radius is None:
            radius = 1 # default
        assertValidSFFloat(radius)
        assertPositive('radius', radius)
        self.__radius = radius
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Circle2D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Circle2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.radius != 1:
            result += " radius='" + SFFloat(self.radius).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Circle2D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Circle2D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Circle2D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Circle2D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Circle2D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.radius != 1:
            result += " radius " + SFFloat(self.radius).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ClipPlane(_X3DChildNode):
    """
    ClipPlane specifies a single plane equation used to clip (i.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ClipPlane'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#ClipPlane'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ClipPlane'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'ClipPlane'),
            ('plane', (0, 1, 0, 0), FieldType.SFVec4f, AccessType.inputOutput, 'ClipPlane'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 enabled=True,
                 plane=(0, 1, 0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ClipPlane __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.plane = plane
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def plane(self):
        """[0,1] If (a,b,c,d) is the plane, with the first three components being a normalized vector describing the plane's normal direction (and thus the fourth component d being distance from the origin), a point (x,y,z) is visible to the user, with regards to the clipping plane, if a*x+b*y+c*z+d is greater than 0."""
        return self.__plane
    @plane.setter
    def plane(self, plane):
        if  plane is None:
            plane = (0, 1, 0, 0) # default
        assertValidSFVec4f(plane)
        assertGreaterThanEquals('plane', plane, -1)
        assertLessThanEquals('plane', plane, 1)
        self.__plane = plane
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ClipPlane.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ClipPlane'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.plane != (0, 1, 0, 0):
            result += " plane='" + SFVec4f(self.plane).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ClipPlane>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ClipPlane>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ClipPlane.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ClipPlane' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ClipPlane' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.plane != (0, 1, 0, 0):
            result += " plane " + SFVec4f(self.plane).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class CollidableOffset(_X3DNBodyCollidableNode):
    """
    CollidableOffset repositions geometry relative to center of owning body.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'CollidableOffset'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rigidBodyPhysics.html#CollidableOffset'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CollidableOffset'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DNBodyCollidableNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DNBodyCollidableNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
            ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
            ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
            ('collidable', None, FieldType.SFNode, AccessType.initializeOnly, 'CollidableOffset'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 enabled=True,
                 rotation=(0, 0, 1, 0),
                 translation=(0, 0, 0),
                 visible=True,
                 collidable=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CollidableOffset __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.enabled = enabled
        self.rotation = rotation
        self.translation = translation
        self.visible = visible
        self.collidable = collidable
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def rotation(self):
        """Orientation (axis, angle in radians) of children relative to local coordinate system."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0) # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def translation(self):
        """Position (x, y, z in meters) of children relative to local coordinate system."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0) # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def collidable(self):
        return self.__collidable
    @collidable.setter
    def collidable(self, collidable):
        if  collidable is None:
            collidable = None # default
        assertValidSFNode(collidable)
        if not isinstance(collidable, object):
            # print(flush=True)
            raise X3DTypeError(str(collidable) + ' does not have a valid node type object')
        self.__collidable = collidable
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.collidable or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function CollidableOffset.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<CollidableOffset'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + SFRotation(self.rotation).XML() + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + SFVec3f(self.translation).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></CollidableOffset>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.collidable: # output this SFNode
                result += self.collidable.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</CollidableOffset>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function CollidableOffset.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'CollidableOffset' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'CollidableOffset' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.rotation != (0, 0, 1, 0):
            result += " rotation " + SFRotation(self.rotation).VRML() + ""
        if self.translation != (0, 0, 0):
            result += " translation " + SFVec3f(self.translation).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.collidable: # output this SFNode
            result += '\n' + '  ' + indent + 'collidable ' + self.collidable.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class CollidableShape(_X3DNBodyCollidableNode):
    """
    CollidableShape connects the collision detection system, the rigid body model, and the renderable scene graph.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'CollidableShape'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rigidBodyPhysics.html#CollidableShape'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CollidableShape'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DNBodyCollidableNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DNBodyCollidableNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
            ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
            ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DNBodyCollidableNode'),
            ('shape', None, FieldType.SFNode, AccessType.initializeOnly, 'CollidableShape'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 enabled=True,
                 rotation=(0, 0, 1, 0),
                 translation=(0, 0, 0),
                 visible=True,
                 shape=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CollidableShape __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.enabled = enabled
        self.rotation = rotation
        self.translation = translation
        self.visible = visible
        self.shape = shape
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def rotation(self):
        """Orientation (axis, angle in radians) of children relative to local coordinate system."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0) # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def translation(self):
        """Position (x, y, z in meters) of children relative to local coordinate system."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0) # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def shape(self):
        return self.__shape
    @shape.setter
    def shape(self, shape):
        if  shape is None:
            shape = None # default
        assertValidSFNode(shape)
        if not isinstance(shape, object):
            # print(flush=True)
            raise X3DTypeError(str(shape) + ' does not have a valid node type object')
        self.__shape = shape
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.shape
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function CollidableShape.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<CollidableShape'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + SFRotation(self.rotation).XML() + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + SFVec3f(self.translation).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></CollidableShape>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.shape: # output this SFNode
                result += self.shape.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</CollidableShape>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function CollidableShape.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'CollidableShape' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'CollidableShape' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.rotation != (0, 0, 1, 0):
            result += " rotation " + SFRotation(self.rotation).VRML() + ""
        if self.translation != (0, 0, 0):
            result += " translation " + SFVec3f(self.translation).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.shape: # output this SFNode
            result += '\n' + '  ' + indent + 'shape ' + self.shape.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Collision(_X3DGroupingNode, _X3DSensorNode):
    """
    Collision detects camera-to-object contact using current view and NavigationInfo avatarSize.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Collision'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/navigation.html#Collision'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Collision'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('proxy', None, FieldType.SFNode, AccessType.initializeOnly, 'Collision'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 enabled=True,
                 visible=True,
                 proxy=None,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Collision __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.enabled = enabled
        self.visible = visible
        self.proxy = proxy
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables collision detection for children and all descendants."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def proxy(self):
        """[X3DChildNode] The proxy node is used as a substitute for Collision children during collision detection, simplifying collision-intersection computations."""
        return self.__proxy
    @proxy.setter
    def proxy(self, proxy):
        if  proxy is None:
            proxy = None # default
        assertValidSFNode(proxy)
        if not isinstance(proxy, object):
            # print(flush=True)
            raise X3DTypeError(str(proxy) + ' does not have a valid node type object')
        self.__proxy = proxy
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.metadata or self.proxy
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Collision.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Collision'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Collision>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.proxy: # output this SFNode
                result += self.proxy.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* Collision found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Collision>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Collision.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Collision' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Collision' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.proxy: # output this SFNode
            result += '\n' + '  ' + indent + 'proxy ' + self.proxy.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class CollisionCollection(_X3DChildNode, _X3DBoundedObject):
    """
    CollisionCollection holds a collection of objects that can be managed as a single entity for resolution of inter-object collisions.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'CollisionCollection'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rigidBodyPhysics.html#CollisionCollection'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CollisionCollection'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('appliedParameters', ["BOUNCE"], FieldType.MFString, AccessType.inputOutput, 'CollisionCollection'),
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('bounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'CollisionCollection'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'CollisionCollection'),
            ('frictionCoefficients', (0, 0), FieldType.SFVec2f, AccessType.inputOutput, 'CollisionCollection'),
            ('minBounceSpeed', 0.1, FieldType.SFFloat, AccessType.inputOutput, 'CollisionCollection'),
            ('slipFactors', (0, 0), FieldType.SFVec2f, AccessType.inputOutput, 'CollisionCollection'),
            ('softnessConstantForceMix', 0.0001, FieldType.SFFloat, AccessType.inputOutput, 'CollisionCollection'),
            ('softnessErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'CollisionCollection'),
            ('surfaceSpeed', (0, 0), FieldType.SFVec2f, AccessType.inputOutput, 'CollisionCollection'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('collidables', list(), FieldType.MFNode, AccessType.inputOutput, 'CollisionCollection'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 appliedParameters=["BOUNCE"],
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 bounce=0,
                 enabled=True,
                 frictionCoefficients=(0, 0),
                 minBounceSpeed=0.1,
                 slipFactors=(0, 0),
                 softnessConstantForceMix=0.0001,
                 softnessErrorCorrection=0.8,
                 surfaceSpeed=(0, 0),
                 visible=True,
                 collidables=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CollisionCollection __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.appliedParameters = appliedParameters
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.bounce = bounce
        self.enabled = enabled
        self.frictionCoefficients = frictionCoefficients
        self.minBounceSpeed = minBounceSpeed
        self.slipFactors = slipFactors
        self.softnessConstantForceMix = softnessConstantForceMix
        self.softnessErrorCorrection = softnessErrorCorrection
        self.surfaceSpeed = surfaceSpeed
        self.visible = visible
        self.collidables = collidables
    @property # getter - - - - - - - - - -
    def appliedParameters(self):
        """Default global parameters for collision outputs of rigid body physics system."""
        return self.__appliedParameters
    @appliedParameters.setter
    def appliedParameters(self, appliedParameters):
        if  appliedParameters is None:
            appliedParameters = ["BOUNCE"] # default
        assertValidMFString(appliedParameters)
        assertValidAppliedParameters('appliedParameters', appliedParameters)
        self.__appliedParameters = appliedParameters
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def bounce(self):
        """[0,1] bounce indicates bounciness (0 = no bounce at all, 1 = maximum bounce)."""
        return self.__bounce
    @bounce.setter
    def bounce(self, bounce):
        if  bounce is None:
            bounce = 0 # default
        assertValidSFFloat(bounce)
        assertZeroToOne('bounce', bounce)
        self.__bounce = bounce
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def frictionCoefficients(self):
        """frictionCoefficients used for computing surface drag."""
        return self.__frictionCoefficients
    @frictionCoefficients.setter
    def frictionCoefficients(self, frictionCoefficients):
        if  frictionCoefficients is None:
            frictionCoefficients = (0, 0) # default
        assertValidSFVec2f(frictionCoefficients)
        assertNonNegative('frictionCoefficients', frictionCoefficients)
        self.__frictionCoefficients = frictionCoefficients
    @property # getter - - - - - - - - - -
    def minBounceSpeed(self):
        """[0,+infinity) minBounceSpeed m/s needed to bounce."""
        return self.__minBounceSpeed
    @minBounceSpeed.setter
    def minBounceSpeed(self, minBounceSpeed):
        if  minBounceSpeed is None:
            minBounceSpeed = 0.1 # default
        assertValidSFFloat(minBounceSpeed)
        assertNonNegative('minBounceSpeed', minBounceSpeed)
        self.__minBounceSpeed = minBounceSpeed
    @property # getter - - - - - - - - - -
    def slipFactors(self):
        """slipFactors used for computing surface drag."""
        return self.__slipFactors
    @slipFactors.setter
    def slipFactors(self, slipFactors):
        if  slipFactors is None:
            slipFactors = (0, 0) # default
        assertValidSFVec2f(slipFactors)
        self.__slipFactors = slipFactors
    @property # getter - - - - - - - - - -
    def softnessConstantForceMix(self):
        """[0,1] softnessConstantForceMix value applies a constant force value to make colliding surfaces appear to be somewhat soft."""
        return self.__softnessConstantForceMix
    @softnessConstantForceMix.setter
    def softnessConstantForceMix(self, softnessConstantForceMix):
        if  softnessConstantForceMix is None:
            softnessConstantForceMix = 0.0001 # default
        assertValidSFFloat(softnessConstantForceMix)
        assertZeroToOne('softnessConstantForceMix', softnessConstantForceMix)
        self.__softnessConstantForceMix = softnessConstantForceMix
    @property # getter - - - - - - - - - -
    def softnessErrorCorrection(self):
        """[0,1] softnessErrorCorrection indicates fraction of collision error fixed in a set of evaluations (0 = no error correction, 1 = all errors corrected in single step)."""
        return self.__softnessErrorCorrection
    @softnessErrorCorrection.setter
    def softnessErrorCorrection(self, softnessErrorCorrection):
        if  softnessErrorCorrection is None:
            softnessErrorCorrection = 0.8 # default
        assertValidSFFloat(softnessErrorCorrection)
        assertZeroToOne('softnessErrorCorrection', softnessErrorCorrection)
        self.__softnessErrorCorrection = softnessErrorCorrection
    @property # getter - - - - - - - - - -
    def surfaceSpeed(self):
        """surfaceSpeed defines speed vectors for computing surface drag, if contact surfaces move independently of bodies."""
        return self.__surfaceSpeed
    @surfaceSpeed.setter
    def surfaceSpeed(self, surfaceSpeed):
        if  surfaceSpeed is None:
            surfaceSpeed = (0, 0) # default
        assertValidSFVec2f(surfaceSpeed)
        self.__surfaceSpeed = surfaceSpeed
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def collidables(self):
        """[CollisionSpace|CollidableShape|CollidableOffset] CollisionCollection node holds a collection of objects in the collidables field that can be managed as a single entity for resolution of inter-object collisions with other groups of collidable objects."""
        return self.__collidables
    @collidables.setter
    def collidables(self, collidables):
        if  collidables is None:
            collidables = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(collidables)
        self.__collidables = collidables
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.collidables or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function CollisionCollection.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<CollisionCollection'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.appliedParameters != ["BOUNCE"]:
            result += " appliedParameters='" + MFString(self.appliedParameters).XML() + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.bounce != 0:
            result += " bounce='" + SFFloat(self.bounce).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.frictionCoefficients != (0, 0):
            result += " frictionCoefficients='" + SFVec2f(self.frictionCoefficients).XML() + "'"
        if self.minBounceSpeed != 0.1:
            result += " minBounceSpeed='" + SFFloat(self.minBounceSpeed).XML() + "'"
        if self.slipFactors != (0, 0):
            result += " slipFactors='" + SFVec2f(self.slipFactors).XML() + "'"
        if self.softnessConstantForceMix != 0.0001:
            result += " softnessConstantForceMix='" + SFFloat(self.softnessConstantForceMix).XML() + "'"
        if self.softnessErrorCorrection != 0.8:
            result += " softnessErrorCorrection='" + SFFloat(self.softnessErrorCorrection).XML() + "'"
        if self.surfaceSpeed != (0, 0):
            result += " surfaceSpeed='" + SFVec2f(self.surfaceSpeed).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></CollisionCollection>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.collidables: # walk each child in MFNode list, if any
            ### print('* CollisionCollection found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(collidables)=' + str(len(self.collidables)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.collidables:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</CollisionCollection>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function CollisionCollection.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'CollisionCollection' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'CollisionCollection' + ' {'
        if self.appliedParameters != ["BOUNCE"]:
            result += " appliedParameters " + MFString(self.appliedParameters).VRML() + ""
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.bounce != 0:
            result += " bounce " + SFFloat(self.bounce).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.frictionCoefficients != (0, 0):
            result += " frictionCoefficients " + SFVec2f(self.frictionCoefficients).VRML() + ""
        if self.minBounceSpeed != 0.1:
            result += " minBounceSpeed " + SFFloat(self.minBounceSpeed).VRML() + ""
        if self.slipFactors != (0, 0):
            result += " slipFactors " + SFVec2f(self.slipFactors).VRML() + ""
        if self.softnessConstantForceMix != 0.0001:
            result += " softnessConstantForceMix " + SFFloat(self.softnessConstantForceMix).VRML() + ""
        if self.softnessErrorCorrection != 0.8:
            result += " softnessErrorCorrection " + SFFloat(self.softnessErrorCorrection).VRML() + ""
        if self.surfaceSpeed != (0, 0):
            result += " surfaceSpeed " + SFVec2f(self.surfaceSpeed).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.collidables: # walk each child in MFNode list, if any
            for each in self.collidables:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class CollisionSensor(_X3DSensorNode):
    """
    CollisionSensor generates collision-detection events.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'CollisionSensor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rigidBodyPhysics.html#CollisionSensor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CollisionSensor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('collider', None, FieldType.SFNode, AccessType.inputOutput, 'CollisionSensor'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 enabled=True,
                 collider=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CollisionSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.collider = collider
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def collider(self):
        return self.__collider
    @collider.setter
    def collider(self, collider):
        if  collider is None:
            collider = None # default
        assertValidSFNode(collider)
        if not isinstance(collider, object):
            # print(flush=True)
            raise X3DTypeError(str(collider) + ' does not have a valid node type object')
        self.__collider = collider
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.collider or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function CollisionSensor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<CollisionSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></CollisionSensor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.collider: # output this SFNode
                result += self.collider.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</CollisionSensor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function CollisionSensor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'CollisionSensor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'CollisionSensor' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.collider: # output this SFNode
            result += '\n' + '  ' + indent + 'collider ' + self.collider.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class CollisionSpace(_X3DNBodyCollisionSpaceNode):
    """
    CollisionSpace holds collection of objects considered together for resolution of inter-object collisions.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'CollisionSpace'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rigidBodyPhysics.html#CollisionSpace'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CollisionSpace'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DNBodyCollisionSpaceNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DNBodyCollisionSpaceNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DNBodyCollisionSpaceNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DNBodyCollisionSpaceNode'),
            ('useGeometry', False, FieldType.SFBool, AccessType.inputOutput, 'CollisionSpace'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DNBodyCollisionSpaceNode'),
            ('collidables', list(), FieldType.MFNode, AccessType.inputOutput, 'CollisionSpace'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 enabled=True,
                 useGeometry=False,
                 visible=True,
                 collidables=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CollisionSpace __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.enabled = enabled
        self.useGeometry = useGeometry
        self.visible = visible
        self.collidables = collidables
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def useGeometry(self):
        """useGeometry indicates whether collision-detection code checks down to level of geometry, or only make approximations using geometry bounds."""
        return self.__useGeometry
    @useGeometry.setter
    def useGeometry(self, useGeometry):
        if  useGeometry is None:
            useGeometry = False # default
        assertValidSFBool(useGeometry)
        self.__useGeometry = useGeometry
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def collidables(self):
        return self.__collidables
    @collidables.setter
    def collidables(self, collidables):
        if  collidables is None:
            collidables = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(collidables)
        self.__collidables = collidables
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.collidables or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function CollisionSpace.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<CollisionSpace'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.useGeometry: # default=false
            result += " useGeometry='" + SFBool(self.useGeometry).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></CollisionSpace>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.collidables: # walk each child in MFNode list, if any
            ### print('* CollisionSpace found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(collidables)=' + str(len(self.collidables)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.collidables:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</CollisionSpace>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function CollisionSpace.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'CollisionSpace' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'CollisionSpace' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.useGeometry: # default=false
            result += " useGeometry " + SFBool(self.useGeometry).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.collidables: # walk each child in MFNode list, if any
            for each in self.collidables:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Color(_X3DColorNode):
    """
    Color node defines a set of RGB color values that apply either to a sibling Coordinate|CoordinateDouble node, or else to a parent ElevationGrid node.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Color'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#Color'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Color'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('color', list(), FieldType.MFColor, AccessType.inputOutput, 'Color'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 color=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Color __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.color = color
    @property # getter - - - - - - - - - -
    def color(self):
        """The color field defines an array of 3-tuple RGB colors."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = MFColor.DEFAULT_VALUE(self)
        assertValidMFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Color.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Color'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.color != list():
            result += " color='" + MFColor(self.color).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Color>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Color>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Color.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Color' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Color' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.color != list():
            result += " color " + MFColor(self.color).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ColorChaser(_X3DChaserNode):
    """
    ColorChaser generates a series of SFColor values that progressively change from initial value to destination value.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ColorChaser'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/followers.html#ColorChaser'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ColorChaser'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('duration', 1, FieldType.SFTime, AccessType.initializeOnly, 'X3DChaserNode'),
            ('initialDestination', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.initializeOnly, 'ColorChaser'),
            ('initialValue', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.initializeOnly, 'ColorChaser'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 duration=1,
                 initialDestination=(0.8, 0.8, 0.8),
                 initialValue=(0.8, 0.8, 0.8),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ColorChaser __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
    @property # getter - - - - - - - - - -
    def duration(self):
        """[0,+infinity) duration is the time interval for filter response in seconds."""
        return self.__duration
    @duration.setter
    def duration(self, duration):
        if  duration is None:
            duration = 1 # default
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = (0.8, 0.8, 0.8) # default
        assertValidSFColor(initialDestination)
        assertZeroToOne('initialDestination', initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = (0.8, 0.8, 0.8) # default
        assertValidSFColor(initialValue)
        assertZeroToOne('initialValue', initialValue)
        self.__initialValue = initialValue
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ColorChaser.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ColorChaser'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.duration != 1:
            result += " duration='" + SFTime(self.duration).XML() + "'"
        if self.initialDestination != (0.8, 0.8, 0.8):
            result += " initialDestination='" + SFColor(self.initialDestination).XML() + "'"
        if self.initialValue != (0.8, 0.8, 0.8):
            result += " initialValue='" + SFColor(self.initialValue).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ColorChaser>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ColorChaser>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ColorChaser.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ColorChaser' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ColorChaser' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.duration != 1:
            result += " duration " + SFTime(self.duration).VRML() + ""
        if self.initialDestination != (0.8, 0.8, 0.8):
            result += " initialDestination " + SFColor(self.initialDestination).VRML() + ""
        if self.initialValue != (0.8, 0.8, 0.8):
            result += " initialValue " + SFColor(self.initialValue).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ColorDamper(_X3DDamperNode):
    """
    ColorDamper generates a series of RGB color values that progressively change from initial value to destination value.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ColorDamper'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/followers.html#ColorDamper'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ColorDamper'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('initialDestination', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.initializeOnly, 'ColorDamper'),
            ('initialValue', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.initializeOnly, 'ColorDamper'),
            ('order', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DDamperNode'),
            ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput, 'X3DDamperNode'),
            ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DDamperNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 initialDestination=(0.8, 0.8, 0.8),
                 initialValue=(0.8, 0.8, 0.8),
                 order=3,
                 tau=0.3,
                 tolerance=-1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ColorDamper __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = (0.8, 0.8, 0.8) # default
        assertValidSFColor(initialDestination)
        assertZeroToOne('initialDestination', initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = (0.8, 0.8, 0.8) # default
        assertValidSFColor(initialValue)
        assertZeroToOne('initialValue', initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        """[0,5] order defines the number of internal filters (larger means smoother response, longer delay)."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3 # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        """[0,+infinity) tau is the exponential-decay time constant for filter response in seconds."""
        return self.__tau
    @tau.setter
    def tau(self, tau):
        if  tau is None:
            tau = 0.3 # default
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        """[0,+infinity) or -1."""
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance):
        if  tolerance is None:
            tolerance = -1 # default
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ColorDamper.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ColorDamper'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.initialDestination != (0.8, 0.8, 0.8):
            result += " initialDestination='" + SFColor(self.initialDestination).XML() + "'"
        if self.initialValue != (0.8, 0.8, 0.8):
            result += " initialValue='" + SFColor(self.initialValue).XML() + "'"
        if self.order != 3:
            result += " order='" + SFInt32(self.order).XML() + "'"
        if self.tau != 0.3:
            result += " tau='" + SFTime(self.tau).XML() + "'"
        if self.tolerance != -1:
            result += " tolerance='" + SFFloat(self.tolerance).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ColorDamper>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ColorDamper>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ColorDamper.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ColorDamper' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ColorDamper' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.initialDestination != (0.8, 0.8, 0.8):
            result += " initialDestination " + SFColor(self.initialDestination).VRML() + ""
        if self.initialValue != (0.8, 0.8, 0.8):
            result += " initialValue " + SFColor(self.initialValue).VRML() + ""
        if self.order != 3:
            result += " order " + SFInt32(self.order).VRML() + ""
        if self.tau != 0.3:
            result += " tau " + SFTime(self.tau).VRML() + ""
        if self.tolerance != -1:
            result += " tolerance " + SFFloat(self.tolerance).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ColorInterpolator(_X3DInterpolatorNode):
    """
    ColorInterpolator generates a range of color values.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ColorInterpolator'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/interpolators.html#ColorInterpolator'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ColorInterpolator'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('key', list(), FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
            ('keyValue', list(), FieldType.MFColor, AccessType.inputOutput, 'ColorInterpolator'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ColorInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFColor.DEFAULT_VALUE(self)
        assertValidMFColor(keyValue)
        assertZeroToOne('keyValue', keyValue)
        self.__keyValue = keyValue
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ColorInterpolator.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ColorInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + MFFloat(self.key).XML() + "'"
        if self.keyValue != list():
            result += " keyValue='" + MFColor(self.keyValue).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ColorInterpolator>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ColorInterpolator>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ColorInterpolator.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ColorInterpolator' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ColorInterpolator' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.key != list():
            result += " key " + MFFloat(self.key).VRML() + ""
        if self.keyValue != list():
            result += " keyValue " + MFColor(self.keyValue).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ColorRGBA(_X3DColorNode):
    """
    ColorRGBA node defines a set of RGBA color values that apply either to a sibling Coordinate|CoordinateDouble node, or else to a parent ElevationGrid node.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ColorRGBA'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#ColorRGBA'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ColorRGBA'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('color', list(), FieldType.MFColorRGBA, AccessType.inputOutput, 'ColorRGBA'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 color=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ColorRGBA __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.color = color
    @property # getter - - - - - - - - - -
    def color(self):
        """[0,1] The color field defines an array of 4-tuple RGBA colors."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = MFColorRGBA.DEFAULT_VALUE(self)
        assertValidMFColorRGBA(color)
        assertZeroToOne('color', color)
        self.__color = color
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ColorRGBA.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ColorRGBA'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.color != list():
            result += " color='" + MFColorRGBA(self.color).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ColorRGBA>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ColorRGBA>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ColorRGBA.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ColorRGBA' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ColorRGBA' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.color != list():
            result += " color " + MFColorRGBA(self.color).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ComposedCubeMapTexture(_X3DEnvironmentTextureNode):
    """
    ComposedCubeMapTexture is a texture node that defines a cubic environment map source as an explicit set of images drawn from individual 2D texture nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ComposedCubeMapTexture'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/environmentalTexturing#ComposedCubeMapTexture'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ComposedCubeMapTexture'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureNode'),
            ('back', None, FieldType.SFNode, AccessType.inputOutput, 'ComposedCubeMapTexture'),
            ('bottom', None, FieldType.SFNode, AccessType.inputOutput, 'ComposedCubeMapTexture'),
            ('front', None, FieldType.SFNode, AccessType.inputOutput, 'ComposedCubeMapTexture'),
            ('left', None, FieldType.SFNode, AccessType.inputOutput, 'ComposedCubeMapTexture'),
            ('right', None, FieldType.SFNode, AccessType.inputOutput, 'ComposedCubeMapTexture'),
            ('top', None, FieldType.SFNode, AccessType.inputOutput, 'ComposedCubeMapTexture'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 back=None,
                 bottom=None,
                 front=None,
                 left=None,
                 right=None,
                 top=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ComposedCubeMapTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.back = back
        self.bottom = bottom
        self.front = front
        self.left = left
        self.right = right
        self.top = top
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def back(self):
        """[X3DTexture2DNode] Parent ComposedCubeMapTexture element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture, other texture nodes)."""
        return self.__back
    @back.setter
    def back(self, back):
        if  back is None:
            back = None # default
        assertValidSFNode(back)
        if not isinstance(back, object):
            # print(flush=True)
            raise X3DTypeError(str(back) + ' does not have a valid node type object')
        self.__back = back
    @property # getter - - - - - - - - - -
    def bottom(self):
        """[X3DTexture2DNode] Parent ComposedCubeMapTexture element can contain up to six image nodes (ImageTexture PixelTexture, other texture nodes)."""
        return self.__bottom
    @bottom.setter
    def bottom(self, bottom):
        if  bottom is None:
            bottom = None # default
        assertValidSFNode(bottom)
        if not isinstance(bottom, object):
            # print(flush=True)
            raise X3DTypeError(str(bottom) + ' does not have a valid node type object')
        self.__bottom = bottom
    @property # getter - - - - - - - - - -
    def front(self):
        """[X3DTexture2DNode] Parent ComposedCubeMapTexture element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture, other texture nodes)."""
        return self.__front
    @front.setter
    def front(self, front):
        if  front is None:
            front = None # default
        assertValidSFNode(front)
        if not isinstance(front, object):
            # print(flush=True)
            raise X3DTypeError(str(front) + ' does not have a valid node type object')
        self.__front = front
    @property # getter - - - - - - - - - -
    def left(self):
        """[X3DTexture2DNode] Parent ComposedCubeMapTexture element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture, other texture nodese)."""
        return self.__left
    @left.setter
    def left(self, left):
        if  left is None:
            left = None # default
        assertValidSFNode(left)
        if not isinstance(left, object):
            # print(flush=True)
            raise X3DTypeError(str(left) + ' does not have a valid node type object')
        self.__left = left
    @property # getter - - - - - - - - - -
    def right(self):
        """[X3DTexture2DNode] Parent ComposedCubeMapTexture element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture, other texture nodes)."""
        return self.__right
    @right.setter
    def right(self, right):
        if  right is None:
            right = None # default
        assertValidSFNode(right)
        if not isinstance(right, object):
            # print(flush=True)
            raise X3DTypeError(str(right) + ' does not have a valid node type object')
        self.__right = right
    @property # getter - - - - - - - - - -
    def top(self):
        """[X3DTexture2DNode] Parent ComposedCubeMapTexture element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture, other texture nodes)."""
        return self.__top
    @top.setter
    def top(self, top):
        if  top is None:
            top = None # default
        assertValidSFNode(top)
        if not isinstance(top, object):
            # print(flush=True)
            raise X3DTypeError(str(top) + ' does not have a valid node type object')
        self.__top = top
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.back or self.bottom or self.front or self.IS or self.left or self.metadata or self.right or self.top
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ComposedCubeMapTexture.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ComposedCubeMapTexture'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ComposedCubeMapTexture>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.back: # output this SFNode
                result += self.back.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.bottom: # output this SFNode
                result += self.bottom.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.front: # output this SFNode
                result += self.front.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.left: # output this SFNode
                result += self.left.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.right: # output this SFNode
                result += self.right.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.top: # output this SFNode
                result += self.top.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ComposedCubeMapTexture>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ComposedCubeMapTexture.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ComposedCubeMapTexture' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ComposedCubeMapTexture' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.back: # output this SFNode
            result += '\n' + '  ' + indent + 'back ' + self.back.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.bottom: # output this SFNode
            result += '\n' + '  ' + indent + 'bottom ' + self.bottom.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.front: # output this SFNode
            result += '\n' + '  ' + indent + 'front ' + self.front.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.left: # output this SFNode
            result += '\n' + '  ' + indent + 'left ' + self.left.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.right: # output this SFNode
            result += '\n' + '  ' + indent + 'right ' + self.right.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.top: # output this SFNode
            result += '\n' + '  ' + indent + 'top ' + self.top.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ComposedShader(_X3DShaderNode): # , _X3DProgrammableShaderObject # TODO fix additional inheritance method resolution order (MRO)
    """
    ComposedShader can contain field declarations, but no CDATA section of plain-text source code, since programs are composed from child ShaderPart nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ComposedShader'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shaders.html#ComposedShader'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ComposedShader'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('language', '', FieldType.SFString, AccessType.initializeOnly, 'X3DShaderNode'),
            ('field', list(), FieldType.MFNode, AccessType.inputOutput, 'ComposedShader'),
            ('parts', list(), FieldType.MFNode, AccessType.inputOutput, 'ComposedShader'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'ComposedShader'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'ComposedShader')]
    def __init__(self,
                 language='',
                 field=None,
                 parts=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ComposedShader __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.language = language
        self.field = field
        self.parts = parts
    @property # getter - - - - - - - - - -
    def language(self):
        """The language field indicates to the X3D player which shading language is used."""
        return self.__language
    @language.setter
    def language(self, language):
        if  language is None:
            language = SFString.DEFAULT_VALUE(self)
        assertValidSFString(language)
        self.__language = language
    @property # getter - - - - - - - - - -
    def field(self):
        """Include a field statement for each field declaration in the ComposedShader node."""
        return self.__field
    @field.setter
    def field(self, field):
        if  field is None:
            field = MFNode.DEFAULT_VALUE(self)
        # TODO type-aware checks for field
        if field: # walk each child in MFNode list, if any
            for each in field:
                assertValidFieldInitializationValue(each.name, each.type, each.value, parent='ComposedShader')
        self.__field = field
    @property # getter - - - - - - - - - -
    def parts(self):
        """[ShaderPart] ComposedShader can contain multiple ShaderPart nodes in the parts field."""
        return self.__parts
    @parts.setter
    def parts(self, parts):
        if  parts is None:
            parts = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(parts)
        self.__parts = parts
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.field or self.parts or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ComposedShader.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ComposedShader'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.language:
            result += " language='" + self.language + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ComposedShader>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.field: # walk each child in MFNode list, if any
            ### print('* ComposedShader found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(field)=' + str(len(self.field)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.field:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.parts: # walk each child in MFNode list, if any
            ### print('* ComposedShader found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(parts)=' + str(len(self.parts)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.parts:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ComposedShader>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ComposedShader.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ComposedShader' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ComposedShader' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.language:
            result += " language " +  '"' + self.language + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.field: # walk each child in MFNode list, if any
            for each in self.field:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.parts: # walk each child in MFNode list, if any
            for each in self.parts:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ComposedTexture3D(_X3DTexture3DNode):
    """
    ComposedTexture3D defines a 3D image-based texture map as a collection of 2D texture sources at various depths.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ComposedTexture3D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texture3D.html#ComposedTexture3D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ComposedTexture3D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureNode'),
            ('repeatR', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture3DNode'),
            ('repeatS', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture3DNode'),
            ('repeatT', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture3DNode'),
            ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly, 'X3DTexture3DNode'),
            ('texture', list(), FieldType.MFNode, AccessType.inputOutput, 'ComposedTexture3D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 repeatR=False,
                 repeatS=False,
                 repeatT=False,
                 textureProperties=None,
                 texture=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ComposedTexture3D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.repeatR = repeatR
        self.repeatS = repeatS
        self.repeatT = repeatT
        self.textureProperties = textureProperties
        self.texture = texture
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def repeatR(self):
        """Whether to vertically repeat texture along R axis."""
        return self.__repeatR
    @repeatR.setter
    def repeatR(self, repeatR):
        if  repeatR is None:
            repeatR = False # default
        assertValidSFBool(repeatR)
        self.__repeatR = repeatR
    @property # getter - - - - - - - - - -
    def repeatS(self):
        """Whether to horizontally repeat texture along S axis."""
        return self.__repeatS
    @repeatS.setter
    def repeatS(self, repeatS):
        if  repeatS is None:
            repeatS = False # default
        assertValidSFBool(repeatS)
        self.__repeatS = repeatS
    @property # getter - - - - - - - - - -
    def repeatT(self):
        """Whether to vertically repeat texture along T axis."""
        return self.__repeatT
    @repeatT.setter
    def repeatT(self, repeatT):
        if  repeatT is None:
            repeatT = False # default
        assertValidSFBool(repeatT)
        self.__repeatT = repeatT
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties):
        if  textureProperties is None:
            textureProperties = None # default
        assertValidSFNode(textureProperties)
        if not isinstance(textureProperties, object):
            # print(flush=True)
            raise X3DTypeError(str(textureProperties) + ' does not have a valid node type object')
        self.__textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def texture(self):
        return self.__texture
    @texture.setter
    def texture(self, texture):
        if  texture is None:
            texture = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(texture)
        self.__texture = texture
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.texture or self.IS or self.metadata or self.textureProperties
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ComposedTexture3D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ComposedTexture3D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.repeatR: # default=false
            result += " repeatR='" + SFBool(self.repeatR).XML() + "'"
        if self.repeatS: # default=false
            result += " repeatS='" + SFBool(self.repeatS).XML() + "'"
        if self.repeatT: # default=false
            result += " repeatT='" + SFBool(self.repeatT).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ComposedTexture3D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.textureProperties: # output this SFNode
                result += self.textureProperties.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.texture: # walk each child in MFNode list, if any
            ### print('* ComposedTexture3D found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(texture)=' + str(len(self.texture)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.texture:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ComposedTexture3D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ComposedTexture3D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ComposedTexture3D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ComposedTexture3D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.repeatR: # default=false
            result += " repeatR " + SFBool(self.repeatR).VRML() + ""
        if self.repeatS: # default=false
            result += " repeatS " + SFBool(self.repeatS).VRML() + ""
        if self.repeatT: # default=false
            result += " repeatT " + SFBool(self.repeatT).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.textureProperties: # output this SFNode
            result += '\n' + '  ' + indent + 'textureProperties ' + self.textureProperties.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texture: # walk each child in MFNode list, if any
            for each in self.texture:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ComposedVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    ComposedVolumeStyle allows compositing multiple rendering styles into single rendering pass.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ComposedVolumeStyle'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/volume.html#ComposedVolumeStyle'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ComposedVolumeStyle'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
            ('renderStyle', list(), FieldType.MFNode, AccessType.inputOutput, 'ComposedVolumeStyle'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 enabled=True,
                 renderStyle=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ComposedVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.renderStyle = renderStyle
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def renderStyle(self):
        """[X3DComposableVolumeRenderStyleNode] List of contributing rendering style nodes or node references that can be applied to the object."""
        return self.__renderStyle
    @renderStyle.setter
    def renderStyle(self, renderStyle):
        if  renderStyle is None:
            renderStyle = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(renderStyle)
        self.__renderStyle = renderStyle
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.renderStyle or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ComposedVolumeStyle.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ComposedVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ComposedVolumeStyle>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.renderStyle: # walk each child in MFNode list, if any
            ### print('* ComposedVolumeStyle found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(renderStyle)=' + str(len(self.renderStyle)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.renderStyle:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ComposedVolumeStyle>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ComposedVolumeStyle.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ComposedVolumeStyle' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ComposedVolumeStyle' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.renderStyle: # walk each child in MFNode list, if any
            for each in self.renderStyle:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Cone(_X3DGeometryNode):
    """
    Cone is a geometry node.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Cone'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geometry3D.html#Cone'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Cone'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bottom', True, FieldType.SFBool, AccessType.inputOutput, 'Cone'),
            ('bottomRadius', 1, FieldType.SFFloat, AccessType.initializeOnly, 'Cone'),
            ('height', 2, FieldType.SFFloat, AccessType.initializeOnly, 'Cone'),
            ('side', True, FieldType.SFBool, AccessType.inputOutput, 'Cone'),
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'Cone'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bottom=True,
                 bottomRadius=1,
                 height=2,
                 side=True,
                 solid=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Cone __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bottom = bottom
        self.bottomRadius = bottomRadius
        self.height = height
        self.side = side
        self.solid = solid
    @property # getter - - - - - - - - - -
    def bottom(self):
        """Whether to draw bottom (other inside faces are not drawn)."""
        return self.__bottom
    @bottom.setter
    def bottom(self, bottom):
        if  bottom is None:
            bottom = True # default
        assertValidSFBool(bottom)
        self.__bottom = bottom
    @property # getter - - - - - - - - - -
    def bottomRadius(self):
        """(0,+infinity) Size in meters."""
        return self.__bottomRadius
    @bottomRadius.setter
    def bottomRadius(self, bottomRadius):
        if  bottomRadius is None:
            bottomRadius = 1 # default
        assertValidSFFloat(bottomRadius)
        assertPositive('bottomRadius', bottomRadius)
        self.__bottomRadius = bottomRadius
    @property # getter - - - - - - - - - -
    def height(self):
        """(0,+infinity) Size in meters."""
        return self.__height
    @height.setter
    def height(self, height):
        if  height is None:
            height = 2 # default
        assertValidSFFloat(height)
        assertPositive('height', height)
        self.__height = height
    @property # getter - - - - - - - - - -
    def side(self):
        """Whether to draw sides (other inside faces are not drawn)."""
        return self.__side
    @side.setter
    def side(self, side):
        if  side is None:
            side = True # default
        assertValidSFBool(side)
        self.__side = side
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Cone.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Cone'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.bottom: # default=true
            result += " bottom='" + SFBool(self.bottom).XML() + "'"
        if self.bottomRadius != 1:
            result += " bottomRadius='" + SFFloat(self.bottomRadius).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.height != 2:
            result += " height='" + SFFloat(self.height).XML() + "'"
        if not self.side: # default=true
            result += " side='" + SFBool(self.side).XML() + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Cone>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Cone>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Cone.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Cone' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Cone' + ' {'
        if not self.bottom: # default=true
            result += " bottom " + SFBool(self.bottom).VRML() + ""
        if self.bottomRadius != 1:
            result += " bottomRadius " + SFFloat(self.bottomRadius).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.height != 2:
            result += " height " + SFFloat(self.height).VRML() + ""
        if not self.side: # default=true
            result += " side " + SFBool(self.side).VRML() + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ConeEmitter(_X3DParticleEmitterNode):
    """
    ConeEmitter generates all available particles from a specific point in space.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ConeEmitter'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/particleSystems.html#ConeEmitter'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ConeEmitter'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('angle', 0.7854, FieldType.SFFloat, AccessType.inputOutput, 'ConeEmitter'),
            ('direction', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'ConeEmitter'),
            ('mass', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('position', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'ConeEmitter'),
            ('speed', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('surfaceArea', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('variation', 0.25, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 angle=0.7854,
                 direction=(0, 1, 0),
                 mass=0,
                 position=(0, 0, 0),
                 speed=0,
                 surfaceArea=0,
                 variation=0.25,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ConeEmitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.angle = angle
        self.direction = direction
        self.mass = mass
        self.position = position
        self.speed = speed
        self.surfaceArea = surfaceArea
        self.variation = variation
    @property # getter - - - - - - - - - -
    def angle(self):
        """[0,+infinity) Cone boundary for random distribution of particles about initial direction."""
        return self.__angle
    @angle.setter
    def angle(self, angle):
        if  angle is None:
            angle = 0.7854 # default
        assertValidSFFloat(angle)
        assertGreaterThanEquals('angle', angle, 0)
        assertLessThanEquals('angle', angle, 3.1416)
        self.__angle = angle
    @property # getter - - - - - - - - - -
    def direction(self):
        """Initial direction from which particles emanate."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 1, 0) # default
        assertValidSFVec3f(direction)
        assertGreaterThanEquals('direction', direction, -1)
        assertLessThanEquals('direction', direction, 1)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def mass(self):
        return self.__mass
    @mass.setter
    def mass(self, mass):
        if  mass is None:
            mass = 0 # default
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def position(self):
        """Point from which particles emanate."""
        return self.__position
    @position.setter
    def position(self, position):
        if  position is None:
            position = (0, 0, 0) # default
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def speed(self):
        """[0,+infinity) Initial linear speed (default is m/s) imparted to all particles along their direction of movement."""
        return self.__speed
    @speed.setter
    def speed(self, speed):
        if  speed is None:
            speed = 0 # default
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def surfaceArea(self):
        """[0,+infinity) Particle surface area in area base units (default is meters squared)."""
        return self.__surfaceArea
    @surfaceArea.setter
    def surfaceArea(self, surfaceArea):
        if  surfaceArea is None:
            surfaceArea = 0 # default
        assertValidSFFloat(surfaceArea)
        assertNonNegative('surfaceArea', surfaceArea)
        self.__surfaceArea = surfaceArea
    @property # getter - - - - - - - - - -
    def variation(self):
        """[0,+infinity) Multiplier for the randomness used to control the range of possible output values."""
        return self.__variation
    @variation.setter
    def variation(self, variation):
        if  variation is None:
            variation = 0.25 # default
        assertValidSFFloat(variation)
        assertNonNegative('variation', variation)
        self.__variation = variation
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ConeEmitter.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ConeEmitter'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.angle != 0.7854:
            result += " angle='" + SFFloat(self.angle).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.direction != (0, 1, 0):
            result += " direction='" + SFVec3f(self.direction).XML() + "'"
        if self.mass != 0:
            result += " mass='" + SFFloat(self.mass).XML() + "'"
        if self.position != (0, 0, 0):
            result += " position='" + SFVec3f(self.position).XML() + "'"
        if self.speed != 0:
            result += " speed='" + SFFloat(self.speed).XML() + "'"
        if self.surfaceArea != 0:
            result += " surfaceArea='" + SFFloat(self.surfaceArea).XML() + "'"
        if self.variation != 0.25:
            result += " variation='" + SFFloat(self.variation).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ConeEmitter>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ConeEmitter>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ConeEmitter.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ConeEmitter' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ConeEmitter' + ' {'
        if self.angle != 0.7854:
            result += " angle " + SFFloat(self.angle).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.direction != (0, 1, 0):
            result += " direction " + SFVec3f(self.direction).VRML() + ""
        if self.mass != 0:
            result += " mass " + SFFloat(self.mass).VRML() + ""
        if self.position != (0, 0, 0):
            result += " position " + SFVec3f(self.position).VRML() + ""
        if self.speed != 0:
            result += " speed " + SFFloat(self.speed).VRML() + ""
        if self.surfaceArea != 0:
            result += " surfaceArea " + SFFloat(self.surfaceArea).VRML() + ""
        if self.variation != 0.25:
            result += " variation " + SFFloat(self.variation).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Contact(_X3DNode):
    """
    Contact nodes are produced as output events when two collidable objects or spaces make contact.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Contact'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rigidBodyPhysics.html#Contact'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Contact'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('appliedParameters', ["BOUNCE"], FieldType.MFString, AccessType.inputOutput, 'Contact'),
            ('bounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'Contact'),
            ('contactNormal', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'Contact'),
            ('depth', 0, FieldType.SFFloat, AccessType.inputOutput, 'Contact'),
            ('frictionCoefficients', (0, 0), FieldType.SFVec2f, AccessType.inputOutput, 'Contact'),
            ('frictionDirection', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'Contact'),
            ('minBounceSpeed', 0, FieldType.SFFloat, AccessType.inputOutput, 'Contact'),
            ('position', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'Contact'),
            ('slipCoefficients', (0, 0), FieldType.SFVec2f, AccessType.inputOutput, 'Contact'),
            ('softnessConstantForceMix', 0.0001, FieldType.SFFloat, AccessType.inputOutput, 'Contact'),
            ('softnessErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'Contact'),
            ('surfaceSpeed', (0, 0), FieldType.SFVec2f, AccessType.inputOutput, 'Contact'),
            ('body1', None, FieldType.SFNode, AccessType.inputOutput, 'Contact'),
            ('body2', None, FieldType.SFNode, AccessType.inputOutput, 'Contact'),
            ('geometry1', None, FieldType.SFNode, AccessType.inputOutput, 'Contact'),
            ('geometry2', None, FieldType.SFNode, AccessType.inputOutput, 'Contact'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 appliedParameters=["BOUNCE"],
                 bounce=0,
                 contactNormal=(0, 1, 0),
                 depth=0,
                 frictionCoefficients=(0, 0),
                 frictionDirection=(0, 1, 0),
                 minBounceSpeed=0,
                 position=(0, 0, 0),
                 slipCoefficients=(0, 0),
                 softnessConstantForceMix=0.0001,
                 softnessErrorCorrection=0.8,
                 surfaceSpeed=(0, 0),
                 body1=None,
                 body2=None,
                 geometry1=None,
                 geometry2=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Contact __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.appliedParameters = appliedParameters
        self.bounce = bounce
        self.contactNormal = contactNormal
        self.depth = depth
        self.frictionCoefficients = frictionCoefficients
        self.frictionDirection = frictionDirection
        self.minBounceSpeed = minBounceSpeed
        self.position = position
        self.slipCoefficients = slipCoefficients
        self.softnessConstantForceMix = softnessConstantForceMix
        self.softnessErrorCorrection = softnessErrorCorrection
        self.surfaceSpeed = surfaceSpeed
        self.body1 = body1
        self.body2 = body2
        self.geometry1 = geometry1
        self.geometry2 = geometry2
    @property # getter - - - - - - - - - -
    def appliedParameters(self):
        """Default global parameters for collision outputs of rigid body physics system."""
        return self.__appliedParameters
    @appliedParameters.setter
    def appliedParameters(self, appliedParameters):
        if  appliedParameters is None:
            appliedParameters = ["BOUNCE"] # default
        assertValidMFString(appliedParameters)
        assertValidAppliedParameters('appliedParameters', appliedParameters)
        self.__appliedParameters = appliedParameters
    @property # getter - - - - - - - - - -
    def bounce(self):
        """[0,1] bounce indicates bounciness (0 = no bounce at all, 1 = maximum bounce)."""
        return self.__bounce
    @bounce.setter
    def bounce(self, bounce):
        if  bounce is None:
            bounce = 0 # default
        assertValidSFFloat(bounce)
        assertZeroToOne('bounce', bounce)
        self.__bounce = bounce
    @property # getter - - - - - - - - - -
    def contactNormal(self):
        """contactNormal is unit vector describing normal between two colliding bodies."""
        return self.__contactNormal
    @contactNormal.setter
    def contactNormal(self, contactNormal):
        if  contactNormal is None:
            contactNormal = (0, 1, 0) # default
        assertValidSFVec3f(contactNormal)
        self.__contactNormal = contactNormal
    @property # getter - - - - - - - - - -
    def depth(self):
        """[0,1] depth indicates how deep the current intersection is along normal vector."""
        return self.__depth
    @depth.setter
    def depth(self, depth):
        if  depth is None:
            depth = 0 # default
        assertValidSFFloat(depth)
        self.__depth = depth
    @property # getter - - - - - - - - - -
    def frictionCoefficients(self):
        """frictionCoefficients used for computing surface drag."""
        return self.__frictionCoefficients
    @frictionCoefficients.setter
    def frictionCoefficients(self, frictionCoefficients):
        if  frictionCoefficients is None:
            frictionCoefficients = (0, 0) # default
        assertValidSFVec2f(frictionCoefficients)
        assertNonNegative('frictionCoefficients', frictionCoefficients)
        self.__frictionCoefficients = frictionCoefficients
    @property # getter - - - - - - - - - -
    def frictionDirection(self):
        """frictionDirection controls friction vector."""
        return self.__frictionDirection
    @frictionDirection.setter
    def frictionDirection(self, frictionDirection):
        if  frictionDirection is None:
            frictionDirection = (0, 1, 0) # default
        assertValidSFVec3f(frictionDirection)
        self.__frictionDirection = frictionDirection
    @property # getter - - - - - - - - - -
    def minBounceSpeed(self):
        """[0,+infinity) minBounceSpeed m/s needed to bounce."""
        return self.__minBounceSpeed
    @minBounceSpeed.setter
    def minBounceSpeed(self, minBounceSpeed):
        if  minBounceSpeed is None:
            minBounceSpeed = 0 # default
        assertValidSFFloat(minBounceSpeed)
        assertNonNegative('minBounceSpeed', minBounceSpeed)
        self.__minBounceSpeed = minBounceSpeed
    @property # getter - - - - - - - - - -
    def position(self):
        """position (x, y, z in meters) of exact location of collision."""
        return self.__position
    @position.setter
    def position(self, position):
        if  position is None:
            position = (0, 0, 0) # default
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def slipCoefficients(self):
        """slipCoefficients used for computing surface drag."""
        return self.__slipCoefficients
    @slipCoefficients.setter
    def slipCoefficients(self, slipCoefficients):
        if  slipCoefficients is None:
            slipCoefficients = (0, 0) # default
        assertValidSFVec2f(slipCoefficients)
        self.__slipCoefficients = slipCoefficients
    @property # getter - - - - - - - - - -
    def softnessConstantForceMix(self):
        """[0,1] softnessConstantForceMix value applies a constant force value to make colliding surfaces appear to be somewhat soft."""
        return self.__softnessConstantForceMix
    @softnessConstantForceMix.setter
    def softnessConstantForceMix(self, softnessConstantForceMix):
        if  softnessConstantForceMix is None:
            softnessConstantForceMix = 0.0001 # default
        assertValidSFFloat(softnessConstantForceMix)
        assertZeroToOne('softnessConstantForceMix', softnessConstantForceMix)
        self.__softnessConstantForceMix = softnessConstantForceMix
    @property # getter - - - - - - - - - -
    def softnessErrorCorrection(self):
        """[0,1] softnessErrorCorrection indicates fraction of collision error fixed in a set of evaluations (0 = no error correction, 1 = all errors corrected in single step)."""
        return self.__softnessErrorCorrection
    @softnessErrorCorrection.setter
    def softnessErrorCorrection(self, softnessErrorCorrection):
        if  softnessErrorCorrection is None:
            softnessErrorCorrection = 0.8 # default
        assertValidSFFloat(softnessErrorCorrection)
        assertZeroToOne('softnessErrorCorrection', softnessErrorCorrection)
        self.__softnessErrorCorrection = softnessErrorCorrection
    @property # getter - - - - - - - - - -
    def surfaceSpeed(self):
        """surfaceSpeed defines speed vectors for computing surface drag, if contact surfaces move independently of bodies."""
        return self.__surfaceSpeed
    @surfaceSpeed.setter
    def surfaceSpeed(self, surfaceSpeed):
        if  surfaceSpeed is None:
            surfaceSpeed = (0, 0) # default
        assertValidSFVec2f(surfaceSpeed)
        self.__surfaceSpeed = surfaceSpeed
    @property # getter - - - - - - - - - -
    def body1(self):
        return self.__body1
    @body1.setter
    def body1(self, body1):
        if  body1 is None:
            body1 = None # default
        assertValidSFNode(body1)
        if not isinstance(body1, object):
            # print(flush=True)
            raise X3DTypeError(str(body1) + ' does not have a valid node type object')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        return self.__body2
    @body2.setter
    def body2(self, body2):
        if  body2 is None:
            body2 = None # default
        assertValidSFNode(body2)
        if not isinstance(body2, object):
            # print(flush=True)
            raise X3DTypeError(str(body2) + ' does not have a valid node type object')
        self.__body2 = body2
    @property # getter - - - - - - - - - -
    def geometry1(self):
        return self.__geometry1
    @geometry1.setter
    def geometry1(self, geometry1):
        if  geometry1 is None:
            geometry1 = None # default
        assertValidSFNode(geometry1)
        if not isinstance(geometry1, object):
            # print(flush=True)
            raise X3DTypeError(str(geometry1) + ' does not have a valid node type object')
        self.__geometry1 = geometry1
    @property # getter - - - - - - - - - -
    def geometry2(self):
        return self.__geometry2
    @geometry2.setter
    def geometry2(self, geometry2):
        if  geometry2 is None:
            geometry2 = None # default
        assertValidSFNode(geometry2)
        if not isinstance(geometry2, object):
            # print(flush=True)
            raise X3DTypeError(str(geometry2) + ' does not have a valid node type object')
        self.__geometry2 = geometry2
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.body1 or self.body2 or self.geometry1 or self.geometry2 or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Contact.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Contact'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.appliedParameters != ["BOUNCE"]:
            result += " appliedParameters='" + MFString(self.appliedParameters).XML() + "'"
        if self.bounce != 0:
            result += " bounce='" + SFFloat(self.bounce).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.contactNormal != (0, 1, 0):
            result += " contactNormal='" + SFVec3f(self.contactNormal).XML() + "'"
        if self.depth != 0:
            result += " depth='" + SFFloat(self.depth).XML() + "'"
        if self.frictionCoefficients != (0, 0):
            result += " frictionCoefficients='" + SFVec2f(self.frictionCoefficients).XML() + "'"
        if self.frictionDirection != (0, 1, 0):
            result += " frictionDirection='" + SFVec3f(self.frictionDirection).XML() + "'"
        if self.minBounceSpeed != 0:
            result += " minBounceSpeed='" + SFFloat(self.minBounceSpeed).XML() + "'"
        if self.position != (0, 0, 0):
            result += " position='" + SFVec3f(self.position).XML() + "'"
        if self.slipCoefficients != (0, 0):
            result += " slipCoefficients='" + SFVec2f(self.slipCoefficients).XML() + "'"
        if self.softnessConstantForceMix != 0.0001:
            result += " softnessConstantForceMix='" + SFFloat(self.softnessConstantForceMix).XML() + "'"
        if self.softnessErrorCorrection != 0.8:
            result += " softnessErrorCorrection='" + SFFloat(self.softnessErrorCorrection).XML() + "'"
        if self.surfaceSpeed != (0, 0):
            result += " surfaceSpeed='" + SFVec2f(self.surfaceSpeed).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Contact>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.body1: # output this SFNode
                result += self.body1.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.body2: # output this SFNode
                result += self.body2.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.geometry1: # output this SFNode
                result += self.geometry1.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.geometry2: # output this SFNode
                result += self.geometry2.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Contact>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Contact.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Contact' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Contact' + ' {'
        if self.appliedParameters != ["BOUNCE"]:
            result += " appliedParameters " + MFString(self.appliedParameters).VRML() + ""
        if self.bounce != 0:
            result += " bounce " + SFFloat(self.bounce).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.contactNormal != (0, 1, 0):
            result += " contactNormal " + SFVec3f(self.contactNormal).VRML() + ""
        if self.depth != 0:
            result += " depth " + SFFloat(self.depth).VRML() + ""
        if self.frictionCoefficients != (0, 0):
            result += " frictionCoefficients " + SFVec2f(self.frictionCoefficients).VRML() + ""
        if self.frictionDirection != (0, 1, 0):
            result += " frictionDirection " + SFVec3f(self.frictionDirection).VRML() + ""
        if self.minBounceSpeed != 0:
            result += " minBounceSpeed " + SFFloat(self.minBounceSpeed).VRML() + ""
        if self.position != (0, 0, 0):
            result += " position " + SFVec3f(self.position).VRML() + ""
        if self.slipCoefficients != (0, 0):
            result += " slipCoefficients " + SFVec2f(self.slipCoefficients).VRML() + ""
        if self.softnessConstantForceMix != 0.0001:
            result += " softnessConstantForceMix " + SFFloat(self.softnessConstantForceMix).VRML() + ""
        if self.softnessErrorCorrection != 0.8:
            result += " softnessErrorCorrection " + SFFloat(self.softnessErrorCorrection).VRML() + ""
        if self.surfaceSpeed != (0, 0):
            result += " surfaceSpeed " + SFVec2f(self.surfaceSpeed).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.body1: # output this SFNode
            result += '\n' + '  ' + indent + 'body1 ' + self.body1.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.body2: # output this SFNode
            result += '\n' + '  ' + indent + 'body2 ' + self.body2.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.geometry1: # output this SFNode
            result += '\n' + '  ' + indent + 'geometry1 ' + self.geometry1.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.geometry2: # output this SFNode
            result += '\n' + '  ' + indent + 'geometry2 ' + self.geometry2.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Contour2D(_X3DNode):
    """
    Contour2D groups a set of curve segments into a composite contour.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Contour2D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/nurbs.html#Contour2D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Contour2D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'Contour2D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Contour2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.children = children
    @property # getter - - - - - - - - - -
    def children(self):
        """[NurbsCurve2D|ContourPolyline2D] The children form a closed loop with first point of first child repeated as last point of last child, and the last point of a segment repeated as first point of the consecutive one."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Contour2D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Contour2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Contour2D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* Contour2D found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Contour2D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Contour2D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Contour2D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Contour2D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ContourPolyline2D(_X3DNurbsControlCurveNode):
    """
    ContourPolyline2D defines a linear curve segment as part of a trimming contour in the u-v domain of a NURBS surface.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ContourPolyline2D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/nurbs.html#ContourPolyline2D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ContourPolyline2D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('controlPoint', list(), FieldType.MFVec2d, AccessType.inputOutput, 'X3DNurbsControlCurveNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 controlPoint=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ContourPolyline2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        """controlPoint specifies the end points of each segment of the piecewise linear curve."""
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint):
        if  controlPoint is None:
            controlPoint = MFVec2d.DEFAULT_VALUE(self)
        assertValidMFVec2d(controlPoint)
        self.__controlPoint = controlPoint
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ContourPolyline2D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ContourPolyline2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.controlPoint != list():
            result += " controlPoint='" + MFVec2d(self.controlPoint).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ContourPolyline2D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ContourPolyline2D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ContourPolyline2D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ContourPolyline2D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ContourPolyline2D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.controlPoint != list():
            result += " controlPoint " + MFVec2d(self.controlPoint).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Convolver(_X3DSoundProcessingNode):
    """
    Convolver performs a linear convolution on a given AudioBuffer, often used to achieve a reverberation effect.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Convolver'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#Convolver'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Convolver'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('buffer', list(), FieldType.MFFloat, AccessType.inputOutput, 'Convolver'),
            ('channelCountMode', 'max', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('channelInterpretation', 'speakers', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('normalize', False, FieldType.SFBool, AccessType.inputOutput, 'Convolver'),
            ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('tailTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 buffer=list(),
                 channelCountMode='max',
                 channelInterpretation='speakers',
                 description='',
                 enabled=True,
                 gain=1,
                 normalize=False,
                 pauseTime=0,
                 resumeTime=0,
                 startTime=0,
                 stopTime=0,
                 tailTime=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Convolver __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.buffer = buffer
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.normalize = normalize
        self.pauseTime = pauseTime
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.tailTime = tailTime
    @property # getter - - - - - - - - - -
    def buffer(self):
        """buffer is a memory-resident audio asset that can contain one or more channels."""
        return self.__buffer
    @buffer.setter
    def buffer(self, buffer):
        if  buffer is None:
            buffer = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(buffer)
        assertGreaterThanEquals('buffer', buffer, -1)
        assertLessThanEquals('buffer', buffer, 1)
        self.__buffer = buffer
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'max' # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'speakers' # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1 # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def normalize(self):
        """normalize controls whether or not the impulse response from the buffer is scaled by an equal-power normalization when the buffer field is set."""
        return self.__normalize
    @normalize.setter
    def normalize(self, normalize):
        if  normalize is None:
            normalize = False # default
        assertValidSFBool(normalize)
        self.__normalize = normalize
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0 # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0 # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0 # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0 # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def tailTime(self):
        """[0,+infinity) tailTime is duration of time that a node continues to provide output signal after the input signal becomes silent."""
        return self.__tailTime
    @tailTime.setter
    def tailTime(self, tailTime):
        if  tailTime is None:
            tailTime = 0 # default
        assertValidSFTime(tailTime)
        assertNonNegative('tailTime', tailTime)
        self.__tailTime = tailTime
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Convolver.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Convolver'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.buffer != list():
            result += " buffer='" + MFFloat(self.buffer).XML() + "'"
        if self.channelCountMode != 'max':
            result += " channelCountMode='" + self.channelCountMode + "'"
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation='" + self.channelInterpretation + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.gain != 1:
            result += " gain='" + SFFloat(self.gain).XML() + "'"
        if self.normalize: # default=false
            result += " normalize='" + SFBool(self.normalize).XML() + "'"
        if self.pauseTime != 0:
            result += " pauseTime='" + SFTime(self.pauseTime).XML() + "'"
        if self.resumeTime != 0:
            result += " resumeTime='" + SFTime(self.resumeTime).XML() + "'"
        if self.startTime != 0:
            result += " startTime='" + SFTime(self.startTime).XML() + "'"
        if self.stopTime != 0:
            result += " stopTime='" + SFTime(self.stopTime).XML() + "'"
        if self.tailTime != 0:
            result += " tailTime='" + SFTime(self.tailTime).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Convolver>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Convolver>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Convolver.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Convolver' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Convolver' + ' {'
        if self.buffer != list():
            result += " buffer " + MFFloat(self.buffer).VRML() + ""
        if self.channelCountMode != 'max':
            result += " channelCountMode " +  '"' + self.channelCountMode + '"' + ""
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation " +  '"' + self.channelInterpretation + '"' + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.gain != 1:
            result += " gain " + SFFloat(self.gain).VRML() + ""
        if self.normalize: # default=false
            result += " normalize " + SFBool(self.normalize).VRML() + ""
        if self.pauseTime != 0:
            result += " pauseTime " + SFTime(self.pauseTime).VRML() + ""
        if self.resumeTime != 0:
            result += " resumeTime " + SFTime(self.resumeTime).VRML() + ""
        if self.startTime != 0:
            result += " startTime " + SFTime(self.startTime).VRML() + ""
        if self.stopTime != 0:
            result += " stopTime " + SFTime(self.stopTime).VRML() + ""
        if self.tailTime != 0:
            result += " tailTime " + SFTime(self.tailTime).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Coordinate(_X3DCoordinateNode):
    """
    Coordinate builds geometry by defining a set of 3D coordinate (triplet) point values.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Coordinate'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#Coordinate'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Coordinate'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('point', list(), FieldType.MFVec3f, AccessType.inputOutput, 'Coordinate'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 point=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Coordinate __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.point = point
    @property # getter - - - - - - - - - -
    def point(self):
        """point contains a set of 3D coordinate (triplet) point values."""
        return self.__point
    @point.setter
    def point(self, point):
        if  point is None:
            point = MFVec3f.DEFAULT_VALUE(self)
        assertValidMFVec3f(point)
        self.__point = point
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Coordinate.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Coordinate'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.point != list():
            result += " point='" + MFVec3f(self.point).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Coordinate>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Coordinate>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Coordinate.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Coordinate' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Coordinate' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.point != list():
            result += " point " + MFVec3f(self.point).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class CoordinateChaser(_X3DChaserNode):
    """
    CoordinateChaser generates a series of coordinate arrays that progressively change from initial value to destination value.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'CoordinateChaser'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/followers.html#CoordinateChaser'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CoordinateChaser'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('duration', 1, FieldType.SFTime, AccessType.initializeOnly, 'X3DChaserNode'),
            ('initialDestination', [(0, 0, 0)], FieldType.MFVec3f, AccessType.initializeOnly, 'CoordinateChaser'),
            ('initialValue', [(0, 0, 0)], FieldType.MFVec3f, AccessType.initializeOnly, 'CoordinateChaser'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 duration=1,
                 initialDestination=[(0, 0, 0)],
                 initialValue=[(0, 0, 0)],
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CoordinateChaser __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
    @property # getter - - - - - - - - - -
    def duration(self):
        """[0,+infinity) duration is the time interval for filter response in seconds."""
        return self.__duration
    @duration.setter
    def duration(self, duration):
        if  duration is None:
            duration = 1 # default
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = [(0, 0, 0)] # default
        assertValidMFVec3f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = [(0, 0, 0)] # default
        assertValidMFVec3f(initialValue)
        self.__initialValue = initialValue
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function CoordinateChaser.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<CoordinateChaser'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.duration != 1:
            result += " duration='" + SFTime(self.duration).XML() + "'"
        if self.initialDestination != [(0, 0, 0)]:
            result += " initialDestination='" + MFVec3f(self.initialDestination).XML() + "'"
        if self.initialValue != [(0, 0, 0)]:
            result += " initialValue='" + MFVec3f(self.initialValue).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></CoordinateChaser>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</CoordinateChaser>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function CoordinateChaser.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'CoordinateChaser' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'CoordinateChaser' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.duration != 1:
            result += " duration " + SFTime(self.duration).VRML() + ""
        if self.initialDestination != [(0, 0, 0)]:
            result += " initialDestination " + MFVec3f(self.initialDestination).VRML() + ""
        if self.initialValue != [(0, 0, 0)]:
            result += " initialValue " + MFVec3f(self.initialValue).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class CoordinateDamper(_X3DDamperNode):
    """
    CoordinateDamper generates a series of coordinate arrays that progressively change from initial value to destination value.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'CoordinateDamper'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/followers.html#CoordinateDamper'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CoordinateDamper'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('initialDestination', [(0, 0, 0)], FieldType.MFVec3f, AccessType.initializeOnly, 'CoordinateDamper'),
            ('initialValue', [(0, 0, 0)], FieldType.MFVec3f, AccessType.initializeOnly, 'CoordinateDamper'),
            ('order', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DDamperNode'),
            ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput, 'X3DDamperNode'),
            ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DDamperNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 initialDestination=[(0, 0, 0)],
                 initialValue=[(0, 0, 0)],
                 order=3,
                 tau=0.3,
                 tolerance=-1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CoordinateDamper __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = [(0, 0, 0)] # default
        assertValidMFVec3f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = [(0, 0, 0)] # default
        assertValidMFVec3f(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        """[0,5] order defines the number of internal filters (larger means smoother response, longer delay)."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3 # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        """[0,+infinity) tau is the exponential-decay time constant for filter response in seconds."""
        return self.__tau
    @tau.setter
    def tau(self, tau):
        if  tau is None:
            tau = 0.3 # default
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        """[0,+infinity) or -1."""
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance):
        if  tolerance is None:
            tolerance = -1 # default
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function CoordinateDamper.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<CoordinateDamper'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.initialDestination != [(0, 0, 0)]:
            result += " initialDestination='" + MFVec3f(self.initialDestination).XML() + "'"
        if self.initialValue != [(0, 0, 0)]:
            result += " initialValue='" + MFVec3f(self.initialValue).XML() + "'"
        if self.order != 3:
            result += " order='" + SFInt32(self.order).XML() + "'"
        if self.tau != 0.3:
            result += " tau='" + SFTime(self.tau).XML() + "'"
        if self.tolerance != -1:
            result += " tolerance='" + SFFloat(self.tolerance).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></CoordinateDamper>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</CoordinateDamper>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function CoordinateDamper.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'CoordinateDamper' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'CoordinateDamper' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.initialDestination != [(0, 0, 0)]:
            result += " initialDestination " + MFVec3f(self.initialDestination).VRML() + ""
        if self.initialValue != [(0, 0, 0)]:
            result += " initialValue " + MFVec3f(self.initialValue).VRML() + ""
        if self.order != 3:
            result += " order " + SFInt32(self.order).VRML() + ""
        if self.tau != 0.3:
            result += " tau " + SFTime(self.tau).VRML() + ""
        if self.tolerance != -1:
            result += " tolerance " + SFFloat(self.tolerance).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class CoordinateDouble(_X3DCoordinateNode):
    """
    CoordinateDouble builds geometry by defining a set of 3D coordinate (triplet) point values.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'CoordinateDouble'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/nurbs.html#CoordinateDouble'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CoordinateDouble'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('point', list(), FieldType.MFVec3d, AccessType.inputOutput, 'CoordinateDouble'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 point=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CoordinateDouble __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.point = point
    @property # getter - - - - - - - - - -
    def point(self):
        """point contains a set of 3D coordinate (triplet) point values."""
        return self.__point
    @point.setter
    def point(self, point):
        if  point is None:
            point = MFVec3d.DEFAULT_VALUE(self)
        assertValidMFVec3d(point)
        self.__point = point
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function CoordinateDouble.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<CoordinateDouble'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.point != list():
            result += " point='" + MFVec3d(self.point).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></CoordinateDouble>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</CoordinateDouble>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function CoordinateDouble.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'CoordinateDouble' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'CoordinateDouble' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.point != list():
            result += " point " + MFVec3d(self.point).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class CoordinateInterpolator(_X3DInterpolatorNode):
    """
    CoordinateInterpolator linearly interpolates among a list of 3-tuple MFVec3f arrays, producing a single MFVec3f array that is fractional average between two nearest arrays in the list.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'CoordinateInterpolator'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/interpolators.html#CoordinateInterpolator'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CoordinateInterpolator'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('key', list(), FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
            ('keyValue', list(), FieldType.MFVec3f, AccessType.inputOutput, 'CoordinateInterpolator'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CoordinateInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFVec3f.DEFAULT_VALUE(self)
        assertValidMFVec3f(keyValue)
        self.__keyValue = keyValue
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function CoordinateInterpolator.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<CoordinateInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + MFFloat(self.key).XML() + "'"
        if self.keyValue != list():
            result += " keyValue='" + MFVec3f(self.keyValue).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></CoordinateInterpolator>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</CoordinateInterpolator>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function CoordinateInterpolator.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'CoordinateInterpolator' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'CoordinateInterpolator' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.key != list():
            result += " key " + MFFloat(self.key).VRML() + ""
        if self.keyValue != list():
            result += " keyValue " + MFVec3f(self.keyValue).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class CoordinateInterpolator2D(_X3DInterpolatorNode):
    """
    CoordinateInterpolator2D generates a series of SFVec2f or MFVec2f 2-tuple float values.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'CoordinateInterpolator2D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/interpolators.html#CoordinateInterpolator2D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CoordinateInterpolator2D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('key', list(), FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
            ('keyValue', list(), FieldType.MFVec2f, AccessType.inputOutput, 'CoordinateInterpolator2D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CoordinateInterpolator2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFVec2f.DEFAULT_VALUE(self)
        assertValidMFVec2f(keyValue)
        self.__keyValue = keyValue
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function CoordinateInterpolator2D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<CoordinateInterpolator2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + MFFloat(self.key).XML() + "'"
        if self.keyValue != list():
            result += " keyValue='" + MFVec2f(self.keyValue).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></CoordinateInterpolator2D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</CoordinateInterpolator2D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function CoordinateInterpolator2D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'CoordinateInterpolator2D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'CoordinateInterpolator2D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.key != list():
            result += " key " + MFFloat(self.key).VRML() + ""
        if self.keyValue != list():
            result += " keyValue " + MFVec2f(self.keyValue).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Cylinder(_X3DGeometryNode):
    """
    Cylinder is a geometry node.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Cylinder'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geometry3D.html#Cylinder'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Cylinder'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bottom', True, FieldType.SFBool, AccessType.inputOutput, 'Cylinder'),
            ('height', 2, FieldType.SFFloat, AccessType.initializeOnly, 'Cylinder'),
            ('radius', 1, FieldType.SFFloat, AccessType.initializeOnly, 'Cylinder'),
            ('side', True, FieldType.SFBool, AccessType.inputOutput, 'Cylinder'),
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'Cylinder'),
            ('top', True, FieldType.SFBool, AccessType.inputOutput, 'Cylinder'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bottom=True,
                 height=2,
                 radius=1,
                 side=True,
                 solid=True,
                 top=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Cylinder __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bottom = bottom
        self.height = height
        self.radius = radius
        self.side = side
        self.solid = solid
        self.top = top
    @property # getter - - - - - - - - - -
    def bottom(self):
        """Whether to draw bottom (inside faces are never drawn)."""
        return self.__bottom
    @bottom.setter
    def bottom(self, bottom):
        if  bottom is None:
            bottom = True # default
        assertValidSFBool(bottom)
        self.__bottom = bottom
    @property # getter - - - - - - - - - -
    def height(self):
        """(0,+infinity) Size in meters."""
        return self.__height
    @height.setter
    def height(self, height):
        if  height is None:
            height = 2 # default
        assertValidSFFloat(height)
        assertPositive('height', height)
        self.__height = height
    @property # getter - - - - - - - - - -
    def radius(self):
        """(0,+infinity) Size in meters."""
        return self.__radius
    @radius.setter
    def radius(self, radius):
        if  radius is None:
            radius = 1 # default
        assertValidSFFloat(radius)
        assertPositive('radius', radius)
        self.__radius = radius
    @property # getter - - - - - - - - - -
    def side(self):
        """Whether to draw sides (inside faces are never drawn)."""
        return self.__side
    @side.setter
    def side(self, side):
        if  side is None:
            side = True # default
        assertValidSFBool(side)
        self.__side = side
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def top(self):
        """Whether to draw top (inside faces are never drawn)."""
        return self.__top
    @top.setter
    def top(self, top):
        if  top is None:
            top = True # default
        assertValidSFBool(top)
        self.__top = top
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Cylinder.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Cylinder'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.bottom: # default=true
            result += " bottom='" + SFBool(self.bottom).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.height != 2:
            result += " height='" + SFFloat(self.height).XML() + "'"
        if self.radius != 1:
            result += " radius='" + SFFloat(self.radius).XML() + "'"
        if not self.side: # default=true
            result += " side='" + SFBool(self.side).XML() + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if not self.top: # default=true
            result += " top='" + SFBool(self.top).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Cylinder>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Cylinder>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Cylinder.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Cylinder' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Cylinder' + ' {'
        if not self.bottom: # default=true
            result += " bottom " + SFBool(self.bottom).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.height != 2:
            result += " height " + SFFloat(self.height).VRML() + ""
        if self.radius != 1:
            result += " radius " + SFFloat(self.radius).VRML() + ""
        if not self.side: # default=true
            result += " side " + SFBool(self.side).VRML() + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if not self.top: # default=true
            result += " top " + SFBool(self.top).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class CylinderSensor(_X3DDragSensorNode):
    """
    CylinderSensor converts pointer motion (for example, a mouse or wand) into rotation values using an invisible cylinder aligned with local Y-axis.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'CylinderSensor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/pointingDeviceSensor.html#CylinderSensor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#CylinderSensor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('autoOffset', True, FieldType.SFBool, AccessType.inputOutput, 'X3DDragSensorNode'),
            ('axisRotation', (0, 1, 0, 0), FieldType.SFRotation, AccessType.inputOutput, 'CylinderSensor'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DPointingDeviceSensorNode'),
            ('diskAngle', 0.26179167, FieldType.SFFloat, AccessType.inputOutput, 'CylinderSensor'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('maxAngle', -1, FieldType.SFFloat, AccessType.inputOutput, 'CylinderSensor'),
            ('minAngle', 0, FieldType.SFFloat, AccessType.inputOutput, 'CylinderSensor'),
            ('offset', 0, FieldType.SFFloat, AccessType.inputOutput, 'CylinderSensor'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 autoOffset=True,
                 axisRotation=(0, 1, 0, 0),
                 description='',
                 diskAngle=0.26179167,
                 enabled=True,
                 maxAngle=-1,
                 minAngle=0,
                 offset=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode CylinderSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.autoOffset = autoOffset
        self.axisRotation = axisRotation
        self.description = description
        self.diskAngle = diskAngle
        self.enabled = enabled
        self.maxAngle = maxAngle
        self.minAngle = minAngle
        self.offset = offset
    @property # getter - - - - - - - - - -
    def autoOffset(self):
        """determines whether previous offset values are remembered/accumulated."""
        return self.__autoOffset
    @autoOffset.setter
    def autoOffset(self, autoOffset):
        if  autoOffset is None:
            autoOffset = True # default
        assertValidSFBool(autoOffset)
        self.__autoOffset = autoOffset
    @property # getter - - - - - - - - - -
    def axisRotation(self):
        """axisRotation determines local sensor coordinate system by rotating the local coordinate system."""
        return self.__axisRotation
    @axisRotation.setter
    def axisRotation(self, axisRotation):
        if  axisRotation is None:
            axisRotation = (0, 1, 0, 0) # default
        assertValidSFRotation(axisRotation)
        self.__axisRotation = axisRotation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def diskAngle(self):
        """Help decide rotation behavior from initial relative bearing of pointer drag: acute angle whether cylinder sides or end-cap disks of virtual-geometry sensor are used for manipulation."""
        return self.__diskAngle
    @diskAngle.setter
    def diskAngle(self, diskAngle):
        if  diskAngle is None:
            diskAngle = 0.26179167 # default
        assertValidSFFloat(diskAngle)
        assertGreaterThanEquals('diskAngle', diskAngle, 0)
        assertLessThanEquals('diskAngle', diskAngle, 1.5708)
        self.__diskAngle = diskAngle
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def maxAngle(self):
        """clamps rotation_changed events within range of min/max values Hint: if minAngle > maxAngle, rotation is not clamped."""
        return self.__maxAngle
    @maxAngle.setter
    def maxAngle(self, maxAngle):
        if  maxAngle is None:
            maxAngle = -1 # default
        assertValidSFFloat(maxAngle)
        assertGreaterThan('maxAngle', maxAngle, -6.2832)
        assertLessThan('maxAngle', maxAngle, 6.2832)
        self.__maxAngle = maxAngle
    @property # getter - - - - - - - - - -
    def minAngle(self):
        """clamps rotation_changed events within range of min/max values Hint: if minAngle > maxAngle, rotation is not clamped."""
        return self.__minAngle
    @minAngle.setter
    def minAngle(self, minAngle):
        if  minAngle is None:
            minAngle = 0 # default
        assertValidSFFloat(minAngle)
        assertGreaterThan('minAngle', minAngle, -6.2832)
        assertLessThan('minAngle', minAngle, 6.2832)
        self.__minAngle = minAngle
    @property # getter - - - - - - - - - -
    def offset(self):
        """Sends event and remembers last value sensed."""
        return self.__offset
    @offset.setter
    def offset(self, offset):
        if  offset is None:
            offset = 0 # default
        assertValidSFFloat(offset)
        self.__offset = offset
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function CylinderSensor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<CylinderSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.autoOffset: # default=true
            result += " autoOffset='" + SFBool(self.autoOffset).XML() + "'"
        if self.axisRotation != (0, 1, 0, 0):
            result += " axisRotation='" + SFRotation(self.axisRotation).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.diskAngle != 0.26179167:
            result += " diskAngle='" + SFFloat(self.diskAngle).XML() + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.maxAngle != -1:
            result += " maxAngle='" + SFFloat(self.maxAngle).XML() + "'"
        if self.minAngle != 0:
            result += " minAngle='" + SFFloat(self.minAngle).XML() + "'"
        if self.offset != 0:
            result += " offset='" + SFFloat(self.offset).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></CylinderSensor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</CylinderSensor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function CylinderSensor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'CylinderSensor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'CylinderSensor' + ' {'
        if not self.autoOffset: # default=true
            result += " autoOffset " + SFBool(self.autoOffset).VRML() + ""
        if self.axisRotation != (0, 1, 0, 0):
            result += " axisRotation " + SFRotation(self.axisRotation).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.diskAngle != 0.26179167:
            result += " diskAngle " + SFFloat(self.diskAngle).VRML() + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.maxAngle != -1:
            result += " maxAngle " + SFFloat(self.maxAngle).VRML() + ""
        if self.minAngle != 0:
            result += " minAngle " + SFFloat(self.minAngle).VRML() + ""
        if self.offset != 0:
            result += " offset " + SFFloat(self.offset).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Delay(_X3DSoundProcessingNode):
    """
    Delay causes a time delay between the arrival of input data and subsequent propagation to the output.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Delay'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#Delay'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Delay'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('channelCountMode', 'max', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('channelInterpretation', 'speakers', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('delayTime', 0, FieldType.SFTime, AccessType.inputOutput, 'Delay'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('maxDelayTime', 1, FieldType.SFTime, AccessType.inputOutput, 'Delay'),
            ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('tailTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 channelCountMode='max',
                 channelInterpretation='speakers',
                 delayTime=0,
                 description='',
                 enabled=True,
                 gain=1,
                 maxDelayTime=1,
                 pauseTime=0,
                 resumeTime=0,
                 startTime=0,
                 stopTime=0,
                 tailTime=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Delay __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.delayTime = delayTime
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.maxDelayTime = maxDelayTime
        self.pauseTime = pauseTime
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.tailTime = tailTime
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'max' # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'speakers' # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def delayTime(self):
        """[0,+infinity) delayTime is duration of delay (in seconds) to apply."""
        return self.__delayTime
    @delayTime.setter
    def delayTime(self, delayTime):
        if  delayTime is None:
            delayTime = 0 # default
        assertValidSFTime(delayTime)
        assertNonNegative('delayTime', delayTime)
        self.__delayTime = delayTime
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1 # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def maxDelayTime(self):
        """[0,+infinity) maxDelayTime is duration of maximum amount of delay (in seconds) that can be applied."""
        return self.__maxDelayTime
    @maxDelayTime.setter
    def maxDelayTime(self, maxDelayTime):
        if  maxDelayTime is None:
            maxDelayTime = 1 # default
        assertValidSFTime(maxDelayTime)
        assertNonNegative('maxDelayTime', maxDelayTime)
        self.__maxDelayTime = maxDelayTime
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0 # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0 # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0 # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0 # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def tailTime(self):
        """[0,+infinity) tailTime is duration of time that a node continues to provide output signal after the input signal becomes silent."""
        return self.__tailTime
    @tailTime.setter
    def tailTime(self, tailTime):
        if  tailTime is None:
            tailTime = 0 # default
        assertValidSFTime(tailTime)
        assertNonNegative('tailTime', tailTime)
        self.__tailTime = tailTime
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Delay.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Delay'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.channelCountMode != 'max':
            result += " channelCountMode='" + self.channelCountMode + "'"
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation='" + self.channelInterpretation + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.delayTime != 0:
            result += " delayTime='" + SFTime(self.delayTime).XML() + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.gain != 1:
            result += " gain='" + SFFloat(self.gain).XML() + "'"
        if self.maxDelayTime != 1:
            result += " maxDelayTime='" + SFTime(self.maxDelayTime).XML() + "'"
        if self.pauseTime != 0:
            result += " pauseTime='" + SFTime(self.pauseTime).XML() + "'"
        if self.resumeTime != 0:
            result += " resumeTime='" + SFTime(self.resumeTime).XML() + "'"
        if self.startTime != 0:
            result += " startTime='" + SFTime(self.startTime).XML() + "'"
        if self.stopTime != 0:
            result += " stopTime='" + SFTime(self.stopTime).XML() + "'"
        if self.tailTime != 0:
            result += " tailTime='" + SFTime(self.tailTime).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Delay>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Delay>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Delay.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Delay' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Delay' + ' {'
        if self.channelCountMode != 'max':
            result += " channelCountMode " +  '"' + self.channelCountMode + '"' + ""
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation " +  '"' + self.channelInterpretation + '"' + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.delayTime != 0:
            result += " delayTime " + SFTime(self.delayTime).VRML() + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.gain != 1:
            result += " gain " + SFFloat(self.gain).VRML() + ""
        if self.maxDelayTime != 1:
            result += " maxDelayTime " + SFTime(self.maxDelayTime).VRML() + ""
        if self.pauseTime != 0:
            result += " pauseTime " + SFTime(self.pauseTime).VRML() + ""
        if self.resumeTime != 0:
            result += " resumeTime " + SFTime(self.resumeTime).VRML() + ""
        if self.startTime != 0:
            result += " startTime " + SFTime(self.startTime).VRML() + ""
        if self.stopTime != 0:
            result += " stopTime " + SFTime(self.stopTime).VRML() + ""
        if self.tailTime != 0:
            result += " tailTime " + SFTime(self.tailTime).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class DirectionalLight(_X3DLightNode):
    """
    DirectionalLight might not be scoped by parent Group or Transform at levels 1 or 2.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'DirectionalLight'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/lighting.html#DirectionalLight'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#DirectionalLight'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ambientIntensity', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
            ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'X3DLightNode'),
            ('direction', (0, 0, -1), FieldType.SFVec3f, AccessType.inputOutput, 'DirectionalLight'),
            ('global_', False, FieldType.SFBool, AccessType.inputOutput, 'DirectionalLight'),
            ('intensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
            ('on', True, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
            ('shadowIntensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
            ('shadows', False, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ambientIntensity=0,
                 color=(1, 1, 1),
                 direction=(0, 0, -1),
                 global_=False,
                 intensity=1,
                 on=True,
                 shadowIntensity=1,
                 shadows=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode DirectionalLight __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.color = color
        self.direction = direction
        self.global_ = global_
        self.intensity = intensity
        self.on = on
        self.shadowIntensity = shadowIntensity
        self.shadows = shadows
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        """[0,1] Brightness of ambient (nondirectional background) emission from the light."""
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity):
        if  ambientIntensity is None:
            ambientIntensity = 0 # default
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def color(self):
        """[0,1] color of light, applied to colors of objects."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = (1, 1, 1) # default
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def direction(self):
        """Orientation vector of light relative to local coordinate system."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 0, -1) # default
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def global_(self): # Appended underscore to field name to avoid naming collision with Python reserved word
        return self.__global_
    @global_.setter
    def global_(self, global_):
        if  global_ is None:
            global_ = False # default
        assertValidSFBool(global_)
        self.__global_ = global_
    @property # getter - - - - - - - - - -
    def intensity(self):
        """[0,1] Brightness of direct emission from the light."""
        return self.__intensity
    @intensity.setter
    def intensity(self, intensity):
        if  intensity is None:
            intensity = 1 # default
        assertValidSFFloat(intensity)
        assertZeroToOne('intensity', intensity)
        self.__intensity = intensity
    @property # getter - - - - - - - - - -
    def on(self):
        """Enables/disables this light source."""
        return self.__on
    @on.setter
    def on(self, on):
        if  on is None:
            on = True # default
        assertValidSFBool(on)
        self.__on = on
    @property # getter - - - - - - - - - -
    def shadowIntensity(self):
        """[0,1] shadowIntensity field defines how much light is obscured by shapes that cast shadows, ranging from 0 (light not obscured, no visible shadows) to 1 (light completely obscured, full-intensity shadows)."""
        return self.__shadowIntensity
    @shadowIntensity.setter
    def shadowIntensity(self, shadowIntensity):
        if  shadowIntensity is None:
            shadowIntensity = 1 # default
        assertValidSFFloat(shadowIntensity)
        assertZeroToOne('shadowIntensity', shadowIntensity)
        self.__shadowIntensity = shadowIntensity
    @property # getter - - - - - - - - - -
    def shadows(self):
        """shadows field indicates whether or not this light casts a shadow behind illuminated X3DShapeNode geometry."""
        return self.__shadows
    @shadows.setter
    def shadows(self, shadows):
        if  shadows is None:
            shadows = False # default
        assertValidSFBool(shadows)
        self.__shadows = shadows
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function DirectionalLight.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<DirectionalLight'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ambientIntensity != 0:
            result += " ambientIntensity='" + SFFloat(self.ambientIntensity).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.color != (1, 1, 1):
            result += " color='" + SFColor(self.color).XML() + "'"
        if self.direction != (0, 0, -1):
            result += " direction='" + SFVec3f(self.direction).XML() + "'"
        if self.global_: # default=false
            result += " global_='" + SFBool(self.global_).XML() + "'"
        if self.intensity != 1:
            result += " intensity='" + SFFloat(self.intensity).XML() + "'"
        if not self.on: # default=true
            result += " on='" + SFBool(self.on).XML() + "'"
        if self.shadowIntensity != 1:
            result += " shadowIntensity='" + SFFloat(self.shadowIntensity).XML() + "'"
        if self.shadows: # default=false
            result += " shadows='" + SFBool(self.shadows).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></DirectionalLight>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</DirectionalLight>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function DirectionalLight.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'DirectionalLight' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'DirectionalLight' + ' {'
        if self.ambientIntensity != 0:
            result += " ambientIntensity " + SFFloat(self.ambientIntensity).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.color != (1, 1, 1):
            result += " color " + SFColor(self.color).VRML() + ""
        if self.direction != (0, 0, -1):
            result += " direction " + SFVec3f(self.direction).VRML() + ""
        if self.global_: # default=false
            result += " global_ " + SFBool(self.global_).VRML() + ""
        if self.intensity != 1:
            result += " intensity " + SFFloat(self.intensity).VRML() + ""
        if not self.on: # default=true
            result += " on " + SFBool(self.on).VRML() + ""
        if self.shadowIntensity != 1:
            result += " shadowIntensity " + SFFloat(self.shadowIntensity).VRML() + ""
        if self.shadows: # default=false
            result += " shadows " + SFBool(self.shadows).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class DISEntityManager(_X3DChildNode):
    """
    DISEntityManager notifies a scene when new DIS ESPDU entities arrive or current entities leave.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'DISEntityManager'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/dis.html#DISEntityManager'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#DISEntityManager'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('address', 'localhost', FieldType.SFString, AccessType.inputOutput, 'DISEntityManager'),
            ('applicationID', 0, FieldType.SFInt32, AccessType.inputOutput, 'DISEntityManager'),
            ('port', 0, FieldType.SFInt32, AccessType.inputOutput, 'DISEntityManager'),
            ('siteID', 0, FieldType.SFInt32, AccessType.inputOutput, 'DISEntityManager'),
            ('mapping', list(), FieldType.MFNode, AccessType.inputOutput, 'DISEntityManager'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 address='localhost',
                 applicationID=0,
                 port=0,
                 siteID=0,
                 mapping=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode DISEntityManager __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.address = address
        self.applicationID = applicationID
        self.port = port
        self.siteID = siteID
        self.mapping = mapping
    @property # getter - - - - - - - - - -
    def address(self):
        """Multicast network address, or else "localhost" example: 224."""
        return self.__address
    @address.setter
    def address(self, address):
        if  address is None:
            address = 'localhost' # default
        assertValidSFString(address)
        self.__address = address
    @property # getter - - - - - - - - - -
    def applicationID(self):
        """Each simulation application that can respond to simulation management PDUs needs to have a unique applicationID."""
        return self.__applicationID
    @applicationID.setter
    def applicationID(self, applicationID):
        if  applicationID is None:
            applicationID = 0 # default
        assertValidSFInt32(applicationID)
        self.__applicationID = applicationID
    @property # getter - - - - - - - - - -
    def port(self):
        """Multicast network port, for example: 3000."""
        return self.__port
    @port.setter
    def port(self, port):
        if  port is None:
            port = 0 # default
        assertValidSFInt32(port)
        self.__port = port
    @property # getter - - - - - - - - - -
    def siteID(self):
        """Simulation/exercise siteID of the participating LAN or organization."""
        return self.__siteID
    @siteID.setter
    def siteID(self, siteID):
        if  siteID is None:
            siteID = 0 # default
        assertValidSFInt32(siteID)
        self.__siteID = siteID
    @property # getter - - - - - - - - - -
    def mapping(self):
        """[DISEntityTypeMapping] mapping field provides a mechanism for automatically creating an X3D model when a new entity arrives over the network."""
        return self.__mapping
    @mapping.setter
    def mapping(self, mapping):
        if  mapping is None:
            mapping = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(mapping)
        self.__mapping = mapping
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.mapping or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function DISEntityManager.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<DISEntityManager'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.address != 'localhost':
            result += " address='" + self.address + "'"
        if self.applicationID != 0:
            result += " applicationID='" + SFInt32(self.applicationID).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.port != 0:
            result += " port='" + SFInt32(self.port).XML() + "'"
        if self.siteID != 0:
            result += " siteID='" + SFInt32(self.siteID).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></DISEntityManager>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.mapping: # walk each child in MFNode list, if any
            ### print('* DISEntityManager found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(mapping)=' + str(len(self.mapping)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.mapping:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</DISEntityManager>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function DISEntityManager.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'DISEntityManager' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'DISEntityManager' + ' {'
        if self.address != 'localhost':
            result += " address " +  '"' + self.address + '"' + ""
        if self.applicationID != 0:
            result += " applicationID " + SFInt32(self.applicationID).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.port != 0:
            result += " port " + SFInt32(self.port).VRML() + ""
        if self.siteID != 0:
            result += " siteID " + SFInt32(self.siteID).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.mapping: # walk each child in MFNode list, if any
            for each in self.mapping:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class DISEntityTypeMapping(_X3DInfoNode, _X3DUrlObject):
    """
    DISEntityTypeMapping provides a best-match mapping from DIS ESPDU entity type information to a specific X3D model, thus providing a visual and behavioral representation that best matches the entity type.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'DISEntityTypeMapping'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/dis.html#DISEntityTypeMapping'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#DISEntityTypeMapping'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('category', 0, FieldType.SFInt32, AccessType.initializeOnly, 'DISEntityTypeMapping'),
            ('country', 0, FieldType.SFInt32, AccessType.initializeOnly, 'DISEntityTypeMapping'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DUrlObject'),
            ('domain', 0, FieldType.SFInt32, AccessType.initializeOnly, 'DISEntityTypeMapping'),
            ('extra', 0, FieldType.SFInt32, AccessType.initializeOnly, 'DISEntityTypeMapping'),
            ('kind', 0, FieldType.SFInt32, AccessType.initializeOnly, 'DISEntityTypeMapping'),
            ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
            ('refresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
            ('specific', 0, FieldType.SFInt32, AccessType.initializeOnly, 'DISEntityTypeMapping'),
            ('subcategory', 0, FieldType.SFInt32, AccessType.initializeOnly, 'DISEntityTypeMapping'),
            ('url', list(), FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 category=0,
                 country=0,
                 description='',
                 domain=0,
                 extra=0,
                 kind=0,
                 load=True,
                 refresh=0,
                 specific=0,
                 subcategory=0,
                 url=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode DISEntityTypeMapping __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.category = category
        self.country = country
        self.description = description
        self.domain = domain
        self.extra = extra
        self.kind = kind
        self.load = load
        self.refresh = refresh
        self.specific = specific
        self.subcategory = subcategory
        self.url = url
    @property # getter - - - - - - - - - -
    def category(self):
        """Integer enumerations value for main category that describes the entity, semantics of each code varies according to domain."""
        return self.__category
    @category.setter
    def category(self, category):
        if  category is None:
            category = 0 # default
        assertValidSFInt32(category)
        assertGreaterThanEquals('category', category, 0)
        assertLessThanEquals('category', category, 255)
        self.__category = category
    @property # getter - - - - - - - - - -
    def country(self):
        """Integer enumerations value for country to which the design of the entity or its design specification is attributed."""
        return self.__country
    @country.setter
    def country(self, country):
        if  country is None:
            country = 0 # default
        assertValidSFInt32(country)
        assertGreaterThanEquals('country', country, 0)
        assertLessThanEquals('country', country, 65535)
        self.__country = country
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def domain(self):
        """Integer enumerations value for domain in which the entity operates: LAND, AIR, SURFACE, SUBSURFACE, SPACE or OTHER."""
        return self.__domain
    @domain.setter
    def domain(self, domain):
        if  domain is None:
            domain = 0 # default
        assertValidSFInt32(domain)
        assertGreaterThanEquals('domain', domain, 0)
        assertLessThanEquals('domain', domain, 255)
        self.__domain = domain
    @property # getter - - - - - - - - - -
    def extra(self):
        """Any extra information required to describe a particular entity."""
        return self.__extra
    @extra.setter
    def extra(self, extra):
        if  extra is None:
            extra = 0 # default
        assertValidSFInt32(extra)
        assertGreaterThanEquals('extra', extra, 0)
        assertLessThanEquals('extra', extra, 255)
        self.__extra = extra
    @property # getter - - - - - - - - - -
    def kind(self):
        """Integer enumerations value for whether entity is a PLATFORM, MUNITION, LIFE_FORM, ENVIRONMENTAL, CULTURAL_FEATURE, SUPPLY, RADIO, EXPENDABLE, SENSOR_EMITTER or OTHER."""
        return self.__kind
    @kind.setter
    def kind(self, kind):
        if  kind is None:
            kind = 0 # default
        assertValidSFInt32(kind)
        assertGreaterThanEquals('kind', kind, 0)
        assertLessThanEquals('kind', kind, 255)
        self.__kind = kind
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def refresh(self):
        """refresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__refresh
    @refresh.setter
    def refresh(self, refresh):
        if  refresh is None:
            refresh = 0 # default
        assertValidSFTime(refresh)
        assertNonNegative('refresh', refresh)
        self.__refresh = refresh
    @property # getter - - - - - - - - - -
    def specific(self):
        """Specific information about an entity based on the Subcategory field."""
        return self.__specific
    @specific.setter
    def specific(self, specific):
        if  specific is None:
            specific = 0 # default
        assertValidSFInt32(specific)
        assertGreaterThanEquals('specific', specific, 0)
        assertLessThanEquals('specific', specific, 255)
        self.__specific = specific
    @property # getter - - - - - - - - - -
    def subcategory(self):
        return self.__subcategory
    @subcategory.setter
    def subcategory(self, subcategory):
        if  subcategory is None:
            subcategory = 0 # default
        assertValidSFInt32(subcategory)
        assertGreaterThanEquals('subcategory', subcategory, 0)
        assertLessThanEquals('subcategory', subcategory, 255)
        self.__subcategory = subcategory
    @property # getter - - - - - - - - - -
    def url(self):
        """Local and/or online addresses of X3D model of interest, for example: "ExtrusionExampleShip."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE(self)
        assertValidMFString(url)
        self.__url = url
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function DISEntityTypeMapping.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<DISEntityTypeMapping'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.category != 0:
            result += " category='" + SFInt32(self.category).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.country != 0:
            result += " country='" + SFInt32(self.country).XML() + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.domain != 0:
            result += " domain='" + SFInt32(self.domain).XML() + "'"
        if self.extra != 0:
            result += " extra='" + SFInt32(self.extra).XML() + "'"
        if self.kind != 0:
            result += " kind='" + SFInt32(self.kind).XML() + "'"
        if not self.load: # default=true
            result += " load='" + SFBool(self.load).XML() + "'"
        if self.refresh != 0:
            result += " refresh='" + SFTime(self.refresh).XML() + "'"
        if self.specific != 0:
            result += " specific='" + SFInt32(self.specific).XML() + "'"
        if self.subcategory != 0:
            result += " subcategory='" + SFInt32(self.subcategory).XML() + "'"
        if self.url != list():
            result += " url='" + MFString(self.url).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></DISEntityTypeMapping>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</DISEntityTypeMapping>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function DISEntityTypeMapping.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'DISEntityTypeMapping' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'DISEntityTypeMapping' + ' {'
        if self.category != 0:
            result += " category " + SFInt32(self.category).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.country != 0:
            result += " country " + SFInt32(self.country).VRML() + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.domain != 0:
            result += " domain " + SFInt32(self.domain).VRML() + ""
        if self.extra != 0:
            result += " extra " + SFInt32(self.extra).VRML() + ""
        if self.kind != 0:
            result += " kind " + SFInt32(self.kind).VRML() + ""
        if not self.load: # default=true
            result += " load " + SFBool(self.load).VRML() + ""
        if self.refresh != 0:
            result += " refresh " + SFTime(self.refresh).VRML() + ""
        if self.specific != 0:
            result += " specific " + SFInt32(self.specific).VRML() + ""
        if self.subcategory != 0:
            result += " subcategory " + SFInt32(self.subcategory).VRML() + ""
        if self.url != list():
            result += " url " + MFString(self.url).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Disk2D(_X3DGeometryNode):
    """
    Disk2D is a geometry node that defines a filled (or partially filled) planar circle with center (0,0).
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Disk2D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geometry2D.html#Disk2D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Disk2D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('innerRadius', 0, FieldType.SFFloat, AccessType.initializeOnly, 'Disk2D'),
            ('outerRadius', 1, FieldType.SFFloat, AccessType.initializeOnly, 'Disk2D'),
            ('solid', False, FieldType.SFBool, AccessType.initializeOnly, 'Disk2D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 innerRadius=0,
                 outerRadius=1,
                 solid=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Disk2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.innerRadius = innerRadius
        self.outerRadius = outerRadius
        self.solid = solid
    @property # getter - - - - - - - - - -
    def innerRadius(self):
        """[0,+infinity) Inner circle radius, greater than or equal to 0."""
        return self.__innerRadius
    @innerRadius.setter
    def innerRadius(self, innerRadius):
        if  innerRadius is None:
            innerRadius = 0 # default
        assertValidSFFloat(innerRadius)
        assertNonNegative('innerRadius', innerRadius)
        self.__innerRadius = innerRadius
    @property # getter - - - - - - - - - -
    def outerRadius(self):
        """(0,+infinity) Outer radius of circle, greater than or equal to inner radius."""
        return self.__outerRadius
    @outerRadius.setter
    def outerRadius(self, outerRadius):
        if  outerRadius is None:
            outerRadius = 1 # default
        assertValidSFFloat(outerRadius)
        assertPositive('outerRadius', outerRadius)
        self.__outerRadius = outerRadius
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = False # default
        assertValidSFBool(solid)
        self.__solid = solid
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Disk2D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Disk2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.innerRadius != 0:
            result += " innerRadius='" + SFFloat(self.innerRadius).XML() + "'"
        if self.outerRadius != 1:
            result += " outerRadius='" + SFFloat(self.outerRadius).XML() + "'"
        if self.solid: # default=false
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Disk2D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Disk2D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Disk2D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Disk2D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Disk2D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.innerRadius != 0:
            result += " innerRadius " + SFFloat(self.innerRadius).VRML() + ""
        if self.outerRadius != 1:
            result += " outerRadius " + SFFloat(self.outerRadius).VRML() + ""
        if self.solid: # default=false
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class DoubleAxisHingeJoint(_X3DRigidJointNode):
    """
    DoubleAxisHingeJoint has two independent axes located around a common anchor point.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'DoubleAxisHingeJoint'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rigidBodyPhysics.html#DoubleAxisHingeJoint'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#DoubleAxisHingeJoint'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('anchorPoint', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
            ('axis1', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
            ('axis2', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
            ('desiredAngularVelocity1', 0, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
            ('desiredAngularVelocity2', 0, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
            ('forceOutput', ["NONE"], FieldType.MFString, AccessType.inputOutput, 'X3DRigidJointNode'),
            ('maxAngle1', 3.141592653, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
            ('maxTorque1', 0, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
            ('maxTorque2', 0, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
            ('minAngle1', -3.141592653, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
            ('stop1Bounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
            ('stop1ConstantForceMix', 0.001, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
            ('stop1ErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
            ('suspensionErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
            ('suspensionForce', 0, FieldType.SFFloat, AccessType.inputOutput, 'DoubleAxisHingeJoint'),
            ('body1', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
            ('body2', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 anchorPoint=(0, 0, 0),
                 axis1=(0, 0, 0),
                 axis2=(0, 0, 0),
                 desiredAngularVelocity1=0,
                 desiredAngularVelocity2=0,
                 forceOutput=["NONE"],
                 maxAngle1=3.141592653,
                 maxTorque1=0,
                 maxTorque2=0,
                 minAngle1=-3.141592653,
                 stop1Bounce=0,
                 stop1ConstantForceMix=0.001,
                 stop1ErrorCorrection=0.8,
                 suspensionErrorCorrection=0.8,
                 suspensionForce=0,
                 body1=None,
                 body2=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode DoubleAxisHingeJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.anchorPoint = anchorPoint
        self.axis1 = axis1
        self.axis2 = axis2
        self.desiredAngularVelocity1 = desiredAngularVelocity1
        self.desiredAngularVelocity2 = desiredAngularVelocity2
        self.forceOutput = forceOutput
        self.maxAngle1 = maxAngle1
        self.maxTorque1 = maxTorque1
        self.maxTorque2 = maxTorque2
        self.minAngle1 = minAngle1
        self.stop1Bounce = stop1Bounce
        self.stop1ConstantForceMix = stop1ConstantForceMix
        self.stop1ErrorCorrection = stop1ErrorCorrection
        self.suspensionErrorCorrection = suspensionErrorCorrection
        self.suspensionForce = suspensionForce
        self.body1 = body1
        self.body2 = body2
    @property # getter - - - - - - - - - -
    def anchorPoint(self):
        """anchorPoint is joint center, specified in world coordinates."""
        return self.__anchorPoint
    @anchorPoint.setter
    def anchorPoint(self, anchorPoint):
        if  anchorPoint is None:
            anchorPoint = (0, 0, 0) # default
        assertValidSFVec3f(anchorPoint)
        self.__anchorPoint = anchorPoint
    @property # getter - - - - - - - - - -
    def axis1(self):
        """axis1 defines axis vector of joint connection to body1."""
        return self.__axis1
    @axis1.setter
    def axis1(self, axis1):
        if  axis1 is None:
            axis1 = (0, 0, 0) # default
        assertValidSFVec3f(axis1)
        self.__axis1 = axis1
    @property # getter - - - - - - - - - -
    def axis2(self):
        """axis2 defines axis vector of joint connection to body2."""
        return self.__axis2
    @axis2.setter
    def axis2(self, axis2):
        if  axis2 is None:
            axis2 = (0, 0, 0) # default
        assertValidSFVec3f(axis2)
        self.__axis2 = axis2
    @property # getter - - - - - - - - - -
    def desiredAngularVelocity1(self):
        """desiredAngularVelocity1 is goal rotation rate for hinge connection to body1."""
        return self.__desiredAngularVelocity1
    @desiredAngularVelocity1.setter
    def desiredAngularVelocity1(self, desiredAngularVelocity1):
        if  desiredAngularVelocity1 is None:
            desiredAngularVelocity1 = 0 # default
        assertValidSFFloat(desiredAngularVelocity1)
        self.__desiredAngularVelocity1 = desiredAngularVelocity1
    @property # getter - - - - - - - - - -
    def desiredAngularVelocity2(self):
        """desiredAngularVelocity2 is goal rotation rate for hinge connection to body2."""
        return self.__desiredAngularVelocity2
    @desiredAngularVelocity2.setter
    def desiredAngularVelocity2(self, desiredAngularVelocity2):
        if  desiredAngularVelocity2 is None:
            desiredAngularVelocity2 = 0 # default
        assertValidSFFloat(desiredAngularVelocity2)
        self.__desiredAngularVelocity2 = desiredAngularVelocity2
    @property # getter - - - - - - - - - -
    def forceOutput(self):
        """forceOutput controls which output fields are generated for the next frame."""
        return self.__forceOutput
    @forceOutput.setter
    def forceOutput(self, forceOutput):
        if  forceOutput is None:
            forceOutput = ["NONE"] # default
        assertValidMFString(forceOutput)
        self.__forceOutput = forceOutput
    @property # getter - - - - - - - - - -
    def maxAngle1(self):
        """[-pi,pi] maxAngle1 is maximum rotation angle for hinge."""
        return self.__maxAngle1
    @maxAngle1.setter
    def maxAngle1(self, maxAngle1):
        if  maxAngle1 is None:
            maxAngle1 = 3.141592653 # default
        assertValidSFFloat(maxAngle1)
        self.__maxAngle1 = maxAngle1
    @property # getter - - - - - - - - - -
    def maxTorque1(self):
        """maxTorque1 is maximum rotational torque applied by corresponding motor axis to achieve desiredAngularVelocity1."""
        return self.__maxTorque1
    @maxTorque1.setter
    def maxTorque1(self, maxTorque1):
        if  maxTorque1 is None:
            maxTorque1 = 0 # default
        assertValidSFFloat(maxTorque1)
        self.__maxTorque1 = maxTorque1
    @property # getter - - - - - - - - - -
    def maxTorque2(self):
        """maxTorque2 is maximum rotational torque applied by corresponding motor axis to achieve desiredAngularVelocity2."""
        return self.__maxTorque2
    @maxTorque2.setter
    def maxTorque2(self, maxTorque2):
        if  maxTorque2 is None:
            maxTorque2 = 0 # default
        assertValidSFFloat(maxTorque2)
        self.__maxTorque2 = maxTorque2
    @property # getter - - - - - - - - - -
    def minAngle1(self):
        """[-pi,pi] minAngle1 is minimum rotation angle for hinge."""
        return self.__minAngle1
    @minAngle1.setter
    def minAngle1(self, minAngle1):
        if  minAngle1 is None:
            minAngle1 = -3.141592653 # default
        assertValidSFFloat(minAngle1)
        self.__minAngle1 = minAngle1
    @property # getter - - - - - - - - - -
    def stop1Bounce(self):
        """[0,1] stop1Bounce is velocity factor for bounce back once stop point is reached."""
        return self.__stop1Bounce
    @stop1Bounce.setter
    def stop1Bounce(self, stop1Bounce):
        if  stop1Bounce is None:
            stop1Bounce = 0 # default
        assertValidSFFloat(stop1Bounce)
        self.__stop1Bounce = stop1Bounce
    @property # getter - - - - - - - - - -
    def stop1ConstantForceMix(self):
        """[0,1] stop1ConstantForceMix value applies a constant force value to make colliding surfaces appear to be somewhat soft."""
        return self.__stop1ConstantForceMix
    @stop1ConstantForceMix.setter
    def stop1ConstantForceMix(self, stop1ConstantForceMix):
        if  stop1ConstantForceMix is None:
            stop1ConstantForceMix = 0.001 # default
        assertValidSFFloat(stop1ConstantForceMix)
        self.__stop1ConstantForceMix = stop1ConstantForceMix
    @property # getter - - - - - - - - - -
    def stop1ErrorCorrection(self):
        """[0,1] stop1ErrorCorrection is fraction of error correction performed during time step once stop point is reached."""
        return self.__stop1ErrorCorrection
    @stop1ErrorCorrection.setter
    def stop1ErrorCorrection(self, stop1ErrorCorrection):
        if  stop1ErrorCorrection is None:
            stop1ErrorCorrection = 0.8 # default
        assertValidSFFloat(stop1ErrorCorrection)
        self.__stop1ErrorCorrection = stop1ErrorCorrection
    @property # getter - - - - - - - - - -
    def suspensionErrorCorrection(self):
        """[0,1] suspensionErrorCorrection describes how quickly the system resolves intersection errors due to floating-point inaccuracies."""
        return self.__suspensionErrorCorrection
    @suspensionErrorCorrection.setter
    def suspensionErrorCorrection(self, suspensionErrorCorrection):
        if  suspensionErrorCorrection is None:
            suspensionErrorCorrection = 0.8 # default
        assertValidSFFloat(suspensionErrorCorrection)
        self.__suspensionErrorCorrection = suspensionErrorCorrection
    @property # getter - - - - - - - - - -
    def suspensionForce(self):
        """[0,1] suspensionForce describes how quickly the system resolves intersection errors due to floating-point inaccuracies."""
        return self.__suspensionForce
    @suspensionForce.setter
    def suspensionForce(self, suspensionForce):
        if  suspensionForce is None:
            suspensionForce = 0 # default
        assertValidSFFloat(suspensionForce)
        self.__suspensionForce = suspensionForce
    @property # getter - - - - - - - - - -
    def body1(self):
        return self.__body1
    @body1.setter
    def body1(self, body1):
        if  body1 is None:
            body1 = None # default
        assertValidSFNode(body1)
        if not isinstance(body1, object):
            # print(flush=True)
            raise X3DTypeError(str(body1) + ' does not have a valid node type object')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        return self.__body2
    @body2.setter
    def body2(self, body2):
        if  body2 is None:
            body2 = None # default
        assertValidSFNode(body2)
        if not isinstance(body2, object):
            # print(flush=True)
            raise X3DTypeError(str(body2) + ' does not have a valid node type object')
        self.__body2 = body2
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.body1 or self.body2 or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function DoubleAxisHingeJoint.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<DoubleAxisHingeJoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.anchorPoint != (0, 0, 0):
            result += " anchorPoint='" + SFVec3f(self.anchorPoint).XML() + "'"
        if self.axis1 != (0, 0, 0):
            result += " axis1='" + SFVec3f(self.axis1).XML() + "'"
        if self.axis2 != (0, 0, 0):
            result += " axis2='" + SFVec3f(self.axis2).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.desiredAngularVelocity1 != 0:
            result += " desiredAngularVelocity1='" + SFFloat(self.desiredAngularVelocity1).XML() + "'"
        if self.desiredAngularVelocity2 != 0:
            result += " desiredAngularVelocity2='" + SFFloat(self.desiredAngularVelocity2).XML() + "'"
        if self.forceOutput != ["NONE"]:
            result += " forceOutput='" + MFString(self.forceOutput).XML() + "'"
        if self.maxAngle1 != 3.141592653:
            result += " maxAngle1='" + SFFloat(self.maxAngle1).XML() + "'"
        if self.maxTorque1 != 0:
            result += " maxTorque1='" + SFFloat(self.maxTorque1).XML() + "'"
        if self.maxTorque2 != 0:
            result += " maxTorque2='" + SFFloat(self.maxTorque2).XML() + "'"
        if self.minAngle1 != -3.141592653:
            result += " minAngle1='" + SFFloat(self.minAngle1).XML() + "'"
        if self.stop1Bounce != 0:
            result += " stop1Bounce='" + SFFloat(self.stop1Bounce).XML() + "'"
        if self.stop1ConstantForceMix != 0.001:
            result += " stop1ConstantForceMix='" + SFFloat(self.stop1ConstantForceMix).XML() + "'"
        if self.stop1ErrorCorrection != 0.8:
            result += " stop1ErrorCorrection='" + SFFloat(self.stop1ErrorCorrection).XML() + "'"
        if self.suspensionErrorCorrection != 0.8:
            result += " suspensionErrorCorrection='" + SFFloat(self.suspensionErrorCorrection).XML() + "'"
        if self.suspensionForce != 0:
            result += " suspensionForce='" + SFFloat(self.suspensionForce).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></DoubleAxisHingeJoint>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.body1: # output this SFNode
                result += self.body1.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.body2: # output this SFNode
                result += self.body2.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</DoubleAxisHingeJoint>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function DoubleAxisHingeJoint.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'DoubleAxisHingeJoint' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'DoubleAxisHingeJoint' + ' {'
        if self.anchorPoint != (0, 0, 0):
            result += " anchorPoint " + SFVec3f(self.anchorPoint).VRML() + ""
        if self.axis1 != (0, 0, 0):
            result += " axis1 " + SFVec3f(self.axis1).VRML() + ""
        if self.axis2 != (0, 0, 0):
            result += " axis2 " + SFVec3f(self.axis2).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.desiredAngularVelocity1 != 0:
            result += " desiredAngularVelocity1 " + SFFloat(self.desiredAngularVelocity1).VRML() + ""
        if self.desiredAngularVelocity2 != 0:
            result += " desiredAngularVelocity2 " + SFFloat(self.desiredAngularVelocity2).VRML() + ""
        if self.forceOutput != ["NONE"]:
            result += " forceOutput " + MFString(self.forceOutput).VRML() + ""
        if self.maxAngle1 != 3.141592653:
            result += " maxAngle1 " + SFFloat(self.maxAngle1).VRML() + ""
        if self.maxTorque1 != 0:
            result += " maxTorque1 " + SFFloat(self.maxTorque1).VRML() + ""
        if self.maxTorque2 != 0:
            result += " maxTorque2 " + SFFloat(self.maxTorque2).VRML() + ""
        if self.minAngle1 != -3.141592653:
            result += " minAngle1 " + SFFloat(self.minAngle1).VRML() + ""
        if self.stop1Bounce != 0:
            result += " stop1Bounce " + SFFloat(self.stop1Bounce).VRML() + ""
        if self.stop1ConstantForceMix != 0.001:
            result += " stop1ConstantForceMix " + SFFloat(self.stop1ConstantForceMix).VRML() + ""
        if self.stop1ErrorCorrection != 0.8:
            result += " stop1ErrorCorrection " + SFFloat(self.stop1ErrorCorrection).VRML() + ""
        if self.suspensionErrorCorrection != 0.8:
            result += " suspensionErrorCorrection " + SFFloat(self.suspensionErrorCorrection).VRML() + ""
        if self.suspensionForce != 0:
            result += " suspensionForce " + SFFloat(self.suspensionForce).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.body1: # output this SFNode
            result += '\n' + '  ' + indent + 'body1 ' + self.body1.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.body2: # output this SFNode
            result += '\n' + '  ' + indent + 'body2 ' + self.body2.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class DynamicsCompressor(_X3DSoundProcessingNode):
    """
    DynamicsCompressor node implements a dynamics compression effect, lowering volume of loudest parts of signal and raising volume of softest parts.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'DynamicsCompressor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#DynamicsCompressor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#DynamicsCompressor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('attack', 0.003, FieldType.SFFloat, AccessType.inputOutput, 'DynamicsCompressor'),
            ('channelCountMode', 'max', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('channelInterpretation', 'speakers', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('knee', 30, FieldType.SFFloat, AccessType.inputOutput, 'DynamicsCompressor'),
            ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('ratio', 12, FieldType.SFFloat, AccessType.inputOutput, 'DynamicsCompressor'),
            ('release', 0.25, FieldType.SFTime, AccessType.inputOutput, 'DynamicsCompressor'),
            ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('tailTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('threshold', -24, FieldType.SFFloat, AccessType.inputOutput, 'DynamicsCompressor'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 attack=0.003,
                 channelCountMode='max',
                 channelInterpretation='speakers',
                 description='',
                 enabled=True,
                 gain=1,
                 knee=30,
                 pauseTime=0,
                 ratio=12,
                 release=0.25,
                 resumeTime=0,
                 startTime=0,
                 stopTime=0,
                 tailTime=0,
                 threshold=-24,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode DynamicsCompressor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.attack = attack
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.knee = knee
        self.pauseTime = pauseTime
        self.ratio = ratio
        self.release = release
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.tailTime = tailTime
        self.threshold = threshold
    @property # getter - - - - - - - - - -
    def attack(self):
        return self.__attack
    @attack.setter
    def attack(self, attack):
        if  attack is None:
            attack = 0.003 # default
        assertValidSFFloat(attack)
        assertNonNegative('attack', attack)
        self.__attack = attack
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'max' # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'speakers' # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1 # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def knee(self):
        """[0,+infinity) knee field contains a decibel value representing range above threshold where the curve smoothly transitions to compressed portion."""
        return self.__knee
    @knee.setter
    def knee(self, knee):
        if  knee is None:
            knee = 30 # default
        assertValidSFFloat(knee)
        assertNonNegative('knee', knee)
        self.__knee = knee
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0 # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def ratio(self):
        """[0,+infinity) ratio field represents amount of input change, in dB, needed for 1 dB change in output."""
        return self.__ratio
    @ratio.setter
    def ratio(self, ratio):
        if  ratio is None:
            ratio = 12 # default
        assertValidSFFloat(ratio)
        assertGreaterThanEquals('ratio', ratio, 1)
        assertLessThanEquals('ratio', ratio, 20)
        self.__ratio = ratio
    @property # getter - - - - - - - - - -
    def release(self):
        """[0,+infinity) release field represents amount of time (in seconds) to increase gain by 10dB."""
        return self.__release
    @release.setter
    def release(self, release):
        if  release is None:
            release = 0.25 # default
        assertValidSFTime(release)
        assertNonNegative('release', release)
        self.__release = release
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0 # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0 # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0 # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def tailTime(self):
        return self.__tailTime
    @tailTime.setter
    def tailTime(self, tailTime):
        if  tailTime is None:
            tailTime = 0 # default
        assertValidSFTime(tailTime)
        assertNonNegative('tailTime', tailTime)
        self.__tailTime = tailTime
    @property # getter - - - - - - - - - -
    def threshold(self):
        """[0,+infinity) threshold field represents decibel value above which compression starts taking effect."""
        return self.__threshold
    @threshold.setter
    def threshold(self, threshold):
        if  threshold is None:
            threshold = -24 # default
        assertValidSFFloat(threshold)
        assertGreaterThanEquals('threshold', threshold, -100)
        assertLessThanEquals('threshold', threshold, 0)
        self.__threshold = threshold
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function DynamicsCompressor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<DynamicsCompressor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.attack != 0.003:
            result += " attack='" + SFFloat(self.attack).XML() + "'"
        if self.channelCountMode != 'max':
            result += " channelCountMode='" + self.channelCountMode + "'"
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation='" + self.channelInterpretation + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.gain != 1:
            result += " gain='" + SFFloat(self.gain).XML() + "'"
        if self.knee != 30:
            result += " knee='" + SFFloat(self.knee).XML() + "'"
        if self.pauseTime != 0:
            result += " pauseTime='" + SFTime(self.pauseTime).XML() + "'"
        if self.ratio != 12:
            result += " ratio='" + SFFloat(self.ratio).XML() + "'"
        if self.release != 0.25:
            result += " release='" + SFTime(self.release).XML() + "'"
        if self.resumeTime != 0:
            result += " resumeTime='" + SFTime(self.resumeTime).XML() + "'"
        if self.startTime != 0:
            result += " startTime='" + SFTime(self.startTime).XML() + "'"
        if self.stopTime != 0:
            result += " stopTime='" + SFTime(self.stopTime).XML() + "'"
        if self.tailTime != 0:
            result += " tailTime='" + SFTime(self.tailTime).XML() + "'"
        if self.threshold != -24:
            result += " threshold='" + SFFloat(self.threshold).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></DynamicsCompressor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</DynamicsCompressor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function DynamicsCompressor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'DynamicsCompressor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'DynamicsCompressor' + ' {'
        if self.attack != 0.003:
            result += " attack " + SFFloat(self.attack).VRML() + ""
        if self.channelCountMode != 'max':
            result += " channelCountMode " +  '"' + self.channelCountMode + '"' + ""
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation " +  '"' + self.channelInterpretation + '"' + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.gain != 1:
            result += " gain " + SFFloat(self.gain).VRML() + ""
        if self.knee != 30:
            result += " knee " + SFFloat(self.knee).VRML() + ""
        if self.pauseTime != 0:
            result += " pauseTime " + SFTime(self.pauseTime).VRML() + ""
        if self.ratio != 12:
            result += " ratio " + SFFloat(self.ratio).VRML() + ""
        if self.release != 0.25:
            result += " release " + SFTime(self.release).VRML() + ""
        if self.resumeTime != 0:
            result += " resumeTime " + SFTime(self.resumeTime).VRML() + ""
        if self.startTime != 0:
            result += " startTime " + SFTime(self.startTime).VRML() + ""
        if self.stopTime != 0:
            result += " stopTime " + SFTime(self.stopTime).VRML() + ""
        if self.tailTime != 0:
            result += " tailTime " + SFTime(self.tailTime).VRML() + ""
        if self.threshold != -24:
            result += " threshold " + SFFloat(self.threshold).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class EaseInEaseOut(_X3DChildNode):
    """
    EaseInEaseOut enables gradual animation transitions by modifying TimeSensor fraction outputs.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'EaseInEaseOut'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/interpolators.html#EaseInEaseOut'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#EaseInEaseOut'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('easeInEaseOut', list(), FieldType.MFVec2f, AccessType.inputOutput, 'EaseInEaseOut'),
            ('key', list(), FieldType.MFFloat, AccessType.inputOutput, 'EaseInEaseOut'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 easeInEaseOut=list(),
                 key=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode EaseInEaseOut __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.easeInEaseOut = easeInEaseOut
        self.key = key
    @property # getter - - - - - - - - - -
    def easeInEaseOut(self):
        """Array of paired values for easeOut fraction and easeIn fraction within each key interval."""
        return self.__easeInEaseOut
    @easeInEaseOut.setter
    def easeInEaseOut(self, easeInEaseOut):
        if  easeInEaseOut is None:
            easeInEaseOut = MFVec2f.DEFAULT_VALUE(self)
        assertValidMFVec2f(easeInEaseOut)
        self.__easeInEaseOut = easeInEaseOut
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to easeInEaseOut array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(key)
        self.__key = key
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function EaseInEaseOut.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<EaseInEaseOut'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.easeInEaseOut != list():
            result += " easeInEaseOut='" + MFVec2f(self.easeInEaseOut).XML() + "'"
        if self.key != list():
            result += " key='" + MFFloat(self.key).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></EaseInEaseOut>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</EaseInEaseOut>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function EaseInEaseOut.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'EaseInEaseOut' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'EaseInEaseOut' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.easeInEaseOut != list():
            result += " easeInEaseOut " + MFVec2f(self.easeInEaseOut).VRML() + ""
        if self.key != list():
            result += " key " + MFFloat(self.key).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class EdgeEnhancementVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    EdgeEnhancementVolumeStyle specifies edge enhancement for the volume rendering style.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'EdgeEnhancementVolumeStyle'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/volume.html#EdgeEnhancementVolumeStyle'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#EdgeEnhancementVolumeStyle'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('edgeColor', (0, 0, 0, 1), FieldType.SFColorRGBA, AccessType.inputOutput, 'EdgeEnhancementVolumeStyle'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
            ('gradientThreshold', 0.4, FieldType.SFFloat, AccessType.inputOutput, 'EdgeEnhancementVolumeStyle'),
            ('surfaceNormals', None, FieldType.SFNode, AccessType.inputOutput, 'EdgeEnhancementVolumeStyle'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 edgeColor=(0, 0, 0, 1),
                 enabled=True,
                 gradientThreshold=0.4,
                 surfaceNormals=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode EdgeEnhancementVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.edgeColor = edgeColor
        self.enabled = enabled
        self.gradientThreshold = gradientThreshold
        self.surfaceNormals = surfaceNormals
    @property # getter - - - - - - - - - -
    def edgeColor(self):
        """[0,1] color used to highlight edges."""
        return self.__edgeColor
    @edgeColor.setter
    def edgeColor(self, edgeColor):
        if  edgeColor is None:
            edgeColor = (0, 0, 0, 1) # default
        assertValidSFColorRGBA(edgeColor)
        assertZeroToOne('edgeColor', edgeColor)
        self.__edgeColor = edgeColor
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gradientThreshold(self):
        """[0,1] minimum angle (in radians) away from view-direction vector for surface normal before applying enhancement."""
        return self.__gradientThreshold
    @gradientThreshold.setter
    def gradientThreshold(self, gradientThreshold):
        if  gradientThreshold is None:
            gradientThreshold = 0.4 # default
        assertValidSFFloat(gradientThreshold)
        assertGreaterThanEquals('gradientThreshold', gradientThreshold, 0)
        assertLessThanEquals('gradientThreshold', gradientThreshold, 3.1416)
        self.__gradientThreshold = gradientThreshold
    @property # getter - - - - - - - - - -
    def surfaceNormals(self):
        return self.__surfaceNormals
    @surfaceNormals.setter
    def surfaceNormals(self, surfaceNormals):
        if  surfaceNormals is None:
            surfaceNormals = None # default
        assertValidSFNode(surfaceNormals)
        if not isinstance(surfaceNormals, object):
            # print(flush=True)
            raise X3DTypeError(str(surfaceNormals) + ' does not have a valid node type object')
        self.__surfaceNormals = surfaceNormals
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.surfaceNormals
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function EdgeEnhancementVolumeStyle.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<EdgeEnhancementVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.edgeColor != (0, 0, 0, 1):
            result += " edgeColor='" + SFColorRGBA(self.edgeColor).XML() + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.gradientThreshold != 0.4:
            result += " gradientThreshold='" + SFFloat(self.gradientThreshold).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></EdgeEnhancementVolumeStyle>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.surfaceNormals: # output this SFNode
                result += self.surfaceNormals.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</EdgeEnhancementVolumeStyle>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function EdgeEnhancementVolumeStyle.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'EdgeEnhancementVolumeStyle' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'EdgeEnhancementVolumeStyle' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.edgeColor != (0, 0, 0, 1):
            result += " edgeColor " + SFColorRGBA(self.edgeColor).VRML() + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.gradientThreshold != 0.4:
            result += " gradientThreshold " + SFFloat(self.gradientThreshold).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.surfaceNormals: # output this SFNode
            result += '\n' + '  ' + indent + 'surfaceNormals ' + self.surfaceNormals.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ElevationGrid(_X3DGeometryNode):
    """
    ElevationGrid is a geometry node defining a rectangular height field, with default values for a 1m by 1m square at height 0.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ElevationGrid'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geometry3D.html#ElevationGrid'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ElevationGrid'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'ElevationGrid'),
            ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'ElevationGrid'),
            ('creaseAngle', 0, FieldType.SFFloat, AccessType.initializeOnly, 'ElevationGrid'),
            ('height', [0, 0, 0, 0], FieldType.MFFloat, AccessType.initializeOnly, 'ElevationGrid'),
            ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'ElevationGrid'),
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'ElevationGrid'),
            ('xDimension', 2, FieldType.SFInt32, AccessType.initializeOnly, 'ElevationGrid'),
            ('xSpacing', 1.0, FieldType.SFFloat, AccessType.initializeOnly, 'ElevationGrid'),
            ('zDimension', 2, FieldType.SFInt32, AccessType.initializeOnly, 'ElevationGrid'),
            ('zSpacing', 1.0, FieldType.SFFloat, AccessType.initializeOnly, 'ElevationGrid'),
            ('color', None, FieldType.SFNode, AccessType.inputOutput, 'ElevationGrid'),
            ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'ElevationGrid'),
            ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'ElevationGrid'),
            ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'ElevationGrid'),
            ('attrib', list(), FieldType.MFNode, AccessType.inputOutput, 'ElevationGrid'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 creaseAngle=0,
                 height=[0, 0, 0, 0],
                 normalPerVertex=True,
                 solid=True,
                 xDimension=2,
                 xSpacing=1.0,
                 zDimension=2,
                 zSpacing=1.0,
                 color=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ElevationGrid __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.creaseAngle = creaseAngle
        self.height = height
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.xDimension = xDimension
        self.xSpacing = xSpacing
        self.zDimension = zDimension
        self.zSpacing = zSpacing
        self.color = color
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color node color values are applied to each point vertex (true) or per quadrilateral (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def creaseAngle(self):
        """[0,+infinity) creaseAngle defines angle (in radians) for determining whether adjacent polygons are drawn with sharp edges or smooth shading."""
        return self.__creaseAngle
    @creaseAngle.setter
    def creaseAngle(self, creaseAngle):
        if  creaseAngle is None:
            creaseAngle = 0 # default
        assertValidSFFloat(creaseAngle)
        assertNonNegative('creaseAngle', creaseAngle)
        self.__creaseAngle = creaseAngle
    @property # getter - - - - - - - - - -
    def height(self):
        """Grid array of height vertices with upward direction along +Y axis, with xDimension rows and zDimension columns."""
        return self.__height
    @height.setter
    def height(self, height):
        if  height is None:
            height = [0, 0, 0, 0] # default
        assertValidMFFloat(height)
        self.__height = height
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or per quadrilateral (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def xDimension(self):
        """(0,+infinity) Number of elements in the height array along X direction."""
        return self.__xDimension
    @xDimension.setter
    def xDimension(self, xDimension):
        if  xDimension is None:
            xDimension = 2 # default
        assertValidSFInt32(xDimension)
        assertNonNegative('xDimension', xDimension)
        self.__xDimension = xDimension
    @property # getter - - - - - - - - - -
    def xSpacing(self):
        """(0,+infinity) Meters distance between grid-array vertices along X direction."""
        return self.__xSpacing
    @xSpacing.setter
    def xSpacing(self, xSpacing):
        if  xSpacing is None:
            xSpacing = 1.0 # default
        assertValidSFFloat(xSpacing)
        assertPositive('xSpacing', xSpacing)
        self.__xSpacing = xSpacing
    @property # getter - - - - - - - - - -
    def zDimension(self):
        """(0,+infinity) Number of elements in the height array along Z direction."""
        return self.__zDimension
    @zDimension.setter
    def zDimension(self, zDimension):
        if  zDimension is None:
            zDimension = 2 # default
        assertValidSFInt32(zDimension)
        assertNonNegative('zDimension', zDimension)
        self.__zDimension = zDimension
    @property # getter - - - - - - - - - -
    def zSpacing(self):
        """(0,+infinity) Meters distance between grid-array vertices along Z direction."""
        return self.__zSpacing
    @zSpacing.setter
    def zSpacing(self, zSpacing):
        if  zSpacing is None:
            zSpacing = 1.0 # default
        assertValidSFFloat(zSpacing)
        assertPositive('zSpacing', zSpacing)
        self.__zSpacing = zSpacing
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that specifies color values applied to corresponding vertices according to colorPerVertex field."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None # default
        assertValidSFNode(color)
        if not isinstance(color, object):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that specifies depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None # default
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that specifies perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None # default
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that specifies coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None # default
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that specifies list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.attrib or self.color or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ElevationGrid.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ElevationGrid'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.ccw: # default=true
            result += " ccw='" + SFBool(self.ccw).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex='" + SFBool(self.colorPerVertex).XML() + "'"
        if self.creaseAngle != 0:
            result += " creaseAngle='" + SFFloat(self.creaseAngle).XML() + "'"
        if self.height != [0, 0, 0, 0]:
            result += " height='" + MFFloat(self.height).XML() + "'"
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex='" + SFBool(self.normalPerVertex).XML() + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if self.xDimension != 2:
            result += " xDimension='" + SFInt32(self.xDimension).XML() + "'"
        if self.xSpacing != 1.0:
            result += " xSpacing='" + SFFloat(self.xSpacing).XML() + "'"
        if self.zDimension != 2:
            result += " zDimension='" + SFInt32(self.zDimension).XML() + "'"
        if self.zSpacing != 1.0:
            result += " zSpacing='" + SFFloat(self.zSpacing).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ElevationGrid>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.color: # output this SFNode
                result += self.color.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.fogCoord: # output this SFNode
                result += self.fogCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.normal: # output this SFNode
                result += self.normal.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.texCoord: # output this SFNode
                result += self.texCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.attrib: # walk each child in MFNode list, if any
            ### print('* ElevationGrid found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(attrib)=' + str(len(self.attrib)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.attrib:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ElevationGrid>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ElevationGrid.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ElevationGrid' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ElevationGrid' + ' {'
        if not self.ccw: # default=true
            result += " ccw " + SFBool(self.ccw).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex " + SFBool(self.colorPerVertex).VRML() + ""
        if self.creaseAngle != 0:
            result += " creaseAngle " + SFFloat(self.creaseAngle).VRML() + ""
        if self.height != [0, 0, 0, 0]:
            result += " height " + MFFloat(self.height).VRML() + ""
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex " + SFBool(self.normalPerVertex).VRML() + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.xDimension != 2:
            result += " xDimension " + SFInt32(self.xDimension).VRML() + ""
        if self.xSpacing != 1.0:
            result += " xSpacing " + SFFloat(self.xSpacing).VRML() + ""
        if self.zDimension != 2:
            result += " zDimension " + SFInt32(self.zDimension).VRML() + ""
        if self.zSpacing != 1.0:
            result += " zSpacing " + SFFloat(self.zSpacing).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.color: # output this SFNode
            result += '\n' + '  ' + indent + 'color ' + self.color.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.fogCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'fogCoord ' + self.fogCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.normal: # output this SFNode
            result += '\n' + '  ' + indent + 'normal ' + self.normal.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'texCoord ' + self.texCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.attrib: # walk each child in MFNode list, if any
            for each in self.attrib:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class EspduTransform(_X3DGroupingNode, _X3DNetworkSensorNode):
    """
    EspduTransform is a networked Transform node that can contain most nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'EspduTransform'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/dis.html#EspduTransform'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#EspduTransform'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('address', 'localhost', FieldType.SFString, AccessType.inputOutput, 'EspduTransform'),
            ('applicationID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('articulationParameterArray', list(), FieldType.MFFloat, AccessType.inputOutput, 'EspduTransform'),
            ('articulationParameterChangeIndicatorArray', list(), FieldType.MFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('articulationParameterCount', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('articulationParameterDesignatorArray', list(), FieldType.MFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('articulationParameterIdPartAttachedToArray', list(), FieldType.MFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('articulationParameterTypeArray', list(), FieldType.MFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'EspduTransform'),
            ('collisionType', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('deadReckoning', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('detonationLocation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'EspduTransform'),
            ('detonationRelativeLocation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'EspduTransform'),
            ('detonationResult', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'EspduTransform'),
            ('entityCategory', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('entityCountry', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('entityDomain', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('entityExtra', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('entityID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('entityKind', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('entitySpecific', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('entitySubcategory', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('eventApplicationID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('eventEntityID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('eventNumber', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('eventSiteID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('fired1', False, FieldType.SFBool, AccessType.inputOutput, 'EspduTransform'),
            ('fired2', False, FieldType.SFBool, AccessType.inputOutput, 'EspduTransform'),
            ('fireMissionIndex', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('firingRange', 0, FieldType.SFFloat, AccessType.inputOutput, 'EspduTransform'),
            ('firingRate', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('forceID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('fuse', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('geoCoords', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'EspduTransform'),
            ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'EspduTransform'),
            ('linearAcceleration', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'EspduTransform'),
            ('linearVelocity', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'EspduTransform'),
            ('marking', '', FieldType.SFString, AccessType.inputOutput, 'EspduTransform'),
            ('multicastRelayHost', '', FieldType.SFString, AccessType.inputOutput, 'EspduTransform'),
            ('multicastRelayPort', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('munitionApplicationID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('munitionEndPoint', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'EspduTransform'),
            ('munitionEntityID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('munitionQuantity', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('munitionSiteID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('munitionStartPoint', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'EspduTransform'),
            ('networkMode', 'standAlone', FieldType.SFString, AccessType.inputOutput, 'EspduTransform'),
            ('port', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('readInterval', 0.1, FieldType.SFTime, AccessType.inputOutput, 'EspduTransform'),
            ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'EspduTransform'),
            ('rtpHeaderExpected', False, FieldType.SFBool, AccessType.initializeOnly, 'EspduTransform'),
            ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'EspduTransform'),
            ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'EspduTransform'),
            ('siteID', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'EspduTransform'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('warhead', 0, FieldType.SFInt32, AccessType.inputOutput, 'EspduTransform'),
            ('writeInterval', 1.0, FieldType.SFTime, AccessType.inputOutput, 'EspduTransform'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 address='localhost',
                 applicationID=0,
                 articulationParameterArray=list(),
                 articulationParameterChangeIndicatorArray=list(),
                 articulationParameterCount=0,
                 articulationParameterDesignatorArray=list(),
                 articulationParameterIdPartAttachedToArray=list(),
                 articulationParameterTypeArray=list(),
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 center=(0, 0, 0),
                 collisionType=0,
                 deadReckoning=0,
                 detonationLocation=(0, 0, 0),
                 detonationRelativeLocation=(0, 0, 0),
                 detonationResult=0,
                 enabled=True,
                 entityCategory=0,
                 entityCountry=0,
                 entityDomain=0,
                 entityExtra=0,
                 entityID=0,
                 entityKind=0,
                 entitySpecific=0,
                 entitySubcategory=0,
                 eventApplicationID=0,
                 eventEntityID=0,
                 eventNumber=0,
                 eventSiteID=0,
                 fired1=False,
                 fired2=False,
                 fireMissionIndex=0,
                 firingRange=0,
                 firingRate=0,
                 forceID=0,
                 fuse=0,
                 geoCoords=(0, 0, 0),
                 geoSystem=["GD", "WE"],
                 linearAcceleration=(0, 0, 0),
                 linearVelocity=(0, 0, 0),
                 marking='',
                 multicastRelayHost='',
                 multicastRelayPort=0,
                 munitionApplicationID=0,
                 munitionEndPoint=(0, 0, 0),
                 munitionEntityID=0,
                 munitionQuantity=0,
                 munitionSiteID=0,
                 munitionStartPoint=(0, 0, 0),
                 networkMode='standAlone',
                 port=0,
                 readInterval=0.1,
                 rotation=(0, 0, 1, 0),
                 rtpHeaderExpected=False,
                 scale=(1, 1, 1),
                 scaleOrientation=(0, 0, 1, 0),
                 siteID=0,
                 translation=(0, 0, 0),
                 visible=True,
                 warhead=0,
                 writeInterval=1.0,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode EspduTransform __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.address = address
        self.applicationID = applicationID
        self.articulationParameterArray = articulationParameterArray
        self.articulationParameterChangeIndicatorArray = articulationParameterChangeIndicatorArray
        self.articulationParameterCount = articulationParameterCount
        self.articulationParameterDesignatorArray = articulationParameterDesignatorArray
        self.articulationParameterIdPartAttachedToArray = articulationParameterIdPartAttachedToArray
        self.articulationParameterTypeArray = articulationParameterTypeArray
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.center = center
        self.collisionType = collisionType
        self.deadReckoning = deadReckoning
        self.detonationLocation = detonationLocation
        self.detonationRelativeLocation = detonationRelativeLocation
        self.detonationResult = detonationResult
        self.enabled = enabled
        self.entityCategory = entityCategory
        self.entityCountry = entityCountry
        self.entityDomain = entityDomain
        self.entityExtra = entityExtra
        self.entityID = entityID
        self.entityKind = entityKind
        self.entitySpecific = entitySpecific
        self.entitySubcategory = entitySubcategory
        self.eventApplicationID = eventApplicationID
        self.eventEntityID = eventEntityID
        self.eventNumber = eventNumber
        self.eventSiteID = eventSiteID
        self.fired1 = fired1
        self.fired2 = fired2
        self.fireMissionIndex = fireMissionIndex
        self.firingRange = firingRange
        self.firingRate = firingRate
        self.forceID = forceID
        self.fuse = fuse
        self.geoCoords = geoCoords
        self.geoSystem = geoSystem
        self.linearAcceleration = linearAcceleration
        self.linearVelocity = linearVelocity
        self.marking = marking
        self.multicastRelayHost = multicastRelayHost
        self.multicastRelayPort = multicastRelayPort
        self.munitionApplicationID = munitionApplicationID
        self.munitionEndPoint = munitionEndPoint
        self.munitionEntityID = munitionEntityID
        self.munitionQuantity = munitionQuantity
        self.munitionSiteID = munitionSiteID
        self.munitionStartPoint = munitionStartPoint
        self.networkMode = networkMode
        self.port = port
        self.readInterval = readInterval
        self.rotation = rotation
        self.rtpHeaderExpected = rtpHeaderExpected
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.siteID = siteID
        self.translation = translation
        self.visible = visible
        self.warhead = warhead
        self.writeInterval = writeInterval
        self.children = children
    @property # getter - - - - - - - - - -
    def address(self):
        """Multicast network address, or else "localhost" Example: 224."""
        return self.__address
    @address.setter
    def address(self, address):
        if  address is None:
            address = 'localhost' # default
        assertValidSFString(address)
        self.__address = address
    @property # getter - - - - - - - - - -
    def applicationID(self):
        """Simulation/exercise applicationID is unique for application at that site."""
        return self.__applicationID
    @applicationID.setter
    def applicationID(self, applicationID):
        if  applicationID is None:
            applicationID = 0 # default
        assertValidSFInt32(applicationID)
        self.__applicationID = applicationID
    @property # getter - - - - - - - - - -
    def articulationParameterArray(self):
        """Information required for representation of the entity's visual appearance and position of its articulated parts."""
        return self.__articulationParameterArray
    @articulationParameterArray.setter
    def articulationParameterArray(self, articulationParameterArray):
        if  articulationParameterArray is None:
            articulationParameterArray = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(articulationParameterArray)
        self.__articulationParameterArray = articulationParameterArray
    @property # getter - - - - - - - - - -
    def articulationParameterChangeIndicatorArray(self):
        """Array of change counters, each incremented when an articulated parameter is updated."""
        return self.__articulationParameterChangeIndicatorArray
    @articulationParameterChangeIndicatorArray.setter
    def articulationParameterChangeIndicatorArray(self, articulationParameterChangeIndicatorArray):
        if  articulationParameterChangeIndicatorArray is None:
            articulationParameterChangeIndicatorArray = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(articulationParameterChangeIndicatorArray)
        self.__articulationParameterChangeIndicatorArray = articulationParameterChangeIndicatorArray
    @property # getter - - - - - - - - - -
    def articulationParameterCount(self):
        """Number of articulated parameters attached to this entity state PDU."""
        return self.__articulationParameterCount
    @articulationParameterCount.setter
    def articulationParameterCount(self, articulationParameterCount):
        if  articulationParameterCount is None:
            articulationParameterCount = 0 # default
        assertValidSFInt32(articulationParameterCount)
        self.__articulationParameterCount = articulationParameterCount
    @property # getter - - - - - - - - - -
    def articulationParameterDesignatorArray(self):
        """Array of designators for each articulated parameter."""
        return self.__articulationParameterDesignatorArray
    @articulationParameterDesignatorArray.setter
    def articulationParameterDesignatorArray(self, articulationParameterDesignatorArray):
        if  articulationParameterDesignatorArray is None:
            articulationParameterDesignatorArray = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(articulationParameterDesignatorArray)
        self.__articulationParameterDesignatorArray = articulationParameterDesignatorArray
    @property # getter - - - - - - - - - -
    def articulationParameterIdPartAttachedToArray(self):
        """Array of ID parts that each articulated parameter is attached to."""
        return self.__articulationParameterIdPartAttachedToArray
    @articulationParameterIdPartAttachedToArray.setter
    def articulationParameterIdPartAttachedToArray(self, articulationParameterIdPartAttachedToArray):
        if  articulationParameterIdPartAttachedToArray is None:
            articulationParameterIdPartAttachedToArray = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(articulationParameterIdPartAttachedToArray)
        self.__articulationParameterIdPartAttachedToArray = articulationParameterIdPartAttachedToArray
    @property # getter - - - - - - - - - -
    def articulationParameterTypeArray(self):
        """Array of type enumerations for each articulated parameter element."""
        return self.__articulationParameterTypeArray
    @articulationParameterTypeArray.setter
    def articulationParameterTypeArray(self, articulationParameterTypeArray):
        if  articulationParameterTypeArray is None:
            articulationParameterTypeArray = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(articulationParameterTypeArray)
        self.__articulationParameterTypeArray = articulationParameterTypeArray
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        """Translation offset from origin of local coordinate system."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0) # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def collisionType(self):
        """Integer enumeration for type of collision: ELASTIC or INELASTIC."""
        return self.__collisionType
    @collisionType.setter
    def collisionType(self, collisionType):
        if  collisionType is None:
            collisionType = 0 # default
        assertValidSFInt32(collisionType)
        self.__collisionType = collisionType
    @property # getter - - - - - - - - - -
    def deadReckoning(self):
        """Dead reckoning algorithm being used to project position/orientation with velocities/accelerations."""
        return self.__deadReckoning
    @deadReckoning.setter
    def deadReckoning(self, deadReckoning):
        if  deadReckoning is None:
            deadReckoning = 0 # default
        assertValidSFInt32(deadReckoning)
        self.__deadReckoning = deadReckoning
    @property # getter - - - - - - - - - -
    def detonationLocation(self):
        """World coordinates for detonationLocation."""
        return self.__detonationLocation
    @detonationLocation.setter
    def detonationLocation(self, detonationLocation):
        if  detonationLocation is None:
            detonationLocation = (0, 0, 0) # default
        assertValidSFVec3f(detonationLocation)
        self.__detonationLocation = detonationLocation
    @property # getter - - - - - - - - - -
    def detonationRelativeLocation(self):
        """Relative coordinates for detonation location."""
        return self.__detonationRelativeLocation
    @detonationRelativeLocation.setter
    def detonationRelativeLocation(self, detonationRelativeLocation):
        if  detonationRelativeLocation is None:
            detonationRelativeLocation = (0, 0, 0) # default
        assertValidSFVec3f(detonationRelativeLocation)
        self.__detonationRelativeLocation = detonationRelativeLocation
    @property # getter - - - - - - - - - -
    def detonationResult(self):
        """Integer enumeration for type of detonation and result that occurred."""
        return self.__detonationResult
    @detonationResult.setter
    def detonationResult(self, detonationResult):
        if  detonationResult is None:
            detonationResult = 0 # default
        assertValidSFInt32(detonationResult)
        self.__detonationResult = detonationResult
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables the sensor node."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def entityCategory(self):
        """Integer enumerations value for main category that describes the entity, semantics of each code varies according to domain."""
        return self.__entityCategory
    @entityCategory.setter
    def entityCategory(self, entityCategory):
        if  entityCategory is None:
            entityCategory = 0 # default
        assertValidSFInt32(entityCategory)
        self.__entityCategory = entityCategory
    @property # getter - - - - - - - - - -
    def entityCountry(self):
        """Integer enumerations value for country to which the design of the entity or its design specification is attributed."""
        return self.__entityCountry
    @entityCountry.setter
    def entityCountry(self, entityCountry):
        if  entityCountry is None:
            entityCountry = 0 # default
        assertValidSFInt32(entityCountry)
        self.__entityCountry = entityCountry
    @property # getter - - - - - - - - - -
    def entityDomain(self):
        """Integer enumerations value for domain in which the entity operates: LAND, AIR, SURFACE, SUBSURFACE, SPACE or OTHER."""
        return self.__entityDomain
    @entityDomain.setter
    def entityDomain(self, entityDomain):
        if  entityDomain is None:
            entityDomain = 0 # default
        assertValidSFInt32(entityDomain)
        self.__entityDomain = entityDomain
    @property # getter - - - - - - - - - -
    def entityExtra(self):
        """Any extra information required to describe a particular entity."""
        return self.__entityExtra
    @entityExtra.setter
    def entityExtra(self, entityExtra):
        if  entityExtra is None:
            entityExtra = 0 # default
        assertValidSFInt32(entityExtra)
        self.__entityExtra = entityExtra
    @property # getter - - - - - - - - - -
    def entityID(self):
        """Simulation/exercise entityID is a unique ID for a single entity within that application."""
        return self.__entityID
    @entityID.setter
    def entityID(self, entityID):
        if  entityID is None:
            entityID = 0 # default
        assertValidSFInt32(entityID)
        self.__entityID = entityID
    @property # getter - - - - - - - - - -
    def entityKind(self):
        """Integer enumerations value for whether entity is a PLATFORM, MUNITION, LIFE_FORM, ENVIRONMENTAL, CULTURAL_FEATURE, SUPPLY, RADIO, EXPENDABLE, SENSOR_EMITTER or OTHER."""
        return self.__entityKind
    @entityKind.setter
    def entityKind(self, entityKind):
        if  entityKind is None:
            entityKind = 0 # default
        assertValidSFInt32(entityKind)
        self.__entityKind = entityKind
    @property # getter - - - - - - - - - -
    def entitySpecific(self):
        """Specific information about an entity based on the Subcategory field."""
        return self.__entitySpecific
    @entitySpecific.setter
    def entitySpecific(self, entitySpecific):
        if  entitySpecific is None:
            entitySpecific = 0 # default
        assertValidSFInt32(entitySpecific)
        self.__entitySpecific = entitySpecific
    @property # getter - - - - - - - - - -
    def entitySubcategory(self):
        return self.__entitySubcategory
    @entitySubcategory.setter
    def entitySubcategory(self, entitySubcategory):
        if  entitySubcategory is None:
            entitySubcategory = 0 # default
        assertValidSFInt32(entitySubcategory)
        self.__entitySubcategory = entitySubcategory
    @property # getter - - - - - - - - - -
    def eventApplicationID(self):
        """Simulation/exercise eventApplicationID is unique for events generated from application at that site."""
        return self.__eventApplicationID
    @eventApplicationID.setter
    def eventApplicationID(self, eventApplicationID):
        if  eventApplicationID is None:
            eventApplicationID = 0 # default
        assertValidSFInt32(eventApplicationID)
        self.__eventApplicationID = eventApplicationID
    @property # getter - - - - - - - - - -
    def eventEntityID(self):
        """For a given event, simulation/exercise entityID is a unique ID for a single entity within that application."""
        return self.__eventEntityID
    @eventEntityID.setter
    def eventEntityID(self, eventEntityID):
        if  eventEntityID is None:
            eventEntityID = 0 # default
        assertValidSFInt32(eventEntityID)
        self.__eventEntityID = eventEntityID
    @property # getter - - - - - - - - - -
    def eventNumber(self):
        """Sequential number of each event issued by an application."""
        return self.__eventNumber
    @eventNumber.setter
    def eventNumber(self, eventNumber):
        if  eventNumber is None:
            eventNumber = 0 # default
        assertValidSFInt32(eventNumber)
        self.__eventNumber = eventNumber
    @property # getter - - - - - - - - - -
    def eventSiteID(self):
        """Simulation/exercise siteID of the participating LAN or organization."""
        return self.__eventSiteID
    @eventSiteID.setter
    def eventSiteID(self, eventSiteID):
        if  eventSiteID is None:
            eventSiteID = 0 # default
        assertValidSFInt32(eventSiteID)
        self.__eventSiteID = eventSiteID
    @property # getter - - - - - - - - - -
    def fired1(self):
        """Has the primary weapon (Fire PDU) been fired?."""
        return self.__fired1
    @fired1.setter
    def fired1(self, fired1):
        if  fired1 is None:
            fired1 = False # default
        assertValidSFBool(fired1)
        self.__fired1 = fired1
    @property # getter - - - - - - - - - -
    def fired2(self):
        """Has the secondary weapon (Fire PDU) been fired?."""
        return self.__fired2
    @fired2.setter
    def fired2(self, fired2):
        if  fired2 is None:
            fired2 = False # default
        assertValidSFBool(fired2)
        self.__fired2 = fired2
    @property # getter - - - - - - - - - -
    def fireMissionIndex(self):
        """."""
        return self.__fireMissionIndex
    @fireMissionIndex.setter
    def fireMissionIndex(self, fireMissionIndex):
        if  fireMissionIndex is None:
            fireMissionIndex = 0 # default
        assertValidSFInt32(fireMissionIndex)
        self.__fireMissionIndex = fireMissionIndex
    @property # getter - - - - - - - - - -
    def firingRange(self):
        """Range (three dimension, straight-line distance) that the firing entity's fire control system has assumed for computing the fire control solution if a weapon and if the value is known."""
        return self.__firingRange
    @firingRange.setter
    def firingRange(self, firingRange):
        if  firingRange is None:
            firingRange = 0 # default
        assertValidSFFloat(firingRange)
        self.__firingRange = firingRange
    @property # getter - - - - - - - - - -
    def firingRate(self):
        """Rate at which munitions are fired."""
        return self.__firingRate
    @firingRate.setter
    def firingRate(self, firingRate):
        if  firingRate is None:
            firingRate = 0 # default
        assertValidSFInt32(firingRate)
        self.__firingRate = firingRate
    @property # getter - - - - - - - - - -
    def forceID(self):
        """forceID determines the team membership of the issuing entity, and whether FRIENDLY OPPOSING or NEUTRAL or OTHER."""
        return self.__forceID
    @forceID.setter
    def forceID(self, forceID):
        if  forceID is None:
            forceID = 0 # default
        assertValidSFInt32(forceID)
        self.__forceID = forceID
    @property # getter - - - - - - - - - -
    def fuse(self):
        """Integer enumerations value for type of fuse on the munition."""
        return self.__fuse
    @fuse.setter
    def fuse(self, fuse):
        if  fuse is None:
            fuse = 0 # default
        assertValidSFInt32(fuse)
        self.__fuse = fuse
    @property # getter - - - - - - - - - -
    def geoCoords(self):
        """Geographic location (specified in current geoSystem coordinates) for children geometry (specified in relative coordinate system, in meters)."""
        return self.__geoCoords
    @geoCoords.setter
    def geoCoords(self, geoCoords):
        if  geoCoords is None:
            geoCoords = (0, 0, 0) # default
        assertValidSFVec3d(geoCoords)
        self.__geoCoords = geoCoords
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"] # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def linearAcceleration(self):
        """Acceleration of the entity relative to the rotating Earth in either world or entity coordinates, depending on the dead reckoning algorithm used."""
        return self.__linearAcceleration
    @linearAcceleration.setter
    def linearAcceleration(self, linearAcceleration):
        if  linearAcceleration is None:
            linearAcceleration = (0, 0, 0) # default
        assertValidSFVec3f(linearAcceleration)
        self.__linearAcceleration = linearAcceleration
    @property # getter - - - - - - - - - -
    def linearVelocity(self):
        """Velocity of the entity relative to the rotating Earth in either world or entity coordinates, depending on the dead reckoning algorithm used."""
        return self.__linearVelocity
    @linearVelocity.setter
    def linearVelocity(self, linearVelocity):
        if  linearVelocity is None:
            linearVelocity = (0, 0, 0) # default
        assertValidSFVec3f(linearVelocity)
        self.__linearVelocity = linearVelocity
    @property # getter - - - - - - - - - -
    def marking(self):
        """Maximum of 11 characters for simple entity label."""
        return self.__marking
    @marking.setter
    def marking(self, marking):
        if  marking is None:
            marking = SFString.DEFAULT_VALUE(self)
        assertValidSFString(marking)
        self.__marking = marking
    @property # getter - - - - - - - - - -
    def multicastRelayHost(self):
        """Fallback server address if multicast not available locally."""
        return self.__multicastRelayHost
    @multicastRelayHost.setter
    def multicastRelayHost(self, multicastRelayHost):
        if  multicastRelayHost is None:
            multicastRelayHost = SFString.DEFAULT_VALUE(self)
        assertValidSFString(multicastRelayHost)
        self.__multicastRelayHost = multicastRelayHost
    @property # getter - - - - - - - - - -
    def multicastRelayPort(self):
        """Fallback server port if multicast not available locally."""
        return self.__multicastRelayPort
    @multicastRelayPort.setter
    def multicastRelayPort(self, multicastRelayPort):
        if  multicastRelayPort is None:
            multicastRelayPort = 0 # default
        assertValidSFInt32(multicastRelayPort)
        self.__multicastRelayPort = multicastRelayPort
    @property # getter - - - - - - - - - -
    def munitionApplicationID(self):
        """munitionApplicationID, unique for application at that site."""
        return self.__munitionApplicationID
    @munitionApplicationID.setter
    def munitionApplicationID(self, munitionApplicationID):
        if  munitionApplicationID is None:
            munitionApplicationID = 0 # default
        assertValidSFInt32(munitionApplicationID)
        self.__munitionApplicationID = munitionApplicationID
    @property # getter - - - - - - - - - -
    def munitionEndPoint(self):
        """Final point of the munition path from firing weapon to detonation or impact, in exercise coordinates."""
        return self.__munitionEndPoint
    @munitionEndPoint.setter
    def munitionEndPoint(self, munitionEndPoint):
        if  munitionEndPoint is None:
            munitionEndPoint = (0, 0, 0) # default
        assertValidSFVec3f(munitionEndPoint)
        self.__munitionEndPoint = munitionEndPoint
    @property # getter - - - - - - - - - -
    def munitionEntityID(self):
        """munitionEntityID is unique ID for entity firing munition within that application."""
        return self.__munitionEntityID
    @munitionEntityID.setter
    def munitionEntityID(self, munitionEntityID):
        if  munitionEntityID is None:
            munitionEntityID = 0 # default
        assertValidSFInt32(munitionEntityID)
        self.__munitionEntityID = munitionEntityID
    @property # getter - - - - - - - - - -
    def munitionQuantity(self):
        """Quantity of munitions fired."""
        return self.__munitionQuantity
    @munitionQuantity.setter
    def munitionQuantity(self, munitionQuantity):
        if  munitionQuantity is None:
            munitionQuantity = 0 # default
        assertValidSFInt32(munitionQuantity)
        self.__munitionQuantity = munitionQuantity
    @property # getter - - - - - - - - - -
    def munitionSiteID(self):
        """Munition siteID of the participating LAN or organization."""
        return self.__munitionSiteID
    @munitionSiteID.setter
    def munitionSiteID(self, munitionSiteID):
        if  munitionSiteID is None:
            munitionSiteID = 0 # default
        assertValidSFInt32(munitionSiteID)
        self.__munitionSiteID = munitionSiteID
    @property # getter - - - - - - - - - -
    def munitionStartPoint(self):
        """Initial point of the munition path from firing weapon to detonation or impact, in exercise coordinates."""
        return self.__munitionStartPoint
    @munitionStartPoint.setter
    def munitionStartPoint(self, munitionStartPoint):
        if  munitionStartPoint is None:
            munitionStartPoint = (0, 0, 0) # default
        assertValidSFVec3f(munitionStartPoint)
        self.__munitionStartPoint = munitionStartPoint
    @property # getter - - - - - - - - - -
    def networkMode(self):
        """Whether this entity is ignoring the network, sending DIS packets to the network, or receiving DIS packets from the network."""
        return self.__networkMode
    @networkMode.setter
    def networkMode(self, networkMode):
        if  networkMode is None:
            networkMode = 'standAlone' # default
        assertValidSFString(networkMode)
        assertValidNetworkMode('networkMode', networkMode)
        self.__networkMode = networkMode
    @property # getter - - - - - - - - - -
    def port(self):
        """Network connection port number (EXAMPLE 3000) for sending or receiving DIS messages."""
        return self.__port
    @port.setter
    def port(self, port):
        if  port is None:
            port = 0 # default
        assertValidSFInt32(port)
        self.__port = port
    @property # getter - - - - - - - - - -
    def readInterval(self):
        """[0,+infinity) Seconds between read updates, 0 means no reading."""
        return self.__readInterval
    @readInterval.setter
    def readInterval(self, readInterval):
        if  readInterval is None:
            readInterval = 0.1 # default
        assertValidSFTime(readInterval)
        assertNonNegative('readInterval', readInterval)
        self.__readInterval = readInterval
    @property # getter - - - - - - - - - -
    def rotation(self):
        """Orientation of children relative to local coordinate system, usually read from (or written to) remote, networked EspduTransform nodes."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0) # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def rtpHeaderExpected(self):
        """Whether RTP headers are prepended to DIS PDUs."""
        return self.__rtpHeaderExpected
    @rtpHeaderExpected.setter
    def rtpHeaderExpected(self, rtpHeaderExpected):
        if  rtpHeaderExpected is None:
            rtpHeaderExpected = False # default
        assertValidSFBool(rtpHeaderExpected)
        self.__rtpHeaderExpected = rtpHeaderExpected
    @property # getter - - - - - - - - - -
    def scale(self):
        """Non-uniform x-y-z scale of child coordinate system, adjusted by center and scaleOrientation."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = (1, 1, 1) # default
        assertValidSFVec3f(scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        """Preliminary rotation of coordinate system before scaling (to allow scaling around arbitrary orientations)."""
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation):
        if  scaleOrientation is None:
            scaleOrientation = (0, 0, 1, 0) # default
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def siteID(self):
        """Simulation/exercise siteID of the participating LAN or organization."""
        return self.__siteID
    @siteID.setter
    def siteID(self, siteID):
        if  siteID is None:
            siteID = 0 # default
        assertValidSFInt32(siteID)
        self.__siteID = siteID
    @property # getter - - - - - - - - - -
    def translation(self):
        """Position of children relative to local coordinate system, usually read from (or written to) remote, networked EspduTransform nodes."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0) # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def warhead(self):
        """Integer enumerations value for type of warhead on the munition."""
        return self.__warhead
    @warhead.setter
    def warhead(self, warhead):
        if  warhead is None:
            warhead = 0 # default
        assertValidSFInt32(warhead)
        self.__warhead = warhead
    @property # getter - - - - - - - - - -
    def writeInterval(self):
        """[0,+infinity) Seconds between write updates, 0 means no writing (sending)."""
        return self.__writeInterval
    @writeInterval.setter
    def writeInterval(self, writeInterval):
        if  writeInterval is None:
            writeInterval = 1.0 # default
        assertValidSFTime(writeInterval)
        assertNonNegative('writeInterval', writeInterval)
        self.__writeInterval = writeInterval
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function EspduTransform.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<EspduTransform'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.address != 'localhost':
            result += " address='" + self.address + "'"
        if self.applicationID != 0:
            result += " applicationID='" + SFInt32(self.applicationID).XML() + "'"
        if self.articulationParameterArray != list():
            result += " articulationParameterArray='" + MFFloat(self.articulationParameterArray).XML() + "'"
        if self.articulationParameterChangeIndicatorArray != list():
            result += " articulationParameterChangeIndicatorArray='" + MFInt32(self.articulationParameterChangeIndicatorArray).XML() + "'"
        if self.articulationParameterCount != 0:
            result += " articulationParameterCount='" + SFInt32(self.articulationParameterCount).XML() + "'"
        if self.articulationParameterDesignatorArray != list():
            result += " articulationParameterDesignatorArray='" + MFInt32(self.articulationParameterDesignatorArray).XML() + "'"
        if self.articulationParameterIdPartAttachedToArray != list():
            result += " articulationParameterIdPartAttachedToArray='" + MFInt32(self.articulationParameterIdPartAttachedToArray).XML() + "'"
        if self.articulationParameterTypeArray != list():
            result += " articulationParameterTypeArray='" + MFInt32(self.articulationParameterTypeArray).XML() + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.center != (0, 0, 0):
            result += " center='" + SFVec3f(self.center).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.collisionType != 0:
            result += " collisionType='" + SFInt32(self.collisionType).XML() + "'"
        if self.deadReckoning != 0:
            result += " deadReckoning='" + SFInt32(self.deadReckoning).XML() + "'"
        if self.detonationLocation != (0, 0, 0):
            result += " detonationLocation='" + SFVec3f(self.detonationLocation).XML() + "'"
        if self.detonationRelativeLocation != (0, 0, 0):
            result += " detonationRelativeLocation='" + SFVec3f(self.detonationRelativeLocation).XML() + "'"
        if self.detonationResult != 0:
            result += " detonationResult='" + SFInt32(self.detonationResult).XML() + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.entityCategory != 0:
            result += " entityCategory='" + SFInt32(self.entityCategory).XML() + "'"
        if self.entityCountry != 0:
            result += " entityCountry='" + SFInt32(self.entityCountry).XML() + "'"
        if self.entityDomain != 0:
            result += " entityDomain='" + SFInt32(self.entityDomain).XML() + "'"
        if self.entityExtra != 0:
            result += " entityExtra='" + SFInt32(self.entityExtra).XML() + "'"
        if self.entityID != 0:
            result += " entityID='" + SFInt32(self.entityID).XML() + "'"
        if self.entityKind != 0:
            result += " entityKind='" + SFInt32(self.entityKind).XML() + "'"
        if self.entitySpecific != 0:
            result += " entitySpecific='" + SFInt32(self.entitySpecific).XML() + "'"
        if self.entitySubcategory != 0:
            result += " entitySubcategory='" + SFInt32(self.entitySubcategory).XML() + "'"
        if self.eventApplicationID != 0:
            result += " eventApplicationID='" + SFInt32(self.eventApplicationID).XML() + "'"
        if self.eventEntityID != 0:
            result += " eventEntityID='" + SFInt32(self.eventEntityID).XML() + "'"
        if self.eventNumber != 0:
            result += " eventNumber='" + SFInt32(self.eventNumber).XML() + "'"
        if self.eventSiteID != 0:
            result += " eventSiteID='" + SFInt32(self.eventSiteID).XML() + "'"
        if self.fireMissionIndex != 0:
            result += " fireMissionIndex='" + SFInt32(self.fireMissionIndex).XML() + "'"
        if self.fired1: # default=false
            result += " fired1='" + SFBool(self.fired1).XML() + "'"
        if self.fired2: # default=false
            result += " fired2='" + SFBool(self.fired2).XML() + "'"
        if self.firingRange != 0:
            result += " firingRange='" + SFFloat(self.firingRange).XML() + "'"
        if self.firingRate != 0:
            result += " firingRate='" + SFInt32(self.firingRate).XML() + "'"
        if self.forceID != 0:
            result += " forceID='" + SFInt32(self.forceID).XML() + "'"
        if self.fuse != 0:
            result += " fuse='" + SFInt32(self.fuse).XML() + "'"
        if self.geoCoords != (0, 0, 0):
            result += " geoCoords='" + SFVec3d(self.geoCoords).XML() + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + MFString(self.geoSystem).XML() + "'"
        if self.linearAcceleration != (0, 0, 0):
            result += " linearAcceleration='" + SFVec3f(self.linearAcceleration).XML() + "'"
        if self.linearVelocity != (0, 0, 0):
            result += " linearVelocity='" + SFVec3f(self.linearVelocity).XML() + "'"
        if self.marking:
            result += " marking='" + self.marking + "'"
        if self.multicastRelayHost:
            result += " multicastRelayHost='" + self.multicastRelayHost + "'"
        if self.multicastRelayPort != 0:
            result += " multicastRelayPort='" + SFInt32(self.multicastRelayPort).XML() + "'"
        if self.munitionApplicationID != 0:
            result += " munitionApplicationID='" + SFInt32(self.munitionApplicationID).XML() + "'"
        if self.munitionEndPoint != (0, 0, 0):
            result += " munitionEndPoint='" + SFVec3f(self.munitionEndPoint).XML() + "'"
        if self.munitionEntityID != 0:
            result += " munitionEntityID='" + SFInt32(self.munitionEntityID).XML() + "'"
        if self.munitionQuantity != 0:
            result += " munitionQuantity='" + SFInt32(self.munitionQuantity).XML() + "'"
        if self.munitionSiteID != 0:
            result += " munitionSiteID='" + SFInt32(self.munitionSiteID).XML() + "'"
        if self.munitionStartPoint != (0, 0, 0):
            result += " munitionStartPoint='" + SFVec3f(self.munitionStartPoint).XML() + "'"
        if self.networkMode != 'standAlone':
            result += " networkMode='" + self.networkMode + "'"
        if self.port != 0:
            result += " port='" + SFInt32(self.port).XML() + "'"
        if self.readInterval != 0.1:
            result += " readInterval='" + SFTime(self.readInterval).XML() + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + SFRotation(self.rotation).XML() + "'"
        if self.rtpHeaderExpected: # default=false
            result += " rtpHeaderExpected='" + SFBool(self.rtpHeaderExpected).XML() + "'"
        if self.scale != (1, 1, 1):
            result += " scale='" + SFVec3f(self.scale).XML() + "'"
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation='" + SFRotation(self.scaleOrientation).XML() + "'"
        if self.siteID != 0:
            result += " siteID='" + SFInt32(self.siteID).XML() + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + SFVec3f(self.translation).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if self.warhead != 0:
            result += " warhead='" + SFInt32(self.warhead).XML() + "'"
        if self.writeInterval != 1.0:
            result += " writeInterval='" + SFTime(self.writeInterval).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></EspduTransform>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* EspduTransform found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</EspduTransform>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function EspduTransform.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'EspduTransform' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'EspduTransform' + ' {'
        if self.address != 'localhost':
            result += " address " +  '"' + self.address + '"' + ""
        if self.applicationID != 0:
            result += " applicationID " + SFInt32(self.applicationID).VRML() + ""
        if self.articulationParameterArray != list():
            result += " articulationParameterArray " + MFFloat(self.articulationParameterArray).VRML() + ""
        if self.articulationParameterChangeIndicatorArray != list():
            result += " articulationParameterChangeIndicatorArray " + MFInt32(self.articulationParameterChangeIndicatorArray).VRML() + ""
        if self.articulationParameterCount != 0:
            result += " articulationParameterCount " + SFInt32(self.articulationParameterCount).VRML() + ""
        if self.articulationParameterDesignatorArray != list():
            result += " articulationParameterDesignatorArray " + MFInt32(self.articulationParameterDesignatorArray).VRML() + ""
        if self.articulationParameterIdPartAttachedToArray != list():
            result += " articulationParameterIdPartAttachedToArray " + MFInt32(self.articulationParameterIdPartAttachedToArray).VRML() + ""
        if self.articulationParameterTypeArray != list():
            result += " articulationParameterTypeArray " + MFInt32(self.articulationParameterTypeArray).VRML() + ""
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.center != (0, 0, 0):
            result += " center " + SFVec3f(self.center).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.collisionType != 0:
            result += " collisionType " + SFInt32(self.collisionType).VRML() + ""
        if self.deadReckoning != 0:
            result += " deadReckoning " + SFInt32(self.deadReckoning).VRML() + ""
        if self.detonationLocation != (0, 0, 0):
            result += " detonationLocation " + SFVec3f(self.detonationLocation).VRML() + ""
        if self.detonationRelativeLocation != (0, 0, 0):
            result += " detonationRelativeLocation " + SFVec3f(self.detonationRelativeLocation).VRML() + ""
        if self.detonationResult != 0:
            result += " detonationResult " + SFInt32(self.detonationResult).VRML() + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.entityCategory != 0:
            result += " entityCategory " + SFInt32(self.entityCategory).VRML() + ""
        if self.entityCountry != 0:
            result += " entityCountry " + SFInt32(self.entityCountry).VRML() + ""
        if self.entityDomain != 0:
            result += " entityDomain " + SFInt32(self.entityDomain).VRML() + ""
        if self.entityExtra != 0:
            result += " entityExtra " + SFInt32(self.entityExtra).VRML() + ""
        if self.entityID != 0:
            result += " entityID " + SFInt32(self.entityID).VRML() + ""
        if self.entityKind != 0:
            result += " entityKind " + SFInt32(self.entityKind).VRML() + ""
        if self.entitySpecific != 0:
            result += " entitySpecific " + SFInt32(self.entitySpecific).VRML() + ""
        if self.entitySubcategory != 0:
            result += " entitySubcategory " + SFInt32(self.entitySubcategory).VRML() + ""
        if self.eventApplicationID != 0:
            result += " eventApplicationID " + SFInt32(self.eventApplicationID).VRML() + ""
        if self.eventEntityID != 0:
            result += " eventEntityID " + SFInt32(self.eventEntityID).VRML() + ""
        if self.eventNumber != 0:
            result += " eventNumber " + SFInt32(self.eventNumber).VRML() + ""
        if self.eventSiteID != 0:
            result += " eventSiteID " + SFInt32(self.eventSiteID).VRML() + ""
        if self.fireMissionIndex != 0:
            result += " fireMissionIndex " + SFInt32(self.fireMissionIndex).VRML() + ""
        if self.fired1: # default=false
            result += " fired1 " + SFBool(self.fired1).VRML() + ""
        if self.fired2: # default=false
            result += " fired2 " + SFBool(self.fired2).VRML() + ""
        if self.firingRange != 0:
            result += " firingRange " + SFFloat(self.firingRange).VRML() + ""
        if self.firingRate != 0:
            result += " firingRate " + SFInt32(self.firingRate).VRML() + ""
        if self.forceID != 0:
            result += " forceID " + SFInt32(self.forceID).VRML() + ""
        if self.fuse != 0:
            result += " fuse " + SFInt32(self.fuse).VRML() + ""
        if self.geoCoords != (0, 0, 0):
            result += " geoCoords " + SFVec3d(self.geoCoords).VRML() + ""
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem " + MFString(self.geoSystem).VRML() + ""
        if self.linearAcceleration != (0, 0, 0):
            result += " linearAcceleration " + SFVec3f(self.linearAcceleration).VRML() + ""
        if self.linearVelocity != (0, 0, 0):
            result += " linearVelocity " + SFVec3f(self.linearVelocity).VRML() + ""
        if self.marking:
            result += " marking " +  '"' + self.marking + '"' + ""
        if self.multicastRelayHost:
            result += " multicastRelayHost " +  '"' + self.multicastRelayHost + '"' + ""
        if self.multicastRelayPort != 0:
            result += " multicastRelayPort " + SFInt32(self.multicastRelayPort).VRML() + ""
        if self.munitionApplicationID != 0:
            result += " munitionApplicationID " + SFInt32(self.munitionApplicationID).VRML() + ""
        if self.munitionEndPoint != (0, 0, 0):
            result += " munitionEndPoint " + SFVec3f(self.munitionEndPoint).VRML() + ""
        if self.munitionEntityID != 0:
            result += " munitionEntityID " + SFInt32(self.munitionEntityID).VRML() + ""
        if self.munitionQuantity != 0:
            result += " munitionQuantity " + SFInt32(self.munitionQuantity).VRML() + ""
        if self.munitionSiteID != 0:
            result += " munitionSiteID " + SFInt32(self.munitionSiteID).VRML() + ""
        if self.munitionStartPoint != (0, 0, 0):
            result += " munitionStartPoint " + SFVec3f(self.munitionStartPoint).VRML() + ""
        if self.networkMode != 'standAlone':
            result += " networkMode " +  '"' + self.networkMode + '"' + ""
        if self.port != 0:
            result += " port " + SFInt32(self.port).VRML() + ""
        if self.readInterval != 0.1:
            result += " readInterval " + SFTime(self.readInterval).VRML() + ""
        if self.rotation != (0, 0, 1, 0):
            result += " rotation " + SFRotation(self.rotation).VRML() + ""
        if self.rtpHeaderExpected: # default=false
            result += " rtpHeaderExpected " + SFBool(self.rtpHeaderExpected).VRML() + ""
        if self.scale != (1, 1, 1):
            result += " scale " + SFVec3f(self.scale).VRML() + ""
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation " + SFRotation(self.scaleOrientation).VRML() + ""
        if self.siteID != 0:
            result += " siteID " + SFInt32(self.siteID).VRML() + ""
        if self.translation != (0, 0, 0):
            result += " translation " + SFVec3f(self.translation).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.warhead != 0:
            result += " warhead " + SFInt32(self.warhead).VRML() + ""
        if self.writeInterval != 1.0:
            result += " writeInterval " + SFTime(self.writeInterval).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ExplosionEmitter(_X3DParticleEmitterNode):
    """
    ExplosionEmitter generates all particles from a specific point in space at the initial time enabled.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ExplosionEmitter'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/particleSystems.html#ExplosionEmitter'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ExplosionEmitter'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('mass', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('position', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'ExplosionEmitter'),
            ('speed', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('surfaceArea', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('variation', 0.25, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 mass=0,
                 position=(0, 0, 0),
                 speed=0,
                 surfaceArea=0,
                 variation=0.25,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ExplosionEmitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.mass = mass
        self.position = position
        self.speed = speed
        self.surfaceArea = surfaceArea
        self.variation = variation
    @property # getter - - - - - - - - - -
    def mass(self):
        """[0,+infinity) Basic mass of each particle, defined in mass base units (default is kilograms)."""
        return self.__mass
    @mass.setter
    def mass(self, mass):
        if  mass is None:
            mass = 0 # default
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def position(self):
        """Point from which particles emanate."""
        return self.__position
    @position.setter
    def position(self, position):
        if  position is None:
            position = (0, 0, 0) # default
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def speed(self):
        """[0,+infinity) Initial linear speed (default is m/s) imparted to all particles along their direction of movement."""
        return self.__speed
    @speed.setter
    def speed(self, speed):
        if  speed is None:
            speed = 0 # default
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def surfaceArea(self):
        """[0,+infinity) Particle surface area in area base units (default is meters squared)."""
        return self.__surfaceArea
    @surfaceArea.setter
    def surfaceArea(self, surfaceArea):
        if  surfaceArea is None:
            surfaceArea = 0 # default
        assertValidSFFloat(surfaceArea)
        assertNonNegative('surfaceArea', surfaceArea)
        self.__surfaceArea = surfaceArea
    @property # getter - - - - - - - - - -
    def variation(self):
        """[0,+infinity) Multiplier for the randomness used to control the range of possible output values."""
        return self.__variation
    @variation.setter
    def variation(self, variation):
        if  variation is None:
            variation = 0.25 # default
        assertValidSFFloat(variation)
        assertNonNegative('variation', variation)
        self.__variation = variation
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ExplosionEmitter.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ExplosionEmitter'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.mass != 0:
            result += " mass='" + SFFloat(self.mass).XML() + "'"
        if self.position != (0, 0, 0):
            result += " position='" + SFVec3f(self.position).XML() + "'"
        if self.speed != 0:
            result += " speed='" + SFFloat(self.speed).XML() + "'"
        if self.surfaceArea != 0:
            result += " surfaceArea='" + SFFloat(self.surfaceArea).XML() + "'"
        if self.variation != 0.25:
            result += " variation='" + SFFloat(self.variation).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ExplosionEmitter>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ExplosionEmitter>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ExplosionEmitter.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ExplosionEmitter' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ExplosionEmitter' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.mass != 0:
            result += " mass " + SFFloat(self.mass).VRML() + ""
        if self.position != (0, 0, 0):
            result += " position " + SFVec3f(self.position).VRML() + ""
        if self.speed != 0:
            result += " speed " + SFFloat(self.speed).VRML() + ""
        if self.surfaceArea != 0:
            result += " surfaceArea " + SFFloat(self.surfaceArea).VRML() + ""
        if self.variation != 0.25:
            result += " variation " + SFFloat(self.variation).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Extrusion(_X3DGeometryNode):
    """
    Extrusion is a geometry node that sequentially stretches a 2D cross section along a 3D-spine path in the local coordinate system, creating an outer hull.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Extrusion'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geometry3D.html#Extrusion'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Extrusion'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('beginCap', True, FieldType.SFBool, AccessType.initializeOnly, 'Extrusion'),
            ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'Extrusion'),
            ('convex', True, FieldType.SFBool, AccessType.initializeOnly, 'Extrusion'),
            ('creaseAngle', 0, FieldType.SFFloat, AccessType.initializeOnly, 'Extrusion'),
            ('crossSection', [(1, 1, 1, -1, -1, -1, -1, 1, 1, 1)], FieldType.MFVec2f, AccessType.initializeOnly, 'Extrusion'),
            ('endCap', True, FieldType.SFBool, AccessType.initializeOnly, 'Extrusion'),
            ('orientation', [(0, 0, 1, 0)], FieldType.MFRotation, AccessType.inputOutput, 'Extrusion'),
            ('scale', [(1, 1)], FieldType.MFVec2f, AccessType.inputOutput, 'Extrusion'),
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'Extrusion'),
            ('spine', [(0, 0, 0, 0, 1, 0)], FieldType.MFVec3f, AccessType.initializeOnly, 'Extrusion'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 beginCap=True,
                 ccw=True,
                 convex=True,
                 creaseAngle=0,
                 crossSection=[(1, 1, 1, -1, -1, -1, -1, 1, 1, 1)],
                 endCap=True,
                 orientation=[(0, 0, 1, 0)],
                 scale=[(1, 1)],
                 solid=True,
                 spine=[(0, 0, 0, 0, 1, 0)],
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Extrusion __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.beginCap = beginCap
        self.ccw = ccw
        self.convex = convex
        self.creaseAngle = creaseAngle
        self.crossSection = crossSection
        self.endCap = endCap
        self.orientation = orientation
        self.scale = scale
        self.solid = solid
        self.spine = spine
    @property # getter - - - - - - - - - -
    def beginCap(self):
        """Whether beginning cap is drawn (similar to Cylinder top cap)."""
        return self.__beginCap
    @beginCap.setter
    def beginCap(self, beginCap):
        if  beginCap is None:
            beginCap = True # default
        assertValidSFBool(beginCap)
        self.__beginCap = beginCap
    @property # getter - - - - - - - - - -
    def ccw(self):
        """The ccw field indicates counterclockwise ordering of vertex-coordinates orientation."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def convex(self):
        """The convex field is a hint to renderers whether all polygons in a shape are convex (true), or possibly concave (false)."""
        return self.__convex
    @convex.setter
    def convex(self, convex):
        if  convex is None:
            convex = True # default
        assertValidSFBool(convex)
        self.__convex = convex
    @property # getter - - - - - - - - - -
    def creaseAngle(self):
        """[0,+infinity) creaseAngle defines angle (in radians) where adjacent polygons are drawn with sharp edges or smooth shading."""
        return self.__creaseAngle
    @creaseAngle.setter
    def creaseAngle(self, creaseAngle):
        if  creaseAngle is None:
            creaseAngle = 0 # default
        assertValidSFFloat(creaseAngle)
        assertNonNegative('creaseAngle', creaseAngle)
        self.__creaseAngle = creaseAngle
    @property # getter - - - - - - - - - -
    def crossSection(self):
        """The crossSection array defines a silhouette outline of the outer Extrusion surface."""
        return self.__crossSection
    @crossSection.setter
    def crossSection(self, crossSection):
        if  crossSection is None:
            crossSection = [(1, 1, 1, -1, -1, -1, -1, 1, 1, 1)] # default
        assertValidMFVec2f(crossSection)
        self.__crossSection = crossSection
    @property # getter - - - - - - - - - -
    def endCap(self):
        """Whether end cap is drawn (similar to Cylinder bottom cap)."""
        return self.__endCap
    @endCap.setter
    def endCap(self, endCap):
        if  endCap is None:
            endCap = True # default
        assertValidSFBool(endCap)
        self.__endCap = endCap
    @property # getter - - - - - - - - - -
    def orientation(self):
        """The orientation array is a list of axis-angle 4-tuple values applied at each spine-aligned cross-section plane."""
        return self.__orientation
    @orientation.setter
    def orientation(self, orientation):
        if  orientation is None:
            orientation = [(0, 0, 1, 0)] # default
        assertValidMFRotation(orientation)
        self.__orientation = orientation
    @property # getter - - - - - - - - - -
    def scale(self):
        """(0,+infinity) scale is a list of 2D-scale parameters applied at each spine-aligned cross-section plane."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = [(1, 1)] # default
        assertValidMFVec2f(scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def spine(self):
        """The spine array defines a center-line sequence of 3D points that define a piecewise-linear curve forming a series of connected vertices."""
        return self.__spine
    @spine.setter
    def spine(self, spine):
        if  spine is None:
            spine = [(0, 0, 0, 0, 1, 0)] # default
        assertValidMFVec3f(spine)
        self.__spine = spine
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Extrusion.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Extrusion'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.beginCap: # default=true
            result += " beginCap='" + SFBool(self.beginCap).XML() + "'"
        if not self.ccw: # default=true
            result += " ccw='" + SFBool(self.ccw).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.convex: # default=true
            result += " convex='" + SFBool(self.convex).XML() + "'"
        if self.creaseAngle != 0:
            result += " creaseAngle='" + SFFloat(self.creaseAngle).XML() + "'"
        if self.crossSection != [(1, 1, 1, -1, -1, -1, -1, 1, 1, 1)]:
            result += " crossSection='" + MFVec2f(self.crossSection).XML() + "'"
        if not self.endCap: # default=true
            result += " endCap='" + SFBool(self.endCap).XML() + "'"
        if self.orientation != [(0, 0, 1, 0)]:
            result += " orientation='" + MFRotation(self.orientation).XML() + "'"
        if self.scale != [(1, 1)]:
            result += " scale='" + MFVec2f(self.scale).XML() + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if self.spine != [(0, 0, 0, 0, 1, 0)]:
            result += " spine='" + MFVec3f(self.spine).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Extrusion>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Extrusion>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Extrusion.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Extrusion' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Extrusion' + ' {'
        if not self.beginCap: # default=true
            result += " beginCap " + SFBool(self.beginCap).VRML() + ""
        if not self.ccw: # default=true
            result += " ccw " + SFBool(self.ccw).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.convex: # default=true
            result += " convex " + SFBool(self.convex).VRML() + ""
        if self.creaseAngle != 0:
            result += " creaseAngle " + SFFloat(self.creaseAngle).VRML() + ""
        if self.crossSection != [(1, 1, 1, -1, -1, -1, -1, 1, 1, 1)]:
            result += " crossSection " + MFVec2f(self.crossSection).VRML() + ""
        if not self.endCap: # default=true
            result += " endCap " + SFBool(self.endCap).VRML() + ""
        if self.orientation != [(0, 0, 1, 0)]:
            result += " orientation " + MFRotation(self.orientation).VRML() + ""
        if self.scale != [(1, 1)]:
            result += " scale " + MFVec2f(self.scale).VRML() + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.spine != [(0, 0, 0, 0, 1, 0)]:
            result += " spine " + MFVec3f(self.spine).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class FillProperties(_X3DAppearanceChildNode):
    """
    FillProperties indicates whether appearance is filled or hatched for associated geometry nodes inside the same Shape.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'FillProperties'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shape.html#FillProperties'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#FillProperties'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('filled', True, FieldType.SFBool, AccessType.inputOutput, 'FillProperties'),
            ('hatchColor', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'FillProperties'),
            ('hatched', True, FieldType.SFBool, AccessType.inputOutput, 'FillProperties'),
            ('hatchStyle', 1, FieldType.SFInt32, AccessType.inputOutput, 'FillProperties'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 filled=True,
                 hatchColor=(1, 1, 1),
                 hatched=True,
                 hatchStyle=1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode FillProperties __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.filled = filled
        self.hatchColor = hatchColor
        self.hatched = hatched
        self.hatchStyle = hatchStyle
    @property # getter - - - - - - - - - -
    def filled(self):
        """Whether or not associated geometry is filled."""
        return self.__filled
    @filled.setter
    def filled(self, filled):
        if  filled is None:
            filled = True # default
        assertValidSFBool(filled)
        self.__filled = filled
    @property # getter - - - - - - - - - -
    def hatchColor(self):
        """[0,1] Color of the hatch pattern."""
        return self.__hatchColor
    @hatchColor.setter
    def hatchColor(self, hatchColor):
        if  hatchColor is None:
            hatchColor = (1, 1, 1) # default
        assertValidSFColor(hatchColor)
        assertZeroToOne('hatchColor', hatchColor)
        self.__hatchColor = hatchColor
    @property # getter - - - - - - - - - -
    def hatched(self):
        """Whether or not associated geometry is hatched."""
        return self.__hatched
    @hatched.setter
    def hatched(self, hatched):
        if  hatched is None:
            hatched = True # default
        assertValidSFBool(hatched)
        self.__hatched = hatched
    @property # getter - - - - - - - - - -
    def hatchStyle(self):
        """hatchStyle selects a hatch pattern from International Register of Graphical Items."""
        return self.__hatchStyle
    @hatchStyle.setter
    def hatchStyle(self, hatchStyle):
        if  hatchStyle is None:
            hatchStyle = 1 # default
        assertValidSFInt32(hatchStyle)
        self.__hatchStyle = hatchStyle
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function FillProperties.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<FillProperties'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.filled: # default=true
            result += " filled='" + SFBool(self.filled).XML() + "'"
        if self.hatchColor != (1, 1, 1):
            result += " hatchColor='" + SFColor(self.hatchColor).XML() + "'"
        if self.hatchStyle != 1:
            result += " hatchStyle='" + SFInt32(self.hatchStyle).XML() + "'"
        if not self.hatched: # default=true
            result += " hatched='" + SFBool(self.hatched).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></FillProperties>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</FillProperties>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function FillProperties.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'FillProperties' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'FillProperties' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.filled: # default=true
            result += " filled " + SFBool(self.filled).VRML() + ""
        if self.hatchColor != (1, 1, 1):
            result += " hatchColor " + SFColor(self.hatchColor).VRML() + ""
        if self.hatchStyle != 1:
            result += " hatchStyle " + SFInt32(self.hatchStyle).VRML() + ""
        if not self.hatched: # default=true
            result += " hatched " + SFBool(self.hatched).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class FloatVertexAttribute(_X3DVertexAttributeNode):
    """
    FloatVertexAttribute defines a set of per-vertex single-precision floating-point attributes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'FloatVertexAttribute'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shaders.html#FloatVertexAttribute'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#FloatVertexAttribute'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DVertexAttributeNode'),
            ('numComponents', 4, FieldType.SFInt32, AccessType.initializeOnly, 'FloatVertexAttribute'),
            ('value', list(), FieldType.MFFloat, AccessType.inputOutput, 'FloatVertexAttribute'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 name='',
                 numComponents=4,
                 value=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode FloatVertexAttribute __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.numComponents = numComponents
        self.value = value
    @property # getter - - - - - - - - - -
    def name(self):
        """Required name for this particular VertexAttribute instance."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def numComponents(self):
        """numComponents pecifies how many consecutive floating-point values should be grouped together per vertex."""
        return self.__numComponents
    @numComponents.setter
    def numComponents(self, numComponents):
        if  numComponents is None:
            numComponents = 4 # default
        assertValidSFInt32(numComponents)
        assertGreaterThanEquals('numComponents', numComponents, 1)
        assertLessThanEquals('numComponents', numComponents, 4)
        self.__numComponents = numComponents
    @property # getter - - - - - - - - - -
    def value(self):
        """value specifies an arbitrary collection of floating-point values that will be passed to the shader as per-vertex information."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(value)
        self.__value = value
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function FloatVertexAttribute.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<FloatVertexAttribute'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.numComponents != 4:
            result += " numComponents='" + SFInt32(self.numComponents).XML() + "'"
        if self.value != list():
            result += " value='" + MFFloat(self.value).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></FloatVertexAttribute>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</FloatVertexAttribute>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function FloatVertexAttribute.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'FloatVertexAttribute' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'FloatVertexAttribute' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if self.numComponents != 4:
            result += " numComponents " + SFInt32(self.numComponents).VRML() + ""
        if self.value != list():
            result += " value " + MFFloat(self.value).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Fog(_X3DBindableNode, _X3DFogObject):
    """
    Fog simulates atmospheric effects by blending distant objects with fog color.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Fog'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/environmentalEffects.html#Fog'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Fog'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'X3DFogObject'),
            ('fogType', 'LINEAR', FieldType.SFString, AccessType.inputOutput, 'X3DFogObject'),
            ('visibilityRange', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DFogObject'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 color=(1, 1, 1),
                 fogType='LINEAR',
                 visibilityRange=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Fog __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.color = color
        self.fogType = fogType
        self.visibilityRange = visibilityRange
    @property # getter - - - - - - - - - -
    def color(self):
        """[0,1] Fog color."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = (1, 1, 1) # default
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def fogType(self):
        """Specifies algorithm for rate of increasing Fog, either LINEAR or EXPONENTIAL."""
        return self.__fogType
    @fogType.setter
    def fogType(self, fogType):
        if  fogType is None:
            fogType = 'LINEAR' # default
        assertValidSFString(fogType)
        assertValidFogType('fogType', fogType)
        self.__fogType = fogType
    @property # getter - - - - - - - - - -
    def visibilityRange(self):
        """Distance in meters where objects are totally obscured by the fog, using local coordinate system."""
        return self.__visibilityRange
    @visibilityRange.setter
    def visibilityRange(self, visibilityRange):
        if  visibilityRange is None:
            visibilityRange = 0 # default
        assertValidSFFloat(visibilityRange)
        assertNonNegative('visibilityRange', visibilityRange)
        self.__visibilityRange = visibilityRange
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Fog.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Fog'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.color != (1, 1, 1):
            result += " color='" + SFColor(self.color).XML() + "'"
        if self.fogType != 'LINEAR':
            result += " fogType='" + self.fogType + "'"
        if self.visibilityRange != 0:
            result += " visibilityRange='" + SFFloat(self.visibilityRange).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Fog>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Fog>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Fog.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Fog' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Fog' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.color != (1, 1, 1):
            result += " color " + SFColor(self.color).VRML() + ""
        if self.fogType != 'LINEAR':
            result += " fogType " +  '"' + self.fogType + '"' + ""
        if self.visibilityRange != 0:
            result += " visibilityRange " + SFFloat(self.visibilityRange).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class FogCoordinate(_X3DGeometricPropertyNode):
    """
    FogCoordinate defines a set of explicit fog depths on a per-vertex basis, overriding Fog visibilityRange.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'FogCoordinate'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/environmentalEffects.html#FogCoordinate'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#FogCoordinate'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('depth', list(), FieldType.MFFloat, AccessType.inputOutput, 'FogCoordinate'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 depth=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode FogCoordinate __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.depth = depth
    @property # getter - - - - - - - - - -
    def depth(self):
        """depth contains a set of 3D coordinate (triplet) point values."""
        return self.__depth
    @depth.setter
    def depth(self, depth):
        if  depth is None:
            depth = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(depth)
        assertZeroToOne('depth', depth)
        self.__depth = depth
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function FogCoordinate.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<FogCoordinate'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.depth != list():
            result += " depth='" + MFFloat(self.depth).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></FogCoordinate>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</FogCoordinate>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function FogCoordinate.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'FogCoordinate' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'FogCoordinate' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.depth != list():
            result += " depth " + MFFloat(self.depth).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class FontStyle(_X3DFontStyleNode):
    """
    FontStyle is an X3DFontStyleNode that defines the size, family, justification, and other styles used by Text nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'FontStyle'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/text.html#FontStyle'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#FontStyle'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('family', ["SERIF"], FieldType.MFString, AccessType.initializeOnly, 'FontStyle'),
            ('horizontal', True, FieldType.SFBool, AccessType.initializeOnly, 'FontStyle'),
            ('justify', ["BEGIN"], FieldType.MFString, AccessType.initializeOnly, 'FontStyle'),
            ('language', '', FieldType.SFString, AccessType.initializeOnly, 'FontStyle'),
            ('leftToRight', True, FieldType.SFBool, AccessType.initializeOnly, 'FontStyle'),
            ('size', 1.0, FieldType.SFFloat, AccessType.initializeOnly, 'FontStyle'),
            ('spacing', 1.0, FieldType.SFFloat, AccessType.initializeOnly, 'FontStyle'),
            ('style', 'PLAIN', FieldType.SFString, AccessType.initializeOnly, 'FontStyle'),
            ('topToBottom', True, FieldType.SFBool, AccessType.initializeOnly, 'FontStyle'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 family=["SERIF"],
                 horizontal=True,
                 justify=["BEGIN"],
                 language='',
                 leftToRight=True,
                 size=1.0,
                 spacing=1.0,
                 style='PLAIN',
                 topToBottom=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode FontStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.family = family
        self.horizontal = horizontal
        self.justify = justify
        self.language = language
        self.leftToRight = leftToRight
        self.size = size
        self.spacing = spacing
        self.style = style
        self.topToBottom = topToBottom
    @property # getter - - - - - - - - - -
    def family(self):
        """Array of quoted font family names in preference order, browsers use the first supported family."""
        return self.__family
    @family.setter
    def family(self, family):
        if  family is None:
            family = ["SERIF"] # default
        assertValidMFString(family)
        self.__family = family
    @property # getter - - - - - - - - - -
    def horizontal(self):
        """Whether text direction is horizontal (true) or vertical (false)."""
        return self.__horizontal
    @horizontal.setter
    def horizontal(self, horizontal):
        if  horizontal is None:
            horizontal = True # default
        assertValidSFBool(horizontal)
        self.__horizontal = horizontal
    @property # getter - - - - - - - - - -
    def justify(self):
        """The justify field determines alignment of the above text layout relative to the origin of the object coordinate system."""
        return self.__justify
    @justify.setter
    def justify(self, justify):
        if  justify is None:
            justify = ["BEGIN"] # default
        assertValidMFString(justify)
        assertValidJustify('justify', justify)
        self.__justify = justify
    @property # getter - - - - - - - - - -
    def language(self):
        """Language codes consist of a primary code and a (possibly empty) series of subcodes."""
        return self.__language
    @language.setter
    def language(self, language):
        if  language is None:
            language = SFString.DEFAULT_VALUE(self)
        assertValidSFString(language)
        self.__language = language
    @property # getter - - - - - - - - - -
    def leftToRight(self):
        return self.__leftToRight
    @leftToRight.setter
    def leftToRight(self, leftToRight):
        if  leftToRight is None:
            leftToRight = True # default
        assertValidSFBool(leftToRight)
        self.__leftToRight = leftToRight
    @property # getter - - - - - - - - - -
    def size(self):
        """(0,+infinity) Nominal height (in local coordinate system) of text glyphs Also sets default spacing between adjacent lines of text."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = 1.0 # default
        assertValidSFFloat(size)
        assertPositive('size', size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def spacing(self):
        """[0,+infinity) Adjustment factor for line spacing between adjacent lines of text."""
        return self.__spacing
    @spacing.setter
    def spacing(self, spacing):
        if  spacing is None:
            spacing = 1.0 # default
        assertValidSFFloat(spacing)
        assertNonNegative('spacing', spacing)
        self.__spacing = spacing
    @property # getter - - - - - - - - - -
    def style(self):
        """Pick one of four values for text style."""
        return self.__style
    @style.setter
    def style(self, style):
        if  style is None:
            style = 'PLAIN' # default
        assertValidSFString(style)
        assertValidFontStyle('style', style)
        self.__style = style
    @property # getter - - - - - - - - - -
    def topToBottom(self):
        """Whether text direction is top-to-bottom (true) or bottom-to-top (false)."""
        return self.__topToBottom
    @topToBottom.setter
    def topToBottom(self, topToBottom):
        if  topToBottom is None:
            topToBottom = True # default
        assertValidSFBool(topToBottom)
        self.__topToBottom = topToBottom
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function FontStyle.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<FontStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.family != ["SERIF"]:
            result += " family='" + MFString(self.family).XML() + "'"
        if not self.horizontal: # default=true
            result += " horizontal='" + SFBool(self.horizontal).XML() + "'"
        if self.justify != ["BEGIN"]:
            result += " justify='" + MFString(self.justify).XML() + "'"
        if self.language:
            result += " language='" + self.language + "'"
        if not self.leftToRight: # default=true
            result += " leftToRight='" + SFBool(self.leftToRight).XML() + "'"
        if self.size != 1.0:
            result += " size='" + SFFloat(self.size).XML() + "'"
        if self.spacing != 1.0:
            result += " spacing='" + SFFloat(self.spacing).XML() + "'"
        if self.style != 'PLAIN':
            result += " style='" + self.style + "'"
        if not self.topToBottom: # default=true
            result += " topToBottom='" + SFBool(self.topToBottom).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></FontStyle>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</FontStyle>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function FontStyle.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'FontStyle' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'FontStyle' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.family != ["SERIF"]:
            result += " family " + MFString(self.family).VRML() + ""
        if not self.horizontal: # default=true
            result += " horizontal " + SFBool(self.horizontal).VRML() + ""
        if self.justify != ["BEGIN"]:
            result += " justify " + MFString(self.justify).VRML() + ""
        if self.language:
            result += " language " +  '"' + self.language + '"' + ""
        if not self.leftToRight: # default=true
            result += " leftToRight " + SFBool(self.leftToRight).VRML() + ""
        if self.size != 1.0:
            result += " size " + SFFloat(self.size).VRML() + ""
        if self.spacing != 1.0:
            result += " spacing " + SFFloat(self.spacing).VRML() + ""
        if self.style != 'PLAIN':
            result += " style " +  '"' + self.style + '"' + ""
        if not self.topToBottom: # default=true
            result += " topToBottom " + SFBool(self.topToBottom).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ForcePhysicsModel(_X3DParticlePhysicsModelNode):
    """
    ForcePhysicsModel applies a constant force value to the particles.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ForcePhysicsModel'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/particleSystems.html#ForcePhysicsModel'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ForcePhysicsModel'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DParticlePhysicsModelNode'),
            ('force', (0, -9.8, 0), FieldType.SFVec3f, AccessType.inputOutput, 'ForcePhysicsModel'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 enabled=True,
                 force=(0, -9.8, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ForcePhysicsModel __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.force = force
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def force(self):
        """(-infinity,+infinity) force field indicates strength and direction of the propelling force on the particles (e."""
        return self.__force
    @force.setter
    def force(self, force):
        if  force is None:
            force = (0, -9.8, 0) # default
        assertValidSFVec3f(force)
        self.__force = force
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ForcePhysicsModel.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ForcePhysicsModel'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.force != (0, -9.8, 0):
            result += " force='" + SFVec3f(self.force).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ForcePhysicsModel>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ForcePhysicsModel>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ForcePhysicsModel.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ForcePhysicsModel' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ForcePhysicsModel' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.force != (0, -9.8, 0):
            result += " force " + SFVec3f(self.force).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Gain(_X3DSoundProcessingNode):
    """
    The Gain node amplifies or deamplifies the input signal.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Gain'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#Gain'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Gain'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('channelCountMode', 'max', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('channelInterpretation', 'speakers', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('tailTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 channelCountMode='max',
                 channelInterpretation='speakers',
                 description='',
                 enabled=True,
                 gain=1,
                 pauseTime=0,
                 resumeTime=0,
                 startTime=0,
                 stopTime=0,
                 tailTime=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Gain __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.pauseTime = pauseTime
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.tailTime = tailTime
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'max' # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'speakers' # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1 # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0 # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0 # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0 # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0 # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def tailTime(self):
        """[0,+infinity) tailTime is duration of time that a node continues to provide output signal after the input signal becomes silent."""
        return self.__tailTime
    @tailTime.setter
    def tailTime(self, tailTime):
        if  tailTime is None:
            tailTime = 0 # default
        assertValidSFTime(tailTime)
        assertNonNegative('tailTime', tailTime)
        self.__tailTime = tailTime
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Gain.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Gain'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.channelCountMode != 'max':
            result += " channelCountMode='" + self.channelCountMode + "'"
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation='" + self.channelInterpretation + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.gain != 1:
            result += " gain='" + SFFloat(self.gain).XML() + "'"
        if self.pauseTime != 0:
            result += " pauseTime='" + SFTime(self.pauseTime).XML() + "'"
        if self.resumeTime != 0:
            result += " resumeTime='" + SFTime(self.resumeTime).XML() + "'"
        if self.startTime != 0:
            result += " startTime='" + SFTime(self.startTime).XML() + "'"
        if self.stopTime != 0:
            result += " stopTime='" + SFTime(self.stopTime).XML() + "'"
        if self.tailTime != 0:
            result += " tailTime='" + SFTime(self.tailTime).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Gain>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Gain>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Gain.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Gain' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Gain' + ' {'
        if self.channelCountMode != 'max':
            result += " channelCountMode " +  '"' + self.channelCountMode + '"' + ""
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation " +  '"' + self.channelInterpretation + '"' + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.gain != 1:
            result += " gain " + SFFloat(self.gain).VRML() + ""
        if self.pauseTime != 0:
            result += " pauseTime " + SFTime(self.pauseTime).VRML() + ""
        if self.resumeTime != 0:
            result += " resumeTime " + SFTime(self.resumeTime).VRML() + ""
        if self.startTime != 0:
            result += " startTime " + SFTime(self.startTime).VRML() + ""
        if self.stopTime != 0:
            result += " stopTime " + SFTime(self.stopTime).VRML() + ""
        if self.tailTime != 0:
            result += " tailTime " + SFTime(self.tailTime).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class GeneratedCubeMapTexture(_X3DEnvironmentTextureNode):
    """
    GeneratedCubeMapTexture is a texture node that defines a cubic environment map that sources its data from internally generated images.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'GeneratedCubeMapTexture'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/environmentalTexturing#GeneratedCubeMapTexture'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeneratedCubeMapTexture'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureNode'),
            ('size', 128, FieldType.SFInt32, AccessType.initializeOnly, 'GeneratedCubeMapTexture'),
            ('update', 'NONE', FieldType.SFString, AccessType.inputOutput, 'GeneratedCubeMapTexture'),
            ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly, 'GeneratedCubeMapTexture'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 size=128,
                 update='NONE',
                 textureProperties=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeneratedCubeMapTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.size = size
        self.update = update
        self.textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def size(self):
        """(0,+infinity) size indicates the resolution of the generated images in number of pixels per side."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = 128 # default
        assertValidSFInt32(size)
        assertPositive('size', size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def update(self):
        """update controls regeneration of the texture."""
        return self.__update
    @update.setter
    def update(self, update):
        if  update is None:
            update = 'NONE' # default
        assertValidSFString(update)
        assertValidGeneratedCubeMapTextureUpdate('update', update)
        self.__update = update
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties):
        if  textureProperties is None:
            textureProperties = None # default
        assertValidSFNode(textureProperties)
        if not isinstance(textureProperties, object):
            # print(flush=True)
            raise X3DTypeError(str(textureProperties) + ' does not have a valid node type object')
        self.__textureProperties = textureProperties
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.textureProperties
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function GeneratedCubeMapTexture.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<GeneratedCubeMapTexture'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.size != 128:
            result += " size='" + SFInt32(self.size).XML() + "'"
        if self.update != 'NONE':
            result += " update='" + self.update + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></GeneratedCubeMapTexture>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.textureProperties: # output this SFNode
                result += self.textureProperties.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</GeneratedCubeMapTexture>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function GeneratedCubeMapTexture.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'GeneratedCubeMapTexture' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'GeneratedCubeMapTexture' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.size != 128:
            result += " size " + SFInt32(self.size).VRML() + ""
        if self.update != 'NONE':
            result += " update " +  '"' + self.update + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.textureProperties: # output this SFNode
            result += '\n' + '  ' + indent + 'textureProperties ' + self.textureProperties.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class GeoCoordinate(_X3DCoordinateNode):
    """
    GeoCoordinate builds geometry as a set of geographic 3D coordinates.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'GeoCoordinate'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geospatial.html#GeoCoordinate'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoCoordinate'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoCoordinate'),
            ('point', list(), FieldType.MFVec3d, AccessType.inputOutput, 'GeoCoordinate'),
            ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly, 'GeoCoordinate'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 geoSystem=["GD", "WE"],
                 point=list(),
                 geoOrigin=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoCoordinate __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.geoSystem = geoSystem
        self.point = point
        self.geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"] # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def point(self):
        """point contains a set of actual 3D geographic coordinates, provided in geoSystem format can split strings if desired: "x1 y1 z1 x2 y2 z2" or "x1 y1 z1", "x2 y2 z2"."""
        return self.__point
    @point.setter
    def point(self, point):
        if  point is None:
            point = MFVec3d.DEFAULT_VALUE(self)
        assertValidMFVec3d(point)
        self.__point = point
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        """[GeoOrigin] Single contained GeoOrigin node that specifies a local coordinate frame for extended precision."""
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin):
        if  geoOrigin is None:
            geoOrigin = None # default
        assertValidSFNode(geoOrigin)
        if not isinstance(geoOrigin, object):
            # print(flush=True)
            raise X3DTypeError(str(geoOrigin) + ' does not have a valid node type object')
        self.__geoOrigin = geoOrigin
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.geoOrigin or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function GeoCoordinate.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<GeoCoordinate'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + MFString(self.geoSystem).XML() + "'"
        if self.point != list():
            result += " point='" + MFVec3d(self.point).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></GeoCoordinate>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.geoOrigin: # output this SFNode
                result += self.geoOrigin.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</GeoCoordinate>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function GeoCoordinate.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'GeoCoordinate' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'GeoCoordinate' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem " + MFString(self.geoSystem).VRML() + ""
        if self.point != list():
            result += " point " + MFVec3d(self.point).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.geoOrigin: # output this SFNode
            result += '\n' + '  ' + indent + 'geoOrigin ' + self.geoOrigin.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class GeoElevationGrid(_X3DGeometryNode):
    """
    GeoElevationGrid is a geometry node defining a rectangular height field, with default values for a 1m by 1m square at height 0.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'GeoElevationGrid'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geospatial.html#GeoElevationGrid'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoElevationGrid'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'GeoElevationGrid'),
            ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'GeoElevationGrid'),
            ('creaseAngle', 0, FieldType.SFDouble, AccessType.initializeOnly, 'GeoElevationGrid'),
            ('geoGridOrigin', (0, 0, 0), FieldType.SFVec3d, AccessType.initializeOnly, 'GeoElevationGrid'),
            ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoElevationGrid'),
            ('height', [0, 0, 0, 0], FieldType.MFDouble, AccessType.initializeOnly, 'GeoElevationGrid'),
            ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'GeoElevationGrid'),
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'GeoElevationGrid'),
            ('xDimension', 2, FieldType.SFInt32, AccessType.initializeOnly, 'GeoElevationGrid'),
            ('xSpacing', 1.0, FieldType.SFDouble, AccessType.initializeOnly, 'GeoElevationGrid'),
            ('yScale', 1, FieldType.SFFloat, AccessType.inputOutput, 'GeoElevationGrid'),
            ('zDimension', 2, FieldType.SFInt32, AccessType.initializeOnly, 'GeoElevationGrid'),
            ('zSpacing', 1.0, FieldType.SFDouble, AccessType.initializeOnly, 'GeoElevationGrid'),
            ('color', None, FieldType.SFNode, AccessType.inputOutput, 'GeoElevationGrid'),
            ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly, 'GeoElevationGrid'),
            ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'GeoElevationGrid'),
            ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'GeoElevationGrid'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 creaseAngle=0,
                 geoGridOrigin=(0, 0, 0),
                 geoSystem=["GD", "WE"],
                 height=[0, 0, 0, 0],
                 normalPerVertex=True,
                 solid=True,
                 xDimension=2,
                 xSpacing=1.0,
                 yScale=1,
                 zDimension=2,
                 zSpacing=1.0,
                 color=None,
                 geoOrigin=None,
                 normal=None,
                 texCoord=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoElevationGrid __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.creaseAngle = creaseAngle
        self.geoGridOrigin = geoGridOrigin
        self.geoSystem = geoSystem
        self.height = height
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.xDimension = xDimension
        self.xSpacing = xSpacing
        self.yScale = yScale
        self.zDimension = zDimension
        self.zSpacing = zSpacing
        self.color = color
        self.geoOrigin = geoOrigin
        self.normal = normal
        self.texCoord = texCoord
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color node color values are applied to each point vertex (true) or per quadrilateral (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def creaseAngle(self):
        """(0,+infinity) creaseAngle defines angle (in radians) for determining whether adjacent polygons are drawn with sharp edges or smooth shading."""
        return self.__creaseAngle
    @creaseAngle.setter
    def creaseAngle(self, creaseAngle):
        if  creaseAngle is None:
            creaseAngle = 0 # default
        assertValidSFDouble(creaseAngle)
        assertNonNegative('creaseAngle', creaseAngle)
        self.__creaseAngle = creaseAngle
    @property # getter - - - - - - - - - -
    def geoGridOrigin(self):
        """Geographic coordinate for southwest (lower-left) corner of height dataset."""
        return self.__geoGridOrigin
    @geoGridOrigin.setter
    def geoGridOrigin(self, geoGridOrigin):
        if  geoGridOrigin is None:
            geoGridOrigin = (0, 0, 0) # default
        assertValidSFVec3d(geoGridOrigin)
        self.__geoGridOrigin = geoGridOrigin
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"] # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def height(self):
        """Contains xDimension rows * zDimension columns floating-point values for elevation above ellipsoid."""
        return self.__height
    @height.setter
    def height(self, height):
        if  height is None:
            height = [0, 0, 0, 0] # default
        assertValidMFDouble(height)
        self.__height = height
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or per quadrilateral (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def xDimension(self):
        """(0,+infinity) Number of elements in the height array along east-west X direction."""
        return self.__xDimension
    @xDimension.setter
    def xDimension(self, xDimension):
        if  xDimension is None:
            xDimension = 2 # default
        assertValidSFInt32(xDimension)
        assertNonNegative('xDimension', xDimension)
        self.__xDimension = xDimension
    @property # getter - - - - - - - - - -
    def xSpacing(self):
        """(0,+infinity) Distance between grid-array vertices along east-west X direction."""
        return self.__xSpacing
    @xSpacing.setter
    def xSpacing(self, xSpacing):
        if  xSpacing is None:
            xSpacing = 1.0 # default
        assertValidSFDouble(xSpacing)
        assertPositive('xSpacing', xSpacing)
        self.__xSpacing = xSpacing
    @property # getter - - - - - - - - - -
    def yScale(self):
        """[0,+infinity) Vertical exaggeration of displayed data produced from the height array."""
        return self.__yScale
    @yScale.setter
    def yScale(self, yScale):
        if  yScale is None:
            yScale = 1 # default
        assertValidSFFloat(yScale)
        assertNonNegative('yScale', yScale)
        self.__yScale = yScale
    @property # getter - - - - - - - - - -
    def zDimension(self):
        """(0,+infinity) Number of elements in the height array along north-south Z direction."""
        return self.__zDimension
    @zDimension.setter
    def zDimension(self, zDimension):
        if  zDimension is None:
            zDimension = 2 # default
        assertValidSFInt32(zDimension)
        assertNonNegative('zDimension', zDimension)
        self.__zDimension = zDimension
    @property # getter - - - - - - - - - -
    def zSpacing(self):
        """(0,+infinity) Distance between grid-array vertices along north-south Z direction."""
        return self.__zSpacing
    @zSpacing.setter
    def zSpacing(self, zSpacing):
        if  zSpacing is None:
            zSpacing = 1.0 # default
        assertValidSFDouble(zSpacing)
        assertPositive('zSpacing', zSpacing)
        self.__zSpacing = zSpacing
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that specifies color values applied to corresponding vertices according to colorPerVertex field."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None # default
        assertValidSFNode(color)
        if not isinstance(color, object):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        """[GeoOrigin] Single contained GeoOrigin node that specifies a local coordinate frame for extended precision."""
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin):
        if  geoOrigin is None:
            geoOrigin = None # default
        assertValidSFNode(geoOrigin)
        if not isinstance(geoOrigin, object):
            # print(flush=True)
            raise X3DTypeError(str(geoOrigin) + ' does not have a valid node type object')
        self.__geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that specifies perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None # default
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that specifies coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None # default
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.color or self.geoOrigin or self.IS or self.metadata or self.normal or self.texCoord
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function GeoElevationGrid.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<GeoElevationGrid'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.ccw: # default=true
            result += " ccw='" + SFBool(self.ccw).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex='" + SFBool(self.colorPerVertex).XML() + "'"
        if self.creaseAngle != 0:
            result += " creaseAngle='" + SFDouble(self.creaseAngle).XML() + "'"
        if self.geoGridOrigin != (0, 0, 0):
            result += " geoGridOrigin='" + SFVec3d(self.geoGridOrigin).XML() + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + MFString(self.geoSystem).XML() + "'"
        if self.height != [0, 0, 0, 0]:
            result += " height='" + MFDouble(self.height).XML() + "'"
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex='" + SFBool(self.normalPerVertex).XML() + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if self.xDimension != 2:
            result += " xDimension='" + SFInt32(self.xDimension).XML() + "'"
        if self.xSpacing != 1.0:
            result += " xSpacing='" + SFDouble(self.xSpacing).XML() + "'"
        if self.yScale != 1:
            result += " yScale='" + SFFloat(self.yScale).XML() + "'"
        if self.zDimension != 2:
            result += " zDimension='" + SFInt32(self.zDimension).XML() + "'"
        if self.zSpacing != 1.0:
            result += " zSpacing='" + SFDouble(self.zSpacing).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></GeoElevationGrid>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.color: # output this SFNode
                result += self.color.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.geoOrigin: # output this SFNode
                result += self.geoOrigin.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.normal: # output this SFNode
                result += self.normal.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.texCoord: # output this SFNode
                result += self.texCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</GeoElevationGrid>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function GeoElevationGrid.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'GeoElevationGrid' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'GeoElevationGrid' + ' {'
        if not self.ccw: # default=true
            result += " ccw " + SFBool(self.ccw).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex " + SFBool(self.colorPerVertex).VRML() + ""
        if self.creaseAngle != 0:
            result += " creaseAngle " + SFDouble(self.creaseAngle).VRML() + ""
        if self.geoGridOrigin != (0, 0, 0):
            result += " geoGridOrigin " + SFVec3d(self.geoGridOrigin).VRML() + ""
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem " + MFString(self.geoSystem).VRML() + ""
        if self.height != [0, 0, 0, 0]:
            result += " height " + MFDouble(self.height).VRML() + ""
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex " + SFBool(self.normalPerVertex).VRML() + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.xDimension != 2:
            result += " xDimension " + SFInt32(self.xDimension).VRML() + ""
        if self.xSpacing != 1.0:
            result += " xSpacing " + SFDouble(self.xSpacing).VRML() + ""
        if self.yScale != 1:
            result += " yScale " + SFFloat(self.yScale).VRML() + ""
        if self.zDimension != 2:
            result += " zDimension " + SFInt32(self.zDimension).VRML() + ""
        if self.zSpacing != 1.0:
            result += " zSpacing " + SFDouble(self.zSpacing).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.color: # output this SFNode
            result += '\n' + '  ' + indent + 'color ' + self.color.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.geoOrigin: # output this SFNode
            result += '\n' + '  ' + indent + 'geoOrigin ' + self.geoOrigin.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.normal: # output this SFNode
            result += '\n' + '  ' + indent + 'normal ' + self.normal.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'texCoord ' + self.texCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class GeoLocation(_X3DGroupingNode):
    """
    GeoLocation positions a regular X3D model onto earth's surface.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'GeoLocation'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geospatial.html#GeoLocation'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoLocation'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('geoCoords', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'GeoLocation'),
            ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoLocation'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly, 'GeoLocation'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 geoCoords=(0, 0, 0),
                 geoSystem=["GD", "WE"],
                 visible=True,
                 geoOrigin=None,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoLocation __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.geoCoords = geoCoords
        self.geoSystem = geoSystem
        self.visible = visible
        self.geoOrigin = geoOrigin
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def geoCoords(self):
        """Geographic location (specified in current geoSystem coordinates) for children geometry (specified in relative coordinate system, in meters)."""
        return self.__geoCoords
    @geoCoords.setter
    def geoCoords(self, geoCoords):
        if  geoCoords is None:
            geoCoords = (0, 0, 0) # default
        assertValidSFVec3d(geoCoords)
        self.__geoCoords = geoCoords
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"] # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        """[GeoOrigin] Single contained GeoOrigin node that specifies a local coordinate frame for extended precision."""
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin):
        if  geoOrigin is None:
            geoOrigin = None # default
        assertValidSFNode(geoOrigin)
        if not isinstance(geoOrigin, object):
            # print(flush=True)
            raise X3DTypeError(str(geoOrigin) + ' does not have a valid node type object')
        self.__geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.geoOrigin or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function GeoLocation.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<GeoLocation'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.geoCoords != (0, 0, 0):
            result += " geoCoords='" + SFVec3d(self.geoCoords).XML() + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + MFString(self.geoSystem).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></GeoLocation>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.geoOrigin: # output this SFNode
                result += self.geoOrigin.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* GeoLocation found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</GeoLocation>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function GeoLocation.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'GeoLocation' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'GeoLocation' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.geoCoords != (0, 0, 0):
            result += " geoCoords " + SFVec3d(self.geoCoords).VRML() + ""
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem " + MFString(self.geoSystem).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.geoOrigin: # output this SFNode
            result += '\n' + '  ' + indent + 'geoOrigin ' + self.geoOrigin.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class GeoLOD(_X3DChildNode, _X3DBoundedObject):
    """
    Note that MFNode rootNode field can contain multiple nodes and has accessType inputOutput. Meanwhile MFNode children field is outputOnly, unlike other X3DGroupingNode exemplars.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'GeoLOD'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geospatial.html#GeoLOD'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoLOD'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('center', (0, 0, 0), FieldType.SFVec3d, AccessType.initializeOnly, 'GeoLOD'),
            ('child1Url', list(), FieldType.MFString, AccessType.initializeOnly, 'GeoLOD'),
            ('child2Url', list(), FieldType.MFString, AccessType.initializeOnly, 'GeoLOD'),
            ('child3Url', list(), FieldType.MFString, AccessType.initializeOnly, 'GeoLOD'),
            ('child4Url', list(), FieldType.MFString, AccessType.initializeOnly, 'GeoLOD'),
            ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoLOD'),
            ('range', 10, FieldType.SFFloat, AccessType.initializeOnly, 'GeoLOD'),
            ('rootUrl', list(), FieldType.MFString, AccessType.initializeOnly, 'GeoLOD'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly, 'GeoLOD'),
            ('rootNode', list(), FieldType.MFNode, AccessType.initializeOnly, 'GeoLOD'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 center=(0, 0, 0),
                 child1Url=list(),
                 child2Url=list(),
                 child3Url=list(),
                 child4Url=list(),
                 geoSystem=["GD", "WE"],
                 range=10,
                 rootUrl=list(),
                 visible=True,
                 geoOrigin=None,
                 rootNode=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoLOD __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.center = center
        self.child1Url = child1Url
        self.child2Url = child2Url
        self.child3Url = child3Url
        self.child4Url = child4Url
        self.geoSystem = geoSystem
        self.range = range
        self.rootUrl = rootUrl
        self.visible = visible
        self.geoOrigin = geoOrigin
        self.rootNode = rootNode
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        """Viewer range from geographic-coordinates center triggers quadtree loading/unloading."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0) # default
        assertValidSFVec3d(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def child1Url(self):
        """quadtree geometry loaded when viewer is within range."""
        return self.__child1Url
    @child1Url.setter
    def child1Url(self, child1Url):
        if  child1Url is None:
            child1Url = MFString.DEFAULT_VALUE(self)
        assertValidMFString(child1Url)
        self.__child1Url = child1Url
    @property # getter - - - - - - - - - -
    def child2Url(self):
        """quadtree geometry loaded when viewer is within range."""
        return self.__child2Url
    @child2Url.setter
    def child2Url(self, child2Url):
        if  child2Url is None:
            child2Url = MFString.DEFAULT_VALUE(self)
        assertValidMFString(child2Url)
        self.__child2Url = child2Url
    @property # getter - - - - - - - - - -
    def child3Url(self):
        """quadtree geometry loaded when viewer is within range."""
        return self.__child3Url
    @child3Url.setter
    def child3Url(self, child3Url):
        if  child3Url is None:
            child3Url = MFString.DEFAULT_VALUE(self)
        assertValidMFString(child3Url)
        self.__child3Url = child3Url
    @property # getter - - - - - - - - - -
    def child4Url(self):
        """quadtree geometry loaded when viewer is within range."""
        return self.__child4Url
    @child4Url.setter
    def child4Url(self, child4Url):
        if  child4Url is None:
            child4Url = MFString.DEFAULT_VALUE(self)
        assertValidMFString(child4Url)
        self.__child4Url = child4Url
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"] # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def range(self):
        """(0,+infinity) Viewer range from geographic-coordinates center triggers quadtree loading/unloading."""
        return self.__range
    @range.setter
    def range(self, range):
        if  range is None:
            range = 10 # default
        assertValidSFFloat(range)
        assertNonNegative('range', range)
        self.__range = range
    @property # getter - - - - - - - - - -
    def rootUrl(self):
        """url for scene providing geometry for the root tile."""
        return self.__rootUrl
    @rootUrl.setter
    def rootUrl(self, rootUrl):
        if  rootUrl is None:
            rootUrl = MFString.DEFAULT_VALUE(self)
        assertValidMFString(rootUrl)
        self.__rootUrl = rootUrl
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        """[GeoOrigin] Single contained GeoOrigin node that specifies a local coordinate frame for extended precision."""
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin):
        if  geoOrigin is None:
            geoOrigin = None # default
        assertValidSFNode(geoOrigin)
        if not isinstance(geoOrigin, object):
            # print(flush=True)
            raise X3DTypeError(str(geoOrigin) + ' does not have a valid node type object')
        self.__geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def rootNode(self):
        """Geometry for the root tile."""
        return self.__rootNode
    @rootNode.setter
    def rootNode(self, rootNode):
        if  rootNode is None:
            rootNode = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(rootNode)
        self.__rootNode = rootNode
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.rootNode or self.geoOrigin or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function GeoLOD.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<GeoLOD'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.center != (0, 0, 0):
            result += " center='" + SFVec3d(self.center).XML() + "'"
        if self.child1Url != list():
            result += " child1Url='" + MFString(self.child1Url).XML() + "'"
        if self.child2Url != list():
            result += " child2Url='" + MFString(self.child2Url).XML() + "'"
        if self.child3Url != list():
            result += " child3Url='" + MFString(self.child3Url).XML() + "'"
        if self.child4Url != list():
            result += " child4Url='" + MFString(self.child4Url).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + MFString(self.geoSystem).XML() + "'"
        if self.range != 10:
            result += " range='" + SFFloat(self.range).XML() + "'"
        if self.rootUrl != list():
            result += " rootUrl='" + MFString(self.rootUrl).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></GeoLOD>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.geoOrigin: # output this SFNode
                result += self.geoOrigin.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.rootNode: # walk each child in MFNode list, if any
            ### print('* GeoLOD found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(rootNode)=' + str(len(self.rootNode)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.rootNode:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</GeoLOD>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function GeoLOD.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'GeoLOD' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'GeoLOD' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.center != (0, 0, 0):
            result += " center " + SFVec3d(self.center).VRML() + ""
        if self.child1Url != list():
            result += " child1Url " + MFString(self.child1Url).VRML() + ""
        if self.child2Url != list():
            result += " child2Url " + MFString(self.child2Url).VRML() + ""
        if self.child3Url != list():
            result += " child3Url " + MFString(self.child3Url).VRML() + ""
        if self.child4Url != list():
            result += " child4Url " + MFString(self.child4Url).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem " + MFString(self.geoSystem).VRML() + ""
        if self.range != 10:
            result += " range " + SFFloat(self.range).VRML() + ""
        if self.rootUrl != list():
            result += " rootUrl " + MFString(self.rootUrl).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.geoOrigin: # output this SFNode
            result += '\n' + '  ' + indent + 'geoOrigin ' + self.geoOrigin.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.rootNode: # walk each child in MFNode list, if any
            for each in self.rootNode:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class GeoMetadata(_X3DInfoNode, _X3DUrlObject):
    """
    GeoMetadata includes a generic subset of metadata about the geographic data.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'GeoMetadata'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geospatial.html#GeoMetadata'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoMetadata'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DUrlObject'),
            ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
            ('refresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
            ('summary', list(), FieldType.MFString, AccessType.inputOutput, 'GeoMetadata'),
            ('url', list(), FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
            ('data', list(), FieldType.MFNode, AccessType.inputOutput, 'GeoMetadata'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 load=True,
                 refresh=0,
                 summary=list(),
                 url=list(),
                 data=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoMetadata __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.load = load
        self.refresh = refresh
        self.summary = summary
        self.url = url
        self.data = data
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def refresh(self):
        """refresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__refresh
    @refresh.setter
    def refresh(self, refresh):
        if  refresh is None:
            refresh = 0 # default
        assertValidSFTime(refresh)
        assertNonNegative('refresh', refresh)
        self.__refresh = refresh
    @property # getter - - - - - - - - - -
    def summary(self):
        """The summary string array contains a set of keyword/value pairs, with each keyword and its subsequent value contained in separate strings."""
        return self.__summary
    @summary.setter
    def summary(self, summary):
        if  summary is None:
            summary = MFString.DEFAULT_VALUE(self)
        assertValidMFString(summary)
        self.__summary = summary
    @property # getter - - - - - - - - - -
    def url(self):
        """Hypertext link to an external, complete metadata description."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE(self)
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def data(self):
        """DEF list of all nodes that implement this data."""
        return self.__data
    @data.setter
    def data(self, data):
        if  data is None:
            data = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(data)
        self.__data = data
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.data or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function GeoMetadata.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<GeoMetadata'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.load: # default=true
            result += " load='" + SFBool(self.load).XML() + "'"
        if self.refresh != 0:
            result += " refresh='" + SFTime(self.refresh).XML() + "'"
        if self.summary != list():
            result += " summary='" + MFString(self.summary).XML() + "'"
        if self.url != list():
            result += " url='" + MFString(self.url).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></GeoMetadata>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.data: # walk each child in MFNode list, if any
            ### print('* GeoMetadata found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(data)=' + str(len(self.data)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.data:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</GeoMetadata>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function GeoMetadata.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'GeoMetadata' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'GeoMetadata' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.load: # default=true
            result += " load " + SFBool(self.load).VRML() + ""
        if self.refresh != 0:
            result += " refresh " + SFTime(self.refresh).VRML() + ""
        if self.summary != list():
            result += " summary " + MFString(self.summary).VRML() + ""
        if self.url != list():
            result += " url " + MFString(self.url).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.data: # walk each child in MFNode list, if any
            for each in self.data:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class GeoOrigin(_X3DNode):
    """
    GeoOrigin is deprecated and discouraged (but nevertheless allowed) in X3D version 3.3. GeoOrigin is restored in X3D version 4.0 for special use on devices with limited floating-point resolution.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'GeoOrigin'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geospatial.html#GeoOrigin'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoOrigin'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('geoCoords', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'GeoOrigin'),
            ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoOrigin'),
            ('rotateYUp', False, FieldType.SFBool, AccessType.initializeOnly, 'GeoOrigin'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 geoCoords=(0, 0, 0),
                 geoSystem=["GD", "WE"],
                 rotateYUp=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoOrigin __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.geoCoords = geoCoords
        self.geoSystem = geoSystem
        self.rotateYUp = rotateYUp
    @property # getter - - - - - - - - - -
    def geoCoords(self):
        """Defines absolute geographic location (and implicit local coordinate frame)."""
        return self.__geoCoords
    @geoCoords.setter
    def geoCoords(self, geoCoords):
        if  geoCoords is None:
            geoCoords = (0, 0, 0) # default
        assertValidSFVec3d(geoCoords)
        self.__geoCoords = geoCoords
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"] # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def rotateYUp(self):
        """Whether to rotate coordinates of nodes using this GeoOrigin so that local-up direction aligns with VRML Y axis rotateYUp false means local up-direction is relative to planet surface rotateYUp true allows proper operation of NavigationInfo modes FLY, WALK."""
        return self.__rotateYUp
    @rotateYUp.setter
    def rotateYUp(self, rotateYUp):
        if  rotateYUp is None:
            rotateYUp = False # default
        assertValidSFBool(rotateYUp)
        self.__rotateYUp = rotateYUp
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function GeoOrigin.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<GeoOrigin'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.geoCoords != (0, 0, 0):
            result += " geoCoords='" + SFVec3d(self.geoCoords).XML() + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + MFString(self.geoSystem).XML() + "'"
        if self.rotateYUp: # default=false
            result += " rotateYUp='" + SFBool(self.rotateYUp).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></GeoOrigin>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</GeoOrigin>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function GeoOrigin.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'GeoOrigin' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'GeoOrigin' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.geoCoords != (0, 0, 0):
            result += " geoCoords " + SFVec3d(self.geoCoords).VRML() + ""
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem " + MFString(self.geoSystem).VRML() + ""
        if self.rotateYUp: # default=false
            result += " rotateYUp " + SFBool(self.rotateYUp).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class GeoPositionInterpolator(_X3DInterpolatorNode):
    """
    GeoPositionInterpolator animates objects within a geographic coordinate system.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'GeoPositionInterpolator'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geospatial.html#GeoPositionInterpolator'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoPositionInterpolator'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoPositionInterpolator'),
            ('key', list(), FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
            ('keyValue', list(), FieldType.MFVec3d, AccessType.inputOutput, 'GeoPositionInterpolator'),
            ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly, 'GeoPositionInterpolator'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 geoSystem=["GD", "WE"],
                 key=list(),
                 keyValue=list(),
                 geoOrigin=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoPositionInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.geoSystem = geoSystem
        self.key = key
        self.keyValue = keyValue
        self.geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"] # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFVec3d.DEFAULT_VALUE(self)
        assertValidMFVec3d(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        """[GeoOrigin] Single contained GeoOrigin node that specifies a local coordinate frame for extended precision."""
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin):
        if  geoOrigin is None:
            geoOrigin = None # default
        assertValidSFNode(geoOrigin)
        if not isinstance(geoOrigin, object):
            # print(flush=True)
            raise X3DTypeError(str(geoOrigin) + ' does not have a valid node type object')
        self.__geoOrigin = geoOrigin
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.geoOrigin or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function GeoPositionInterpolator.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<GeoPositionInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + MFString(self.geoSystem).XML() + "'"
        if self.key != list():
            result += " key='" + MFFloat(self.key).XML() + "'"
        if self.keyValue != list():
            result += " keyValue='" + MFVec3d(self.keyValue).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></GeoPositionInterpolator>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.geoOrigin: # output this SFNode
                result += self.geoOrigin.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</GeoPositionInterpolator>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function GeoPositionInterpolator.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'GeoPositionInterpolator' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'GeoPositionInterpolator' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem " + MFString(self.geoSystem).VRML() + ""
        if self.key != list():
            result += " key " + MFFloat(self.key).VRML() + ""
        if self.keyValue != list():
            result += " keyValue " + MFVec3d(self.keyValue).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.geoOrigin: # output this SFNode
            result += '\n' + '  ' + indent + 'geoOrigin ' + self.geoOrigin.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class GeoProximitySensor(_X3DEnvironmentalSensorNode):
    """
    GeoProximitySensor generates events when the viewer enters, exits and moves within a region of space (defined by a box).
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'GeoProximitySensor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geospatial.html#GeoProximitySensor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoProximitySensor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('center', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'GeoProximitySensor'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('geoCenter', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'GeoProximitySensor'),
            ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoProximitySensor'),
            ('size', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DEnvironmentalSensorNode'),
            ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly, 'GeoProximitySensor'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 center=(0, 0, 0),
                 enabled=True,
                 geoCenter=(0, 0, 0),
                 geoSystem=["GD", "WE"],
                 size=(0, 0, 0),
                 geoOrigin=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoProximitySensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.enabled = enabled
        self.geoCenter = geoCenter
        self.geoSystem = geoSystem
        self.size = size
        self.geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def center(self):
        """(starting with v3."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0) # default
        assertValidSFVec3d(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def geoCenter(self):
        """(deprecated as of v3."""
        return self.__geoCenter
    @geoCenter.setter
    def geoCenter(self, geoCenter):
        if  geoCenter is None:
            geoCenter = (0, 0, 0) # default
        assertValidSFVec3d(geoCenter)
        self.__geoCenter = geoCenter
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"] # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def size(self):
        """[0,+infinity) size of Proximity box."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = (0, 0, 0) # default
        assertValidSFVec3f(size)
        assertNonNegative('size', size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        """[GeoOrigin] Single contained GeoOrigin node that specifies a local coordinate frame for extended precision."""
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin):
        if  geoOrigin is None:
            geoOrigin = None # default
        assertValidSFNode(geoOrigin)
        if not isinstance(geoOrigin, object):
            # print(flush=True)
            raise X3DTypeError(str(geoOrigin) + ' does not have a valid node type object')
        self.__geoOrigin = geoOrigin
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.geoOrigin or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function GeoProximitySensor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<GeoProximitySensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.center != (0, 0, 0):
            result += " center='" + SFVec3d(self.center).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.geoCenter != (0, 0, 0):
            result += " geoCenter='" + SFVec3d(self.geoCenter).XML() + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + MFString(self.geoSystem).XML() + "'"
        if self.size != (0, 0, 0):
            result += " size='" + SFVec3f(self.size).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></GeoProximitySensor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.geoOrigin: # output this SFNode
                result += self.geoOrigin.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</GeoProximitySensor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function GeoProximitySensor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'GeoProximitySensor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'GeoProximitySensor' + ' {'
        if self.center != (0, 0, 0):
            result += " center " + SFVec3d(self.center).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.geoCenter != (0, 0, 0):
            result += " geoCenter " + SFVec3d(self.geoCenter).VRML() + ""
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem " + MFString(self.geoSystem).VRML() + ""
        if self.size != (0, 0, 0):
            result += " size " + SFVec3f(self.size).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.geoOrigin: # output this SFNode
            result += '\n' + '  ' + indent + 'geoOrigin ' + self.geoOrigin.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class GeoTouchSensor(_X3DTouchSensorNode):
    """
    GeoTouchSensor returns geographic coordinates for the object being selected.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'GeoTouchSensor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geospatial.html#GeoTouchSensor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoTouchSensor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DPointingDeviceSensorNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoTouchSensor'),
            ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly, 'GeoTouchSensor'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 enabled=True,
                 geoSystem=["GD", "WE"],
                 geoOrigin=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoTouchSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
        self.geoSystem = geoSystem
        self.geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (G D), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"] # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        """[GeoOrigin] Single contained GeoOrigin node that specifies a local coordinate frame for extended precision."""
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin):
        if  geoOrigin is None:
            geoOrigin = None # default
        assertValidSFNode(geoOrigin)
        if not isinstance(geoOrigin, object):
            # print(flush=True)
            raise X3DTypeError(str(geoOrigin) + ' does not have a valid node type object')
        self.__geoOrigin = geoOrigin
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.geoOrigin or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function GeoTouchSensor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<GeoTouchSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + MFString(self.geoSystem).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></GeoTouchSensor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.geoOrigin: # output this SFNode
                result += self.geoOrigin.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</GeoTouchSensor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function GeoTouchSensor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'GeoTouchSensor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'GeoTouchSensor' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem " + MFString(self.geoSystem).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.geoOrigin: # output this SFNode
            result += '\n' + '  ' + indent + 'geoOrigin ' + self.geoOrigin.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class GeoTransform(_X3DGroupingNode):
    """
    GeoTransform is a Grouping node that can contain most nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'GeoTransform'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geospatial.html#GeoTransform'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoTransform'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('geoCenter', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'GeoTransform'),
            ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoTransform'),
            ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'GeoTransform'),
            ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'GeoTransform'),
            ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'GeoTransform'),
            ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'GeoTransform'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly, 'GeoTransform'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 geoCenter=(0, 0, 0),
                 geoSystem=["GD", "WE"],
                 rotation=(0, 0, 1, 0),
                 scale=(1, 1, 1),
                 scaleOrientation=(0, 0, 1, 0),
                 translation=(0, 0, 0),
                 visible=True,
                 geoOrigin=None,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoTransform __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.geoCenter = geoCenter
        self.geoSystem = geoSystem
        self.rotation = rotation
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.translation = translation
        self.visible = visible
        self.geoOrigin = geoOrigin
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def geoCenter(self):
        """Translation offset from origin of local coordinate system, applied prior to rotation or scaling."""
        return self.__geoCenter
    @geoCenter.setter
    def geoCenter(self, geoCenter):
        if  geoCenter is None:
            geoCenter = (0, 0, 0) # default
        assertValidSFVec3d(geoCenter)
        self.__geoCenter = geoCenter
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"] # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def rotation(self):
        """Orientation (axis, angle in radians) of children relative to local coordinate system."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0) # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        """Non-uniform x-y-z scale of child coordinate system, adjusted by center and scaleOrientation."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = (1, 1, 1) # default
        assertValidSFVec3f(scale)
        assertPositive('scale', scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        """Preliminary rotation of coordinate sys tem before scaling (to allow scaling around arbitrary orientations)."""
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation):
        if  scaleOrientation is None:
            scaleOrientation = (0, 0, 1, 0) # default
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def translation(self):
        """Position (x, y, z in meters) of children relative to local coordinate system."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0) # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        """[GeoOrigin] Single contained GeoOrigin node that specifies a local coordinate frame for extended precision."""
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin):
        if  geoOrigin is None:
            geoOrigin = None # default
        assertValidSFNode(geoOrigin)
        if not isinstance(geoOrigin, object):
            # print(flush=True)
            raise X3DTypeError(str(geoOrigin) + ' does not have a valid node type object')
        self.__geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.geoOrigin or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function GeoTransform.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<GeoTransform'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.geoCenter != (0, 0, 0):
            result += " geoCenter='" + SFVec3d(self.geoCenter).XML() + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + MFString(self.geoSystem).XML() + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + SFRotation(self.rotation).XML() + "'"
        if self.scale != (1, 1, 1):
            result += " scale='" + SFVec3f(self.scale).XML() + "'"
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation='" + SFRotation(self.scaleOrientation).XML() + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + SFVec3f(self.translation).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></GeoTransform>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.geoOrigin: # output this SFNode
                result += self.geoOrigin.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* GeoTransform found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</GeoTransform>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function GeoTransform.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'GeoTransform' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'GeoTransform' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.geoCenter != (0, 0, 0):
            result += " geoCenter " + SFVec3d(self.geoCenter).VRML() + ""
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem " + MFString(self.geoSystem).VRML() + ""
        if self.rotation != (0, 0, 1, 0):
            result += " rotation " + SFRotation(self.rotation).VRML() + ""
        if self.scale != (1, 1, 1):
            result += " scale " + SFVec3f(self.scale).VRML() + ""
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation " + SFRotation(self.scaleOrientation).VRML() + ""
        if self.translation != (0, 0, 0):
            result += " translation " + SFVec3f(self.translation).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.geoOrigin: # output this SFNode
            result += '\n' + '  ' + indent + 'geoOrigin ' + self.geoOrigin.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class GeoViewpoint(_X3DViewpointNode):
    """
    GeoViewpoint specifies viewpoints using geographic coordinates.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'GeoViewpoint'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geospatial.html#GeoViewpoint'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#GeoViewpoint'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('centerOfRotation', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'GeoViewpoint'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DViewpointNode'),
            ('farDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DViewpointNode'),
            ('fieldOfView', 0.7854, FieldType.SFFloat, AccessType.inputOutput, 'GeoViewpoint'),
            ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'GeoViewpoint'),
            ('jump', True, FieldType.SFBool, AccessType.inputOutput, 'X3DViewpointNode'),
            ('nearDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DViewpointNode'),
            ('orientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'X3DViewpointNode'),
            ('position', (0, 0, 100000), FieldType.SFVec3d, AccessType.inputOutput, 'GeoViewpoint'),
            ('retainUserOffsets', False, FieldType.SFBool, AccessType.inputOutput, 'X3DViewpointNode'),
            ('speedFactor', 1.0, FieldType.SFFloat, AccessType.initializeOnly, 'GeoViewpoint'),
            ('viewAll', False, FieldType.SFBool, AccessType.inputOutput, 'X3DViewpointNode'),
            ('geoOrigin', None, FieldType.SFNode, AccessType.initializeOnly, 'GeoViewpoint'),
            ('navigationInfo', None, FieldType.SFNode, AccessType.inputOutput, 'X3DViewpointNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 centerOfRotation=(0, 0, 0),
                 description='',
                 farDistance=-1,
                 fieldOfView=0.7854,
                 geoSystem=["GD", "WE"],
                 jump=True,
                 nearDistance=-1,
                 orientation=(0, 0, 1, 0),
                 position=(0, 0, 100000),
                 retainUserOffsets=False,
                 speedFactor=1.0,
                 viewAll=False,
                 geoOrigin=None,
                 navigationInfo=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode GeoViewpoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.centerOfRotation = centerOfRotation
        self.description = description
        self.farDistance = farDistance
        self.fieldOfView = fieldOfView
        self.geoSystem = geoSystem
        self.jump = jump
        self.nearDistance = nearDistance
        self.orientation = orientation
        self.position = position
        self.retainUserOffsets = retainUserOffsets
        self.speedFactor = speedFactor
        self.viewAll = viewAll
        self.geoOrigin = geoOrigin
        self.navigationInfo = navigationInfo
    @property # getter - - - - - - - - - -
    def centerOfRotation(self):
        """centerOfRotation specifies center point about which to rotate user's eyepoint when in EXAMINE or LOOKAT mode."""
        return self.__centerOfRotation
    @centerOfRotation.setter
    def centerOfRotation(self, centerOfRotation):
        if  centerOfRotation is None:
            centerOfRotation = (0, 0, 0) # default
        assertValidSFVec3d(centerOfRotation)
        self.__centerOfRotation = centerOfRotation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def farDistance(self):
        """or (0,+infinity) farDistance defines maximum clipping plane distance allowed for object display."""
        return self.__farDistance
    @farDistance.setter
    def farDistance(self, farDistance):
        if  farDistance is None:
            farDistance = -1 # default
        assertValidSFFloat(farDistance)
        self.__farDistance = farDistance
    @property # getter - - - - - - - - - -
    def fieldOfView(self):
        """Preferred minimum viewing angle from this viewpoint in radians, providing minimum height or minimum width (whichever is smaller)."""
        return self.__fieldOfView
    @fieldOfView.setter
    def fieldOfView(self, fieldOfView):
        if  fieldOfView is None:
            fieldOfView = 0.7854 # default
        assertValidSFFloat(fieldOfView)
        assertGreaterThan('fieldOfView', fieldOfView, 0)
        assertLessThan('fieldOfView', fieldOfView, 3.1416)
        self.__fieldOfView = fieldOfView
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"] # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def jump(self):
        """Whether to transition instantly by jumping, or else smoothly animate to this Viewpoint."""
        return self.__jump
    @jump.setter
    def jump(self, jump):
        if  jump is None:
            jump = True # default
        assertValidSFBool(jump)
        self.__jump = jump
    @property # getter - - - - - - - - - -
    def nearDistance(self):
        """or (0,+infinity) nearDistance defines minimum clipping plane distance necessary for object display."""
        return self.__nearDistance
    @nearDistance.setter
    def nearDistance(self, nearDistance):
        if  nearDistance is None:
            nearDistance = -1 # default
        assertValidSFFloat(nearDistance)
        self.__nearDistance = nearDistance
    @property # getter - - - - - - - - - -
    def orientation(self):
        """Rotation of Viewpoint, relative to default -Z axis direction in local coordinate system."""
        return self.__orientation
    @orientation.setter
    def orientation(self, orientation):
        if  orientation is None:
            orientation = (0, 0, 1, 0) # default
        assertValidSFRotation(orientation)
        self.__orientation = orientation
    @property # getter - - - - - - - - - -
    def position(self):
        """position relative to local georeferenced coordinate system, in proper format."""
        return self.__position
    @position.setter
    def position(self, position):
        if  position is None:
            position = (0, 0, 100000) # default
        assertValidSFVec3d(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def retainUserOffsets(self):
        """Retain (true) or reset to zero (false) any prior user navigation offsets from defined viewpoint position, orientation."""
        return self.__retainUserOffsets
    @retainUserOffsets.setter
    def retainUserOffsets(self, retainUserOffsets):
        if  retainUserOffsets is None:
            retainUserOffsets = False # default
        assertValidSFBool(retainUserOffsets)
        self.__retainUserOffsets = retainUserOffsets
    @property # getter - - - - - - - - - -
    def speedFactor(self):
        """[0,+infinity) speedFactor is a multiplier to modify the original elevation-based speed that is set automatically by the browser."""
        return self.__speedFactor
    @speedFactor.setter
    def speedFactor(self, speedFactor):
        if  speedFactor is None:
            speedFactor = 1.0 # default
        assertValidSFFloat(speedFactor)
        assertNonNegative('speedFactor', speedFactor)
        self.__speedFactor = speedFactor
    @property # getter - - - - - - - - - -
    def viewAll(self):
        return self.__viewAll
    @viewAll.setter
    def viewAll(self, viewAll):
        if  viewAll is None:
            viewAll = False # default
        assertValidSFBool(viewAll)
        self.__viewAll = viewAll
    @property # getter - - - - - - - - - -
    def geoOrigin(self):
        """[GeoOrigin] Single contained GeoOrigin node that specifies a local coordinate frame for extended precision."""
        return self.__geoOrigin
    @geoOrigin.setter
    def geoOrigin(self, geoOrigin):
        if  geoOrigin is None:
            geoOrigin = None # default
        assertValidSFNode(geoOrigin)
        if not isinstance(geoOrigin, object):
            # print(flush=True)
            raise X3DTypeError(str(geoOrigin) + ' does not have a valid node type object')
        self.__geoOrigin = geoOrigin
    @property # getter - - - - - - - - - -
    def navigationInfo(self):
        return self.__navigationInfo
    @navigationInfo.setter
    def navigationInfo(self, navigationInfo):
        if  navigationInfo is None:
            navigationInfo = None # default
        assertValidSFNode(navigationInfo)
        if not isinstance(navigationInfo, object):
            # print(flush=True)
            raise X3DTypeError(str(navigationInfo) + ' does not have a valid node type object')
        self.__navigationInfo = navigationInfo
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.geoOrigin or self.IS or self.metadata or self.navigationInfo
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function GeoViewpoint.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<GeoViewpoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.centerOfRotation != (0, 0, 0):
            result += " centerOfRotation='" + SFVec3d(self.centerOfRotation).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.farDistance != -1:
            result += " farDistance='" + SFFloat(self.farDistance).XML() + "'"
        if self.fieldOfView != 0.7854:
            result += " fieldOfView='" + SFFloat(self.fieldOfView).XML() + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + MFString(self.geoSystem).XML() + "'"
        if not self.jump: # default=true
            result += " jump='" + SFBool(self.jump).XML() + "'"
        if self.nearDistance != -1:
            result += " nearDistance='" + SFFloat(self.nearDistance).XML() + "'"
        if self.orientation != (0, 0, 1, 0):
            result += " orientation='" + SFRotation(self.orientation).XML() + "'"
        if self.position != (0, 0, 100000):
            result += " position='" + SFVec3d(self.position).XML() + "'"
        if self.retainUserOffsets: # default=false
            result += " retainUserOffsets='" + SFBool(self.retainUserOffsets).XML() + "'"
        if self.speedFactor != 1.0:
            result += " speedFactor='" + SFFloat(self.speedFactor).XML() + "'"
        if self.viewAll: # default=false
            result += " viewAll='" + SFBool(self.viewAll).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></GeoViewpoint>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.geoOrigin: # output this SFNode
                result += self.geoOrigin.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.navigationInfo: # output this SFNode
                result += self.navigationInfo.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</GeoViewpoint>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function GeoViewpoint.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'GeoViewpoint' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'GeoViewpoint' + ' {'
        if self.centerOfRotation != (0, 0, 0):
            result += " centerOfRotation " + SFVec3d(self.centerOfRotation).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.farDistance != -1:
            result += " farDistance " + SFFloat(self.farDistance).VRML() + ""
        if self.fieldOfView != 0.7854:
            result += " fieldOfView " + SFFloat(self.fieldOfView).VRML() + ""
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem " + MFString(self.geoSystem).VRML() + ""
        if not self.jump: # default=true
            result += " jump " + SFBool(self.jump).VRML() + ""
        if self.nearDistance != -1:
            result += " nearDistance " + SFFloat(self.nearDistance).VRML() + ""
        if self.orientation != (0, 0, 1, 0):
            result += " orientation " + SFRotation(self.orientation).VRML() + ""
        if self.position != (0, 0, 100000):
            result += " position " + SFVec3d(self.position).VRML() + ""
        if self.retainUserOffsets: # default=false
            result += " retainUserOffsets " + SFBool(self.retainUserOffsets).VRML() + ""
        if self.speedFactor != 1.0:
            result += " speedFactor " + SFFloat(self.speedFactor).VRML() + ""
        if self.viewAll: # default=false
            result += " viewAll " + SFBool(self.viewAll).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.geoOrigin: # output this SFNode
            result += '\n' + '  ' + indent + 'geoOrigin ' + self.geoOrigin.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.navigationInfo: # output this SFNode
            result += '\n' + '  ' + indent + 'navigationInfo ' + self.navigationInfo.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Group(_X3DGroupingNode):
    """
    Group is a Grouping node that can contain most nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Group'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/grouping.html#Group'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Group'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 visible=True,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Group __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.visible = visible
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Group.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Group'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Group>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* Group found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Group>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Group.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Group' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Group' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class HAnimDisplacer(_X3DGeometricPropertyNode):
    """
    HAnimDisplacer nodes alter the shape of coordinate-based geometry within parent HAnimJoint or HAnimSegment nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'HAnimDisplacer'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/hanim.html#HAnimDisplacer'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#HAnimDisplacer'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('coordIndex', list(), FieldType.MFInt32, AccessType.initializeOnly, 'HAnimDisplacer'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'HAnimDisplacer'),
            ('displacements', list(), FieldType.MFVec3f, AccessType.inputOutput, 'HAnimDisplacer'),
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'HAnimDisplacer'),
            ('weight', 0.0, FieldType.SFFloat, AccessType.inputOutput, 'HAnimDisplacer'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 coordIndex=list(),
                 description='',
                 displacements=list(),
                 name='',
                 weight=0.0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode HAnimDisplacer __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.coordIndex = coordIndex
        self.description = description
        self.displacements = displacements
        self.name = name
        self.weight = weight
    @property # getter - - - - - - - - - -
    def coordIndex(self):
        """[0,+infinity) Defines index values into the parent HAnimSegment or HAnimBody/HAnimHumanoid coordinate array for the mesh of vertices affected by this HAnimDisplacer."""
        return self.__coordIndex
    @coordIndex.setter
    def coordIndex(self, coordIndex):
        if  coordIndex is None:
            coordIndex = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(coordIndex)
        assertNonNegative('coordIndex', coordIndex)
        self.__coordIndex = coordIndex
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def displacements(self):
        """displacements are a set of SFVec3f values added to neutral/resting position of each of the corresponding HAnimSegment vertices (or HAnimJoint/HAnimHumanoid vertices) referenced by coordIndex field."""
        return self.__displacements
    @displacements.setter
    def displacements(self, displacements):
        if  displacements is None:
            displacements = MFVec3f.DEFAULT_VALUE(self)
        assertValidMFVec3f(displacements)
        self.__displacements = displacements
    @property # getter - - - - - - - - - -
    def name(self):
        """Unique name attribute must be defined so that HAnimDisplacer node can be identified at run time for animation purposes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def weight(self):
        """The weigh factor has typical range [0,1] and defines the scale factor applied to displacement values before adding them to neutral vertex positions."""
        return self.__weight
    @weight.setter
    def weight(self, weight):
        if  weight is None:
            weight = 0.0 # default
        assertValidSFFloat(weight)
        self.__weight = weight
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function HAnimDisplacer.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<HAnimDisplacer'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.coordIndex != list():
            result += " coordIndex='" + MFInt32(self.coordIndex).XML() + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.displacements != list():
            result += " displacements='" + MFVec3f(self.displacements).XML() + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.weight != 0.0:
            result += " weight='" + SFFloat(self.weight).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></HAnimDisplacer>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</HAnimDisplacer>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function HAnimDisplacer.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'HAnimDisplacer' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'HAnimDisplacer' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.coordIndex != list():
            result += " coordIndex " + MFInt32(self.coordIndex).VRML() + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.displacements != list():
            result += " displacements " + MFVec3f(self.displacements).VRML() + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if self.weight != 0.0:
            result += " weight " + SFFloat(self.weight).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class HAnimHumanoid(_X3DChildNode, _X3DBoundedObject):
    """
    The HAnimHumanoid node is used to: (a) store references to the joints, segments, sites, skeleton, optional skin, and fixed viewpoints, (b) serve as a container for the entire humanoid, (c) provide a convenient way of moving the humanoid through its environment, and (d) store human-readable metadata such as name, version, author, copyright, age, gender and other information.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'HAnimHumanoid'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/hanim.html#HAnimHumanoid'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#HAnimHumanoid'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimHumanoid'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'HAnimHumanoid'),
            ('info', list(), FieldType.MFString, AccessType.inputOutput, 'HAnimHumanoid'),
            ('jointBindingPositions', [(0, 0, 0)], FieldType.MFVec3f, AccessType.inputOutput, 'HAnimHumanoid'),
            ('jointBindingRotations', [(0, 0, 1, 0)], FieldType.MFRotation, AccessType.inputOutput, 'HAnimHumanoid'),
            ('jointBindingScales', [(0, 0, 0)], FieldType.MFVec3f, AccessType.inputOutput, 'HAnimHumanoid'),
            ('loa', -1, FieldType.SFInt32, AccessType.inputOutput, 'HAnimHumanoid'),
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'HAnimHumanoid'),
            ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'HAnimHumanoid'),
            ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimHumanoid'),
            ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'HAnimHumanoid'),
            ('skeletalConfiguration', 'BASIC', FieldType.SFString, AccessType.inputOutput, 'HAnimHumanoid'),
            ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimHumanoid'),
            ('version', '2.0', FieldType.SFString, AccessType.inputOutput, 'HAnimHumanoid'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('skinBindingCoords', None, FieldType.SFNode, AccessType.inputOutput, 'HAnimHumanoid'),
            ('skinBindingNormals', None, FieldType.SFNode, AccessType.inputOutput, 'HAnimHumanoid'),
            ('skinCoord', None, FieldType.SFNode, AccessType.inputOutput, 'HAnimHumanoid'),
            ('skinNormal', None, FieldType.SFNode, AccessType.inputOutput, 'HAnimHumanoid'),
            ('joints', list(), FieldType.MFNode, AccessType.inputOutput, 'HAnimHumanoid'),
            ('motions', list(), FieldType.MFNode, AccessType.inputOutput, 'HAnimHumanoid'),
            ('segments', list(), FieldType.MFNode, AccessType.inputOutput, 'HAnimHumanoid'),
            ('sites', list(), FieldType.MFNode, AccessType.inputOutput, 'HAnimHumanoid'),
            ('skeleton', list(), FieldType.MFNode, AccessType.inputOutput, 'HAnimHumanoid'),
            ('skin', list(), FieldType.MFNode, AccessType.inputOutput, 'HAnimHumanoid'),
            ('viewpoints', list(), FieldType.MFNode, AccessType.inputOutput, 'HAnimHumanoid'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 center=(0, 0, 0),
                 description='',
                 info=list(),
                 jointBindingPositions=[(0, 0, 0)],
                 jointBindingRotations=[(0, 0, 1, 0)],
                 jointBindingScales=[(0, 0, 0)],
                 loa=-1,
                 name='',
                 rotation=(0, 0, 1, 0),
                 scale=(1, 1, 1),
                 scaleOrientation=(0, 0, 1, 0),
                 skeletalConfiguration='BASIC',
                 translation=(0, 0, 0),
                 version='2.0',
                 visible=True,
                 skinBindingCoords=None,
                 skinBindingNormals=None,
                 skinCoord=None,
                 skinNormal=None,
                 joints=None,
                 motions=None,
                 segments=None,
                 sites=None,
                 skeleton=None,
                 skin=None,
                 viewpoints=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode HAnimHumanoid __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.center = center
        self.description = description
        self.info = info
        self.jointBindingPositions = jointBindingPositions
        self.jointBindingRotations = jointBindingRotations
        self.jointBindingScales = jointBindingScales
        self.loa = loa
        self.name = name
        self.rotation = rotation
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.skeletalConfiguration = skeletalConfiguration
        self.translation = translation
        self.version = version
        self.visible = visible
        self.skinBindingCoords = skinBindingCoords
        self.skinBindingNormals = skinBindingNormals
        self.skinCoord = skinCoord
        self.skinNormal = skinNormal
        self.joints = joints
        self.motions = motions
        self.segments = segments
        self.sites = sites
        self.skeleton = skeleton
        self.skin = skin
        self.viewpoints = viewpoints
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        """Translation offset from origin of local coordinate system."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0) # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def info(self):
        """Contains metadata keyword=value pairs, where approved keyword terms are humanoidVersion authorName authorEmail copyright creationDate usageRestrictions age gender height and weight."""
        return self.__info
    @info.setter
    def info(self, info):
        if  info is None:
            info = MFString.DEFAULT_VALUE(self)
        assertValidMFString(info)
        self.__info = info
    @property # getter - - - - - - - - - -
    def jointBindingPositions(self):
        """Specifies an array of position values for each HAnimJoint node in the joints field, in order, corresponding to each binding pose."""
        return self.__jointBindingPositions
    @jointBindingPositions.setter
    def jointBindingPositions(self, jointBindingPositions):
        if  jointBindingPositions is None:
            jointBindingPositions = [(0, 0, 0)] # default
        assertValidMFVec3f(jointBindingPositions)
        self.__jointBindingPositions = jointBindingPositions
    @property # getter - - - - - - - - - -
    def jointBindingRotations(self):
        """Specifies an array of rotation values for each HAnimJoint node in the joints field, in order, corresponding to each binding pose."""
        return self.__jointBindingRotations
    @jointBindingRotations.setter
    def jointBindingRotations(self, jointBindingRotations):
        if  jointBindingRotations is None:
            jointBindingRotations = [(0, 0, 1, 0)] # default
        assertValidMFRotation(jointBindingRotations)
        self.__jointBindingRotations = jointBindingRotations
    @property # getter - - - - - - - - - -
    def jointBindingScales(self):
        """Specifies an array of scale values for each HAnimJoint node in the joints field, in order, corresponding to each binding pose."""
        return self.__jointBindingScales
    @jointBindingScales.setter
    def jointBindingScales(self, jointBindingScales):
        if  jointBindingScales is None:
            jointBindingScales = [(0, 0, 0)] # default
        assertValidMFVec3f(jointBindingScales)
        self.__jointBindingScales = jointBindingScales
    @property # getter - - - - - - - - - -
    def loa(self):
        """[-1,4] Level Of Articulation 0."""
        return self.__loa
    @loa.setter
    def loa(self, loa):
        if  loa is None:
            loa = -1 # default
        assertValidSFInt32(loa)
        assertGreaterThanEquals('loa', loa, -1)
        assertLessThanEquals('loa', loa, 4)
        self.__loa = loa
    @property # getter - - - - - - - - - -
    def name(self):
        """Unique name attribute must be defined so that each HAnimHumanoid node in a scene can be identified at run time for animation purposes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def rotation(self):
        """Orientation of children relative to local coordinate system."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0) # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        """Non-uniform x-y-z scale of child coordinate system, adjusted by center and scaleOrientation."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = (1, 1, 1) # default
        assertValidSFVec3f(scale)
        assertPositive('scale', scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        """Preliminary rotation of coordinate system before scaling (to allow scaling around arbitrary orientations)."""
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation):
        if  scaleOrientation is None:
            scaleOrientation = (0, 0, 1, 0) # default
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def skeletalConfiguration(self):
        """Models sharing a common skeletal configuration can share animations and binding poses."""
        return self.__skeletalConfiguration
    @skeletalConfiguration.setter
    def skeletalConfiguration(self, skeletalConfiguration):
        if  skeletalConfiguration is None:
            skeletalConfiguration = 'BASIC' # default
        assertValidSFString(skeletalConfiguration)
        self.__skeletalConfiguration = skeletalConfiguration
    @property # getter - - - - - - - - - -
    def translation(self):
        """Position of children relative to local coordinate system."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0) # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def version(self):
        """HAnimHumanoid version, where value is 1."""
        return self.__version
    @version.setter
    def version(self, version):
        if  version is None:
            version = '2.0' # default
        assertValidSFString(version)
        assertValidHanimVersion('version', version)
        self.__version = version
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def skinBindingCoords(self):
        """[X3DCoordinateNode] Array of Coordinate nodes to handle non-default source pose so that both skin and skeleton can be in same binding pose."""
        return self.__skinBindingCoords
    @skinBindingCoords.setter
    def skinBindingCoords(self, skinBindingCoords):
        if  skinBindingCoords is None:
            skinBindingCoords = None # default
        assertValidSFNode(skinBindingCoords)
        if not isinstance(skinBindingCoords, object):
            # print(flush=True)
            raise X3DTypeError(str(skinBindingCoords) + ' does not have a valid node type object')
        self.__skinBindingCoords = skinBindingCoords
    @property # getter - - - - - - - - - -
    def skinBindingNormals(self):
        """[X3DNormalNode] Array of Normal nodes to handle non-default source pose so that both skin and skeleton can be in same binding pose."""
        return self.__skinBindingNormals
    @skinBindingNormals.setter
    def skinBindingNormals(self, skinBindingNormals):
        if  skinBindingNormals is None:
            skinBindingNormals = None # default
        assertValidSFNode(skinBindingNormals)
        if not isinstance(skinBindingNormals, object):
            # print(flush=True)
            raise X3DTypeError(str(skinBindingNormals) + ' does not have a valid node type object')
        self.__skinBindingNormals = skinBindingNormals
    @property # getter - - - - - - - - - -
    def skinCoord(self):
        """[X3DCoordinateNode] Coordinate node utilized by indexed mesh definitions for skin."""
        return self.__skinCoord
    @skinCoord.setter
    def skinCoord(self, skinCoord):
        if  skinCoord is None:
            skinCoord = None # default
        assertValidSFNode(skinCoord)
        if not isinstance(skinCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(skinCoord) + ' does not have a valid node type object')
        self.__skinCoord = skinCoord
    @property # getter - - - - - - - - - -
    def skinNormal(self):
        """[X3DNormalNode] Single Normal node utilized by indexed mesh definitions for skin."""
        return self.__skinNormal
    @skinNormal.setter
    def skinNormal(self, skinNormal):
        if  skinNormal is None:
            skinNormal = None # default
        assertValidSFNode(skinNormal)
        if not isinstance(skinNormal, object):
            # print(flush=True)
            raise X3DTypeError(str(skinNormal) + ' does not have a valid node type object')
        self.__skinNormal = skinNormal
    @property # getter - - - - - - - - - -
    def joints(self):
        """[HAnimJoint] The joints field contains a list of USE references for all HAnimJoint node instances found within the preceding skeleton hierarchy."""
        return self.__joints
    @joints.setter
    def joints(self, joints):
        if  joints is None:
            joints = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(joints)
        self.__joints = joints
    @property # getter - - - - - - - - - -
    def motions(self):
        """[HAnimMotion] Contains any HAnimMotion nodes that can animate the HAnimHumanoid."""
        return self.__motions
    @motions.setter
    def motions(self, motions):
        if  motions is None:
            motions = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(motions)
        self.__motions = motions
    @property # getter - - - - - - - - - -
    def segments(self):
        """[HAnimSegment] The segments field contains a list of USE references for all HAnimSegment node instances found within the preceding skeleton hierarchy."""
        return self.__segments
    @segments.setter
    def segments(self, segments):
        if  segments is None:
            segments = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(segments)
        self.__segments = segments
    @property # getter - - - - - - - - - -
    def sites(self):
        """[HAnimSite] sites field contains a list of USE references for all HAnimSite node instances found within the preceding skeleton hierarchy."""
        return self.__sites
    @sites.setter
    def sites(self, sites):
        if  sites is None:
            sites = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(sites)
        self.__sites = sites
    @property # getter - - - - - - - - - -
    def skeleton(self):
        """[HAnimJoint|HAnimSite] List of top-level HAnimJoint and HAnimSite nodes that create the skeleton model."""
        return self.__skeleton
    @skeleton.setter
    def skeleton(self, skeleton):
        if  skeleton is None:
            skeleton = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(skeleton)
        self.__skeleton = skeleton
    @property # getter - - - - - - - - - -
    def skin(self):
        """[IndexedFaceSet|Group|Transform|Shape] List of one or more indexed mesh definitions (such as IndexedFaceSet) that utilize skinCoord point and skinNormal normal data."""
        return self.__skin
    @skin.setter
    def skin(self, skin):
        if  skin is None:
            skin = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(skin)
        self.__skin = skin
    @property # getter - - - - - - - - - -
    def viewpoints(self):
        """[HAnimSite] List of HAnimSite nodes containing Viewpoint nodes that appear in the skeleton model, usually as USE node references."""
        return self.__viewpoints
    @viewpoints.setter
    def viewpoints(self, viewpoints):
        if  viewpoints is None:
            viewpoints = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(viewpoints)
        self.__viewpoints = viewpoints
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.joints or self.motions or self.segments or self.sites or self.skeleton or self.skin or self.viewpoints or self.IS or self.metadata or self.skinBindingCoords or self.skinBindingNormals or self.skinCoord or self.skinNormal
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function HAnimHumanoid.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<HAnimHumanoid'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.center != (0, 0, 0):
            result += " center='" + SFVec3f(self.center).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.info != list():
            result += " info='" + MFString(self.info).XML() + "'"
        if self.jointBindingPositions != [(0, 0, 0)]:
            result += " jointBindingPositions='" + MFVec3f(self.jointBindingPositions).XML() + "'"
        if self.jointBindingRotations != [(0, 0, 1, 0)]:
            result += " jointBindingRotations='" + MFRotation(self.jointBindingRotations).XML() + "'"
        if self.jointBindingScales != [(0, 0, 0)]:
            result += " jointBindingScales='" + MFVec3f(self.jointBindingScales).XML() + "'"
        if self.loa != -1:
            result += " loa='" + SFInt32(self.loa).XML() + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + SFRotation(self.rotation).XML() + "'"
        if self.scale != (1, 1, 1):
            result += " scale='" + SFVec3f(self.scale).XML() + "'"
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation='" + SFRotation(self.scaleOrientation).XML() + "'"
        if self.skeletalConfiguration != 'BASIC':
            result += " skeletalConfiguration='" + self.skeletalConfiguration + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + SFVec3f(self.translation).XML() + "'"
        if self.version != '2.0':
            result += " version='" + self.version + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></HAnimHumanoid>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.skinBindingCoords: # output this SFNode
                result += self.skinBindingCoords.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.skinBindingNormals: # output this SFNode
                result += self.skinBindingNormals.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.skinCoord: # output this SFNode
                result += self.skinCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.skinNormal: # output this SFNode
                result += self.skinNormal.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.joints: # walk each child in MFNode list, if any
            ### print('* HAnimHumanoid found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(joints)=' + str(len(self.joints)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.joints:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.motions: # walk each child in MFNode list, if any
            ### print('* HAnimHumanoid found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(motions)=' + str(len(self.motions)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.motions:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.segments: # walk each child in MFNode list, if any
            ### print('* HAnimHumanoid found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(segments)=' + str(len(self.segments)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.segments:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.sites: # walk each child in MFNode list, if any
            ### print('* HAnimHumanoid found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(sites)=' + str(len(self.sites)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.sites:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.skeleton: # walk each child in MFNode list, if any
            ### print('* HAnimHumanoid found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(skeleton)=' + str(len(self.skeleton)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.skeleton:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.skin: # walk each child in MFNode list, if any
            ### print('* HAnimHumanoid found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(skin)=' + str(len(self.skin)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.skin:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.viewpoints: # walk each child in MFNode list, if any
            ### print('* HAnimHumanoid found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(viewpoints)=' + str(len(self.viewpoints)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.viewpoints:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</HAnimHumanoid>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function HAnimHumanoid.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'HAnimHumanoid' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'HAnimHumanoid' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.center != (0, 0, 0):
            result += " center " + SFVec3f(self.center).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.info != list():
            result += " info " + MFString(self.info).VRML() + ""
        if self.jointBindingPositions != [(0, 0, 0)]:
            result += " jointBindingPositions " + MFVec3f(self.jointBindingPositions).VRML() + ""
        if self.jointBindingRotations != [(0, 0, 1, 0)]:
            result += " jointBindingRotations " + MFRotation(self.jointBindingRotations).VRML() + ""
        if self.jointBindingScales != [(0, 0, 0)]:
            result += " jointBindingScales " + MFVec3f(self.jointBindingScales).VRML() + ""
        if self.loa != -1:
            result += " loa " + SFInt32(self.loa).VRML() + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if self.rotation != (0, 0, 1, 0):
            result += " rotation " + SFRotation(self.rotation).VRML() + ""
        if self.scale != (1, 1, 1):
            result += " scale " + SFVec3f(self.scale).VRML() + ""
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation " + SFRotation(self.scaleOrientation).VRML() + ""
        if self.skeletalConfiguration != 'BASIC':
            result += " skeletalConfiguration " +  '"' + self.skeletalConfiguration + '"' + ""
        if self.translation != (0, 0, 0):
            result += " translation " + SFVec3f(self.translation).VRML() + ""
        if self.version != '2.0':
            result += " version " +  '"' + self.version + '"' + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.skinBindingCoords: # output this SFNode
            result += '\n' + '  ' + indent + 'skinBindingCoords ' + self.skinBindingCoords.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.skinBindingNormals: # output this SFNode
            result += '\n' + '  ' + indent + 'skinBindingNormals ' + self.skinBindingNormals.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.skinCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'skinCoord ' + self.skinCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.skinNormal: # output this SFNode
            result += '\n' + '  ' + indent + 'skinNormal ' + self.skinNormal.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.joints: # walk each child in MFNode list, if any
            for each in self.joints:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.motions: # walk each child in MFNode list, if any
            for each in self.motions:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.segments: # walk each child in MFNode list, if any
            for each in self.segments:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.sites: # walk each child in MFNode list, if any
            for each in self.sites:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.skeleton: # walk each child in MFNode list, if any
            for each in self.skeleton:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.skin: # walk each child in MFNode list, if any
            for each in self.skin:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.viewpoints: # walk each child in MFNode list, if any
            for each in self.viewpoints:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class HAnimJoint(_X3DChildNode, _X3DBoundedObject):
    """
    HAnimJoint node can represent each joint in a body.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'HAnimJoint'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/hanim.html#HAnimJoint'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#HAnimJoint'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimJoint'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'HAnimJoint'),
            ('limitOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'HAnimJoint'),
            ('llimit', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimJoint'),
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'HAnimJoint'),
            ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'HAnimJoint'),
            ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimJoint'),
            ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'HAnimJoint'),
            ('skinCoordIndex', list(), FieldType.MFInt32, AccessType.inputOutput, 'HAnimJoint'),
            ('skinCoordWeight', list(), FieldType.MFFloat, AccessType.inputOutput, 'HAnimJoint'),
            ('stiffness', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimJoint'),
            ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimJoint'),
            ('ulimit', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimJoint'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'HAnimJoint'),
            ('displacers', list(), FieldType.MFNode, AccessType.inputOutput, 'HAnimJoint'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 center=(0, 0, 0),
                 description='',
                 limitOrientation=(0, 0, 1, 0),
                 llimit=(0, 0, 0),
                 name='',
                 rotation=(0, 0, 1, 0),
                 scale=(1, 1, 1),
                 scaleOrientation=(0, 0, 1, 0),
                 skinCoordIndex=list(),
                 skinCoordWeight=list(),
                 stiffness=(1, 1, 1),
                 translation=(0, 0, 0),
                 ulimit=(0, 0, 0),
                 visible=True,
                 children=None,
                 displacers=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode HAnimJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.center = center
        self.description = description
        self.limitOrientation = limitOrientation
        self.llimit = llimit
        self.name = name
        self.rotation = rotation
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.skinCoordIndex = skinCoordIndex
        self.skinCoordWeight = skinCoordWeight
        self.stiffness = stiffness
        self.translation = translation
        self.ulimit = ulimit
        self.visible = visible
        self.children = children
        self.displacers = displacers
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        """Translation offset from origin of local coordinate system."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0) # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def limitOrientation(self):
        """Orientation of upper/lower rotation limits, relative to HAnimJoint center."""
        return self.__limitOrientation
    @limitOrientation.setter
    def limitOrientation(self, limitOrientation):
        if  limitOrientation is None:
            limitOrientation = (0, 0, 1, 0) # default
        assertValidSFRotation(limitOrientation)
        self.__limitOrientation = limitOrientation
    @property # getter - - - - - - - - - -
    def llimit(self):
        """Lower limit for minimum joint rotation in radians."""
        return self.__llimit
    @llimit.setter
    def llimit(self, llimit):
        if  llimit is None:
            llimit = (0, 0, 0) # default
        assertValidSFVec3f(llimit)
        self.__llimit = llimit
    @property # getter - - - - - - - - - -
    def name(self):
        """Unique name attribute must be defined so that HAnimJoint node can be identified at run time for animation purposes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def rotation(self):
        """Orientation of children relative to local coordinate system."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0) # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        """Non-uniform x-y-z scale of child coordinate system, adjusted by center and scaleOrientation."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = (1, 1, 1) # default
        assertValidSFVec3f(scale)
        assertPositive('scale', scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        """Preliminary rotation of coordinate system before scaling (to allow scaling around arbitrary orientations)."""
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation):
        if  scaleOrientation is None:
            scaleOrientation = (0, 0, 1, 0) # default
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def skinCoordIndex(self):
        """[0,+infinity) Coordinate index values referencing which vertices are influenced by the HAnimJoint."""
        return self.__skinCoordIndex
    @skinCoordIndex.setter
    def skinCoordIndex(self, skinCoordIndex):
        if  skinCoordIndex is None:
            skinCoordIndex = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(skinCoordIndex)
        assertNonNegative('skinCoordIndex', skinCoordIndex)
        self.__skinCoordIndex = skinCoordIndex
    @property # getter - - - - - - - - - -
    def skinCoordWeight(self):
        """Weight deformation values for the corresponding values in the skinCoordIndex field."""
        return self.__skinCoordWeight
    @skinCoordWeight.setter
    def skinCoordWeight(self, skinCoordWeight):
        if  skinCoordWeight is None:
            skinCoordWeight = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(skinCoordWeight)
        self.__skinCoordWeight = skinCoordWeight
    @property # getter - - - - - - - - - -
    def stiffness(self):
        """[0,1] A scale factor of (1 - stiffness) is applied around the corresponding axis (X, Y, or Z for entries 0, 1 and 2 of the stiffness field)."""
        return self.__stiffness
    @stiffness.setter
    def stiffness(self, stiffness):
        if  stiffness is None:
            stiffness = (1, 1, 1) # default
        assertValidSFVec3f(stiffness)
        assertZeroToOne('stiffness', stiffness)
        self.__stiffness = stiffness
    @property # getter - - - - - - - - - -
    def translation(self):
        """Position of children relative to local coordinate system."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0) # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def ulimit(self):
        """Upper limit for maximum joint rotation in radians."""
        return self.__ulimit
    @ulimit.setter
    def ulimit(self, ulimit):
        if  ulimit is None:
            ulimit = (0, 0, 0) # default
        assertValidSFVec3f(ulimit)
        self.__ulimit = ulimit
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[HAnimJoint|HAnimSegment|HAnimSite] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def displacers(self):
        """[HAnimDisplacer] the displacers field stores HAnimDisplacer objects for a particular HAnimJoint object."""
        return self.__displacers
    @displacers.setter
    def displacers(self, displacers):
        if  displacers is None:
            displacers = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(displacers)
        self.__displacers = displacers
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.displacers or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function HAnimJoint.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<HAnimJoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.center != (0, 0, 0):
            result += " center='" + SFVec3f(self.center).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.limitOrientation != (0, 0, 1, 0):
            result += " limitOrientation='" + SFRotation(self.limitOrientation).XML() + "'"
        if self.llimit != (0, 0, 0):
            result += " llimit='" + SFVec3f(self.llimit).XML() + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + SFRotation(self.rotation).XML() + "'"
        if self.scale != (1, 1, 1):
            result += " scale='" + SFVec3f(self.scale).XML() + "'"
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation='" + SFRotation(self.scaleOrientation).XML() + "'"
        if self.skinCoordIndex != list():
            result += " skinCoordIndex='" + MFInt32(self.skinCoordIndex).XML() + "'"
        if self.skinCoordWeight != list():
            result += " skinCoordWeight='" + MFFloat(self.skinCoordWeight).XML() + "'"
        if self.stiffness != (1, 1, 1):
            result += " stiffness='" + SFVec3f(self.stiffness).XML() + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + SFVec3f(self.translation).XML() + "'"
        if self.ulimit != (0, 0, 0):
            result += " ulimit='" + SFVec3f(self.ulimit).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></HAnimJoint>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* HAnimJoint found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.displacers: # walk each child in MFNode list, if any
            ### print('* HAnimJoint found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(displacers)=' + str(len(self.displacers)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.displacers:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</HAnimJoint>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function HAnimJoint.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'HAnimJoint' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'HAnimJoint' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.center != (0, 0, 0):
            result += " center " + SFVec3f(self.center).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.limitOrientation != (0, 0, 1, 0):
            result += " limitOrientation " + SFRotation(self.limitOrientation).VRML() + ""
        if self.llimit != (0, 0, 0):
            result += " llimit " + SFVec3f(self.llimit).VRML() + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if self.rotation != (0, 0, 1, 0):
            result += " rotation " + SFRotation(self.rotation).VRML() + ""
        if self.scale != (1, 1, 1):
            result += " scale " + SFVec3f(self.scale).VRML() + ""
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation " + SFRotation(self.scaleOrientation).VRML() + ""
        if self.skinCoordIndex != list():
            result += " skinCoordIndex " + MFInt32(self.skinCoordIndex).VRML() + ""
        if self.skinCoordWeight != list():
            result += " skinCoordWeight " + MFFloat(self.skinCoordWeight).VRML() + ""
        if self.stiffness != (1, 1, 1):
            result += " stiffness " + SFVec3f(self.stiffness).VRML() + ""
        if self.translation != (0, 0, 0):
            result += " translation " + SFVec3f(self.translation).VRML() + ""
        if self.ulimit != (0, 0, 0):
            result += " ulimit " + SFVec3f(self.ulimit).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.displacers: # walk each child in MFNode list, if any
            for each in self.displacers:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class HAnimMotion(_X3DChildNode):
    """
    An HAnimMotion node supports discrete frame-by-frame playback for H-Anim motion data animation.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'HAnimMotion'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/documents/specifications/19774/V2.0/MotionDataAnimation/MotionNodes.html#MotionObject'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#HAnimMotion'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('channels', list(), FieldType.MFString, AccessType.inputOutput, 'HAnimMotion'),
            ('channelsEnabled', list(), FieldType.MFBool, AccessType.inputOutput, 'HAnimMotion'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'HAnimMotion'),
            ('enabled', False, FieldType.SFBool, AccessType.inputOutput, 'HAnimMotion'),
            ('endFrame', 0, FieldType.SFInt32, AccessType.inputOutput, 'HAnimMotion'),
            ('frameCount', 0, FieldType.SFInt32, AccessType.inputOutput, 'HAnimMotion'),
            ('frameDuration', 0.1, FieldType.SFTime, AccessType.inputOutput, 'HAnimMotion'),
            ('frameIncrement', 1, FieldType.SFInt32, AccessType.inputOutput, 'HAnimMotion'),
            ('frameIndex', 0, FieldType.SFInt32, AccessType.inputOutput, 'HAnimMotion'),
            ('joints', list(), FieldType.MFString, AccessType.inputOutput, 'HAnimMotion'),
            ('loa', -1, FieldType.SFInt32, AccessType.inputOutput, 'HAnimMotion'),
            ('loop', False, FieldType.SFBool, AccessType.inputOutput, 'HAnimMotion'),
            ('startFrame', 0, FieldType.SFInt32, AccessType.inputOutput, 'HAnimMotion'),
            ('values', list(), FieldType.MFFloat, AccessType.inputOutput, 'HAnimMotion'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 channels=list(),
                 channelsEnabled=list(),
                 description='',
                 enabled=False,
                 endFrame=0,
                 frameCount=0,
                 frameDuration=0.1,
                 frameIncrement=1,
                 frameIndex=0,
                 joints=list(),
                 loa=-1,
                 loop=False,
                 startFrame=0,
                 values=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode HAnimMotion __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.channels = channels
        self.channelsEnabled = channelsEnabled
        self.description = description
        self.enabled = enabled
        self.endFrame = endFrame
        self.frameCount = frameCount
        self.frameDuration = frameDuration
        self.frameIncrement = frameIncrement
        self.frameIndex = frameIndex
        self.joints = joints
        self.loa = loa
        self.loop = loop
        self.startFrame = startFrame
        self.values = values
    @property # getter - - - - - - - - - -
    def channels(self):
        """list of number of channels for transformation, followed by transformation type of each channel of data."""
        return self.__channels
    @channels.setter
    def channels(self, channels):
        if  channels is None:
            channels = MFString.DEFAULT_VALUE(self)
        assertValidMFString(channels)
        self.__channels = channels
    @property # getter - - - - - - - - - -
    def channelsEnabled(self):
        """boolean values for each channels indicating whether enabled."""
        return self.__channelsEnabled
    @channelsEnabled.setter
    def channelsEnabled(self, channelsEnabled):
        if  channelsEnabled is None:
            channelsEnabled = MFBool.DEFAULT_VALUE(self)
        assertValidMFBool(channelsEnabled)
        self.__channelsEnabled = channelsEnabled
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = False # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def endFrame(self):
        """[0,+infinity) endFrame indicates final index of animated frame."""
        return self.__endFrame
    @endFrame.setter
    def endFrame(self, endFrame):
        if  endFrame is None:
            endFrame = 0 # default
        assertValidSFInt32(endFrame)
        assertNonNegative('endFrame', endFrame)
        self.__endFrame = endFrame
    @property # getter - - - - - - - - - -
    def frameCount(self):
        """[0,+infinity) frameCount indicates the number of frames present in the animation, equaling the number of sets of channel data present in the values array."""
        return self.__frameCount
    @frameCount.setter
    def frameCount(self, frameCount):
        if  frameCount is None:
            frameCount = 0 # default
        assertValidSFInt32(frameCount)
        assertNonNegative('frameCount', frameCount)
        self.__frameCount = frameCount
    @property # getter - - - - - - - - - -
    def frameDuration(self):
        """(0,+infinity) frameDuration specifies the duration of each frame in seconds."""
        return self.__frameDuration
    @frameDuration.setter
    def frameDuration(self, frameDuration):
        if  frameDuration is None:
            frameDuration = 0.1 # default
        assertValidSFTime(frameDuration)
        assertPositive('frameDuration', frameDuration)
        self.__frameDuration = frameDuration
    @property # getter - - - - - - - - - -
    def frameIncrement(self):
        """[-infinity,+infinity) frameIncrement field controls whether playback direction is forwards or backwards, and also whether frames are skipped (e."""
        return self.__frameIncrement
    @frameIncrement.setter
    def frameIncrement(self, frameIncrement):
        if  frameIncrement is None:
            frameIncrement = 1 # default
        assertValidSFInt32(frameIncrement)
        self.__frameIncrement = frameIncrement
    @property # getter - - - - - - - - - -
    def frameIndex(self):
        """[0,+infinity) frameIndex indicates index of current frame."""
        return self.__frameIndex
    @frameIndex.setter
    def frameIndex(self, frameIndex):
        if  frameIndex is None:
            frameIndex = 0 # default
        assertValidSFInt32(frameIndex)
        assertNonNegative('frameIndex', frameIndex)
        self.__frameIndex = frameIndex
    @property # getter - - - - - - - - - -
    def joints(self):
        """joints field lists names of joints that raw motion data is to be applied to."""
        return self.__joints
    @joints.setter
    def joints(self, joints):
        if  joints is None:
            joints = MFString.DEFAULT_VALUE(self)
        assertValidMFString(joints)
        self.__joints = joints
    @property # getter - - - - - - - - - -
    def loa(self):
        """[-1,4] Level Of Articulation 0."""
        return self.__loa
    @loa.setter
    def loa(self, loa):
        if  loa is None:
            loa = -1 # default
        assertValidSFInt32(loa)
        assertGreaterThanEquals('loa', loa, -1)
        assertLessThanEquals('loa', loa, 4)
        self.__loa = loa
    @property # getter - - - - - - - - - -
    def loop(self):
        """Repeat indefinitely when loop=true, repeat only once when loop=false."""
        return self.__loop
    @loop.setter
    def loop(self, loop):
        if  loop is None:
            loop = False # default
        assertValidSFBool(loop)
        self.__loop = loop
    @property # getter - - - - - - - - - -
    def startFrame(self):
        """[0,+infinity) startFrame indicates initial index of animated frame."""
        return self.__startFrame
    @startFrame.setter
    def startFrame(self, startFrame):
        if  startFrame is None:
            startFrame = 0 # default
        assertValidSFInt32(startFrame)
        assertNonNegative('startFrame', startFrame)
        self.__startFrame = startFrame
    @property # getter - - - - - - - - - -
    def values(self):
        """values field contains all transformation values, ordered first by frame, then by joint, and then by transformation Sets of floats in the values array matching the order listed in joints and channels fields."""
        return self.__values
    @values.setter
    def values(self, values):
        if  values is None:
            values = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(values)
        self.__values = values
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function HAnimMotion.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<HAnimMotion'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.channels != list():
            result += " channels='" + MFString(self.channels).XML() + "'"
        if self.channelsEnabled != list():
            result += " channelsEnabled='" + MFBool(self.channelsEnabled).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.enabled: # default=false
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.endFrame != 0:
            result += " endFrame='" + SFInt32(self.endFrame).XML() + "'"
        if self.frameCount != 0:
            result += " frameCount='" + SFInt32(self.frameCount).XML() + "'"
        if self.frameDuration != 0.1:
            result += " frameDuration='" + SFTime(self.frameDuration).XML() + "'"
        if self.frameIncrement != 1:
            result += " frameIncrement='" + SFInt32(self.frameIncrement).XML() + "'"
        if self.frameIndex != 0:
            result += " frameIndex='" + SFInt32(self.frameIndex).XML() + "'"
        if self.joints != list():
            result += " joints='" + MFString(self.joints).XML() + "'"
        if self.loa != -1:
            result += " loa='" + SFInt32(self.loa).XML() + "'"
        if self.loop: # default=false
            result += " loop='" + SFBool(self.loop).XML() + "'"
        if self.startFrame != 0:
            result += " startFrame='" + SFInt32(self.startFrame).XML() + "'"
        if self.values != list():
            result += " values='" + MFFloat(self.values).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></HAnimMotion>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</HAnimMotion>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function HAnimMotion.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'HAnimMotion' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'HAnimMotion' + ' {'
        if self.channels != list():
            result += " channels " + MFString(self.channels).VRML() + ""
        if self.channelsEnabled != list():
            result += " channelsEnabled " + MFBool(self.channelsEnabled).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.enabled: # default=false
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.endFrame != 0:
            result += " endFrame " + SFInt32(self.endFrame).VRML() + ""
        if self.frameCount != 0:
            result += " frameCount " + SFInt32(self.frameCount).VRML() + ""
        if self.frameDuration != 0.1:
            result += " frameDuration " + SFTime(self.frameDuration).VRML() + ""
        if self.frameIncrement != 1:
            result += " frameIncrement " + SFInt32(self.frameIncrement).VRML() + ""
        if self.frameIndex != 0:
            result += " frameIndex " + SFInt32(self.frameIndex).VRML() + ""
        if self.joints != list():
            result += " joints " + MFString(self.joints).VRML() + ""
        if self.loa != -1:
            result += " loa " + SFInt32(self.loa).VRML() + ""
        if self.loop: # default=false
            result += " loop " + SFBool(self.loop).VRML() + ""
        if self.startFrame != 0:
            result += " startFrame " + SFInt32(self.startFrame).VRML() + ""
        if self.values != list():
            result += " values " + MFFloat(self.values).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class HAnimSegment(_X3DGroupingNode):
    """
    HAnimSegment node contains Shape geometry for each body segment.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'HAnimSegment'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/hanim.html#HAnimSegment'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#HAnimSegment'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('centerOfMass', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimSegment'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'HAnimSegment'),
            ('mass', 0, FieldType.SFFloat, AccessType.inputOutput, 'HAnimSegment'),
            ('momentsOfInertia', [0, 0, 0, 0, 0, 0, 0, 0, 0], FieldType.MFFloat, AccessType.inputOutput, 'HAnimSegment'),
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'HAnimSegment'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'HAnimSegment'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
            ('displacers', list(), FieldType.MFNode, AccessType.inputOutput, 'HAnimSegment'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 centerOfMass=(0, 0, 0),
                 description='',
                 mass=0,
                 momentsOfInertia=[0, 0, 0, 0, 0, 0, 0, 0, 0],
                 name='',
                 visible=True,
                 coord=None,
                 children=None,
                 displacers=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode HAnimSegment __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.centerOfMass = centerOfMass
        self.description = description
        self.mass = mass
        self.momentsOfInertia = momentsOfInertia
        self.name = name
        self.visible = visible
        self.coord = coord
        self.children = children
        self.displacers = displacers
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def centerOfMass(self):
        """Location within segment of center of mass."""
        return self.__centerOfMass
    @centerOfMass.setter
    def centerOfMass(self, centerOfMass):
        if  centerOfMass is None:
            centerOfMass = (0, 0, 0) # default
        assertValidSFVec3f(centerOfMass)
        self.__centerOfMass = centerOfMass
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def mass(self):
        """Total mass of the segment, 0 if not available, defined in mass base units (default is kilograms)."""
        return self.__mass
    @mass.setter
    def mass(self, mass):
        if  mass is None:
            mass = 0 # default
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def momentsOfInertia(self):
        """3x3 moments of inertia matrix."""
        return self.__momentsOfInertia
    @momentsOfInertia.setter
    def momentsOfInertia(self, momentsOfInertia):
        if  momentsOfInertia is None:
            momentsOfInertia = [0, 0, 0, 0, 0, 0, 0, 0, 0] # default
        assertValidMFFloat(momentsOfInertia)
        assertNonNegative('momentsOfInertia', momentsOfInertia)
        self.__momentsOfInertia = momentsOfInertia
    @property # getter - - - - - - - - - -
    def name(self):
        """Unique name attribute must be defined so that HAnimSegment node can be identified at run time for animation purposes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] the coord field is used for HAnimSegment objects that have deformable meshes and shall contain coordinates referenced from the IndexedFaceSet for the paarent HAnimSegment object."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None # default
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    @property # getter - - - - - - - - - -
    def displacers(self):
        """[HAnimDisplacer] the displacers field stores HAnimDisplacer objects for a particular HAnimSegment object."""
        return self.__displacers
    @displacers.setter
    def displacers(self, displacers):
        if  displacers is None:
            displacers = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(displacers)
        self.__displacers = displacers
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.displacers or self.coord or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function HAnimSegment.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<HAnimSegment'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.centerOfMass != (0, 0, 0):
            result += " centerOfMass='" + SFVec3f(self.centerOfMass).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.mass != 0:
            result += " mass='" + SFFloat(self.mass).XML() + "'"
        if self.momentsOfInertia != [0, 0, 0, 0, 0, 0, 0, 0, 0]:
            result += " momentsOfInertia='" + MFFloat(self.momentsOfInertia).XML() + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></HAnimSegment>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.coord: # output this SFNode
                result += self.coord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* HAnimSegment found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.displacers: # walk each child in MFNode list, if any
            ### print('* HAnimSegment found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(displacers)=' + str(len(self.displacers)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.displacers:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</HAnimSegment>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function HAnimSegment.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'HAnimSegment' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'HAnimSegment' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.centerOfMass != (0, 0, 0):
            result += " centerOfMass " + SFVec3f(self.centerOfMass).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.mass != 0:
            result += " mass " + SFFloat(self.mass).VRML() + ""
        if self.momentsOfInertia != [0, 0, 0, 0, 0, 0, 0, 0, 0]:
            result += " momentsOfInertia " + MFFloat(self.momentsOfInertia).VRML() + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.coord: # output this SFNode
            result += '\n' + '  ' + indent + 'coord ' + self.coord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.displacers: # walk each child in MFNode list, if any
            for each in self.displacers:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class HAnimSite(_X3DGroupingNode):
    """
    An HAnimSite node serves three purposes: (a) define an "end effector" location which can be used by an inverse kinematics system, (b) define an attachment point for accessories such as jewelry and clothing, and (c) define a location for a Viewpoint virtual camera in the reference frame of an HAnimSegment (such as a view "through the eyes" of the humanoid for use in multi-user worlds).
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'HAnimSite'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/hanim.html#HAnimSite'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#HAnimSite'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimSite'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'HAnimSite'),
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'HAnimSite'),
            ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'HAnimSite'),
            ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimSite'),
            ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'HAnimSite'),
            ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'HAnimSite'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 center=(0, 0, 0),
                 description='',
                 name='',
                 rotation=(0, 0, 1, 0),
                 scale=(1, 1, 1),
                 scaleOrientation=(0, 0, 1, 0),
                 translation=(0, 0, 0),
                 visible=True,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode HAnimSite __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.center = center
        self.description = description
        self.name = name
        self.rotation = rotation
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.translation = translation
        self.visible = visible
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        """Default location of this HAnimSite, i."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0) # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def name(self):
        """Unique name attribute must be defined so that HAnimSite node can be identified at run time for animation purposes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def rotation(self):
        """Orientation of children relative to local coordinate system."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0) # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        """Non-uniform x-y-z scale of child coordinate system, adjusted by center and scaleOrientation."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = (1, 1, 1) # default
        assertValidSFVec3f(scale)
        assertPositive('scale', scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        """Preliminary rotation of coordinate system before scaling (to allow scaling around arbitrary orientations)."""
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation):
        if  scaleOrientation is None:
            scaleOrientation = (0, 0, 1, 0) # default
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def translation(self):
        """Position of children relative to local coordinate system."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0) # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function HAnimSite.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<HAnimSite'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.center != (0, 0, 0):
            result += " center='" + SFVec3f(self.center).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + SFRotation(self.rotation).XML() + "'"
        if self.scale != (1, 1, 1):
            result += " scale='" + SFVec3f(self.scale).XML() + "'"
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation='" + SFRotation(self.scaleOrientation).XML() + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + SFVec3f(self.translation).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></HAnimSite>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* HAnimSite found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</HAnimSite>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function HAnimSite.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'HAnimSite' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'HAnimSite' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.center != (0, 0, 0):
            result += " center " + SFVec3f(self.center).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if self.rotation != (0, 0, 1, 0):
            result += " rotation " + SFRotation(self.rotation).VRML() + ""
        if self.scale != (1, 1, 1):
            result += " scale " + SFVec3f(self.scale).VRML() + ""
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation " + SFRotation(self.scaleOrientation).VRML() + ""
        if self.translation != (0, 0, 0):
            result += " translation " + SFVec3f(self.translation).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ImageCubeMapTexture(_X3DEnvironmentTextureNode, _X3DUrlObject):
    """
    ImageCubeMapTexture is a texture node that defines a cubic environment map source as a single file format that contains multiple images, one for each side.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ImageCubeMapTexture'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/environmentalTexturing#ImageCubeMapTexture'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ImageCubeMapTexture'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureNode'),
            ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
            ('refresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
            ('url', list(), FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
            ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly, 'ImageCubeMapTexture'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 load=True,
                 refresh=0,
                 url=list(),
                 textureProperties=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ImageCubeMapTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.load = load
        self.refresh = refresh
        self.url = url
        self.textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def refresh(self):
        """refresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__refresh
    @refresh.setter
    def refresh(self, refresh):
        if  refresh is None:
            refresh = 0 # default
        assertValidSFTime(refresh)
        assertNonNegative('refresh', refresh)
        self.__refresh = refresh
    @property # getter - - - - - - - - - -
    def url(self):
        """Location and filename of image."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE(self)
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties):
        if  textureProperties is None:
            textureProperties = None # default
        assertValidSFNode(textureProperties)
        if not isinstance(textureProperties, object):
            # print(flush=True)
            raise X3DTypeError(str(textureProperties) + ' does not have a valid node type object')
        self.__textureProperties = textureProperties
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.textureProperties
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ImageCubeMapTexture.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ImageCubeMapTexture'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.load: # default=true
            result += " load='" + SFBool(self.load).XML() + "'"
        if self.refresh != 0:
            result += " refresh='" + SFTime(self.refresh).XML() + "'"
        if self.url != list():
            result += " url='" + MFString(self.url).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ImageCubeMapTexture>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.textureProperties: # output this SFNode
                result += self.textureProperties.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ImageCubeMapTexture>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ImageCubeMapTexture.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ImageCubeMapTexture' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ImageCubeMapTexture' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.load: # default=true
            result += " load " + SFBool(self.load).VRML() + ""
        if self.refresh != 0:
            result += " refresh " + SFTime(self.refresh).VRML() + ""
        if self.url != list():
            result += " url " + MFString(self.url).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.textureProperties: # output this SFNode
            result += '\n' + '  ' + indent + 'textureProperties ' + self.textureProperties.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ImageTexture(_X3DTexture2DNode, _X3DUrlObject):
    """
    ImageTexture maps a 2D-image file onto a geometric shape.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ImageTexture'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texturing.html#ImageTexture'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ImageTexture'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureNode'),
            ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
            ('refresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
            ('repeatS', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture2DNode'),
            ('repeatT', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture2DNode'),
            ('url', list(), FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
            ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly, 'X3DTexture2DNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 load=True,
                 refresh=0,
                 repeatS=True,
                 repeatT=True,
                 url=list(),
                 textureProperties=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ImageTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.load = load
        self.refresh = refresh
        self.repeatS = repeatS
        self.repeatT = repeatT
        self.url = url
        self.textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def refresh(self):
        """refresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__refresh
    @refresh.setter
    def refresh(self, refresh):
        if  refresh is None:
            refresh = 0 # default
        assertValidSFTime(refresh)
        assertNonNegative('refresh', refresh)
        self.__refresh = refresh
    @property # getter - - - - - - - - - -
    def repeatS(self):
        """Whether to horizontally repeat texture along S axis."""
        return self.__repeatS
    @repeatS.setter
    def repeatS(self, repeatS):
        if  repeatS is None:
            repeatS = True # default
        assertValidSFBool(repeatS)
        self.__repeatS = repeatS
    @property # getter - - - - - - - - - -
    def repeatT(self):
        """Whether to vertically repeat texture along T axis."""
        return self.__repeatT
    @repeatT.setter
    def repeatT(self, repeatT):
        if  repeatT is None:
            repeatT = True # default
        assertValidSFBool(repeatT)
        self.__repeatT = repeatT
    @property # getter - - - - - - - - - -
    def url(self):
        """Location and filename of image."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE(self)
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties):
        if  textureProperties is None:
            textureProperties = None # default
        assertValidSFNode(textureProperties)
        if not isinstance(textureProperties, object):
            # print(flush=True)
            raise X3DTypeError(str(textureProperties) + ' does not have a valid node type object')
        self.__textureProperties = textureProperties
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.textureProperties
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ImageTexture.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ImageTexture'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.load: # default=true
            result += " load='" + SFBool(self.load).XML() + "'"
        if self.refresh != 0:
            result += " refresh='" + SFTime(self.refresh).XML() + "'"
        if not self.repeatS: # default=true
            result += " repeatS='" + SFBool(self.repeatS).XML() + "'"
        if not self.repeatT: # default=true
            result += " repeatT='" + SFBool(self.repeatT).XML() + "'"
        if self.url != list():
            result += " url='" + MFString(self.url).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ImageTexture>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.textureProperties: # output this SFNode
                result += self.textureProperties.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ImageTexture>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ImageTexture.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ImageTexture' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ImageTexture' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.load: # default=true
            result += " load " + SFBool(self.load).VRML() + ""
        if self.refresh != 0:
            result += " refresh " + SFTime(self.refresh).VRML() + ""
        if not self.repeatS: # default=true
            result += " repeatS " + SFBool(self.repeatS).VRML() + ""
        if not self.repeatT: # default=true
            result += " repeatT " + SFBool(self.repeatT).VRML() + ""
        if self.url != list():
            result += " url " + MFString(self.url).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.textureProperties: # output this SFNode
            result += '\n' + '  ' + indent + 'textureProperties ' + self.textureProperties.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ImageTexture3D(_X3DTexture3DNode, _X3DUrlObject):
    """
    ImageTexture3D defines a 3D image-based texture map by specifying a single image file that contains complete 3D data.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ImageTexture3D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texture3D.html#ImageTexture3D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ImageTexture3D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureNode'),
            ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
            ('refresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
            ('repeatR', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture3DNode'),
            ('repeatS', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture3DNode'),
            ('repeatT', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture3DNode'),
            ('url', list(), FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
            ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly, 'X3DTexture3DNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 load=True,
                 refresh=0,
                 repeatR=False,
                 repeatS=False,
                 repeatT=False,
                 url=list(),
                 textureProperties=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ImageTexture3D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.load = load
        self.refresh = refresh
        self.repeatR = repeatR
        self.repeatS = repeatS
        self.repeatT = repeatT
        self.url = url
        self.textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def refresh(self):
        """refresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__refresh
    @refresh.setter
    def refresh(self, refresh):
        if  refresh is None:
            refresh = 0 # default
        assertValidSFTime(refresh)
        assertNonNegative('refresh', refresh)
        self.__refresh = refresh
    @property # getter - - - - - - - - - -
    def repeatR(self):
        """Whether to vertically repeat texture along R axis."""
        return self.__repeatR
    @repeatR.setter
    def repeatR(self, repeatR):
        if  repeatR is None:
            repeatR = False # default
        assertValidSFBool(repeatR)
        self.__repeatR = repeatR
    @property # getter - - - - - - - - - -
    def repeatS(self):
        """Whether to horizontally repeat texture along S axis."""
        return self.__repeatS
    @repeatS.setter
    def repeatS(self, repeatS):
        if  repeatS is None:
            repeatS = False # default
        assertValidSFBool(repeatS)
        self.__repeatS = repeatS
    @property # getter - - - - - - - - - -
    def repeatT(self):
        """Whether to vertically repeat texture along T axis."""
        return self.__repeatT
    @repeatT.setter
    def repeatT(self, repeatT):
        if  repeatT is None:
            repeatT = False # default
        assertValidSFBool(repeatT)
        self.__repeatT = repeatT
    @property # getter - - - - - - - - - -
    def url(self):
        """Location and filename of image."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE(self)
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties):
        if  textureProperties is None:
            textureProperties = None # default
        assertValidSFNode(textureProperties)
        if not isinstance(textureProperties, object):
            # print(flush=True)
            raise X3DTypeError(str(textureProperties) + ' does not have a valid node type object')
        self.__textureProperties = textureProperties
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.textureProperties
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ImageTexture3D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ImageTexture3D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.load: # default=true
            result += " load='" + SFBool(self.load).XML() + "'"
        if self.refresh != 0:
            result += " refresh='" + SFTime(self.refresh).XML() + "'"
        if self.repeatR: # default=false
            result += " repeatR='" + SFBool(self.repeatR).XML() + "'"
        if self.repeatS: # default=false
            result += " repeatS='" + SFBool(self.repeatS).XML() + "'"
        if self.repeatT: # default=false
            result += " repeatT='" + SFBool(self.repeatT).XML() + "'"
        if self.url != list():
            result += " url='" + MFString(self.url).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ImageTexture3D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.textureProperties: # output this SFNode
                result += self.textureProperties.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ImageTexture3D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ImageTexture3D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ImageTexture3D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ImageTexture3D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.load: # default=true
            result += " load " + SFBool(self.load).VRML() + ""
        if self.refresh != 0:
            result += " refresh " + SFTime(self.refresh).VRML() + ""
        if self.repeatR: # default=false
            result += " repeatR " + SFBool(self.repeatR).VRML() + ""
        if self.repeatS: # default=false
            result += " repeatS " + SFBool(self.repeatS).VRML() + ""
        if self.repeatT: # default=false
            result += " repeatT " + SFBool(self.repeatT).VRML() + ""
        if self.url != list():
            result += " url " + MFString(self.url).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.textureProperties: # output this SFNode
            result += '\n' + '  ' + indent + 'textureProperties ' + self.textureProperties.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class IndexedFaceSet(_X3DComposedGeometryNode):
    """
    IndexedFaceSet defines polygons using index lists corresponding to vertex coordinates.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'IndexedFaceSet'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geometry3D.html#IndexedFaceSet'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IndexedFaceSet'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('colorIndex', list(), FieldType.MFInt32, AccessType.initializeOnly, 'IndexedFaceSet'),
            ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('convex', True, FieldType.SFBool, AccessType.initializeOnly, 'IndexedFaceSet'),
            ('coordIndex', list(), FieldType.MFInt32, AccessType.initializeOnly, 'IndexedFaceSet'),
            ('creaseAngle', 0, FieldType.SFFloat, AccessType.initializeOnly, 'IndexedFaceSet'),
            ('normalIndex', list(), FieldType.MFInt32, AccessType.initializeOnly, 'IndexedFaceSet'),
            ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('texCoordIndex', list(), FieldType.MFInt32, AccessType.initializeOnly, 'IndexedFaceSet'),
            ('color', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('attrib', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ccw=True,
                 colorIndex=list(),
                 colorPerVertex=True,
                 convex=True,
                 coordIndex=list(),
                 creaseAngle=0,
                 normalIndex=list(),
                 normalPerVertex=True,
                 solid=True,
                 texCoordIndex=list(),
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode IndexedFaceSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorIndex = colorIndex
        self.colorPerVertex = colorPerVertex
        self.convex = convex
        self.coordIndex = coordIndex
        self.creaseAngle = creaseAngle
        self.normalIndex = normalIndex
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.texCoordIndex = texCoordIndex
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorIndex(self):
        """[-1,+infinity) colorIndex values define the order in which Color|ColorRGBA values are applied to polygons (or vertices)."""
        return self.__colorIndex
    @colorIndex.setter
    def colorIndex(self, colorIndex):
        if  colorIndex is None:
            colorIndex = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(colorIndex)
        assertGreaterThanEquals('colorIndex', colorIndex, -1)
        self.__colorIndex = colorIndex
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color|ColorRGBA values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def convex(self):
        """The convex field is a hint to renderers whether all polygons in a shape are convex (true), or possibly concave (false)."""
        return self.__convex
    @convex.setter
    def convex(self, convex):
        if  convex is None:
            convex = True # default
        assertValidSFBool(convex)
        self.__convex = convex
    @property # getter - - - - - - - - - -
    def coordIndex(self):
        """[-1,+infinity) coordIndex indices provide the order in which coordinates are applied to construct each polygon face."""
        return self.__coordIndex
    @coordIndex.setter
    def coordIndex(self, coordIndex):
        if  coordIndex is None:
            coordIndex = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(coordIndex)
        assertGreaterThanEquals('coordIndex', coordIndex, -1)
        self.__coordIndex = coordIndex
    @property # getter - - - - - - - - - -
    def creaseAngle(self):
        """[0,+infinity) creaseAngle defines angle (in radians) for determining whether adjacent polygons are drawn with sharp edges or smooth shading."""
        return self.__creaseAngle
    @creaseAngle.setter
    def creaseAngle(self, creaseAngle):
        if  creaseAngle is None:
            creaseAngle = 0 # default
        assertValidSFFloat(creaseAngle)
        assertNonNegative('creaseAngle', creaseAngle)
        self.__creaseAngle = creaseAngle
    @property # getter - - - - - - - - - -
    def normalIndex(self):
        """[-1,+infinity) normalIndex values define the order in which normal vectors are applied to polygons (or vertices)."""
        return self.__normalIndex
    @normalIndex.setter
    def normalIndex(self, normalIndex):
        if  normalIndex is None:
            normalIndex = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(normalIndex)
        assertGreaterThanEquals('normalIndex', normalIndex, -1)
        self.__normalIndex = normalIndex
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def texCoordIndex(self):
        """[-1,+infinity) List of texture-coordinate indices mapping attached texture to corresponding coordinates."""
        return self.__texCoordIndex
    @texCoordIndex.setter
    def texCoordIndex(self, texCoordIndex):
        if  texCoordIndex is None:
            texCoordIndex = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(texCoordIndex)
        assertGreaterThanEquals('texCoordIndex', texCoordIndex, -1)
        self.__texCoordIndex = texCoordIndex
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that specifies color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None # default
        assertValidSFNode(color)
        if not isinstance(color, object):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that specifies a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None # default
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that specifies depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None # default
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that specifies perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None # default
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that specifies coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None # default
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that specifies list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.attrib or self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function IndexedFaceSet.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<IndexedFaceSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.ccw: # default=true
            result += " ccw='" + SFBool(self.ccw).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.colorIndex != list():
            result += " colorIndex='" + MFInt32(self.colorIndex).XML() + "'"
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex='" + SFBool(self.colorPerVertex).XML() + "'"
        if not self.convex: # default=true
            result += " convex='" + SFBool(self.convex).XML() + "'"
        if self.coordIndex != list():
            result += " coordIndex='" + MFInt32(self.coordIndex).XML() + "'"
        if self.creaseAngle != 0:
            result += " creaseAngle='" + SFFloat(self.creaseAngle).XML() + "'"
        if self.normalIndex != list():
            result += " normalIndex='" + MFInt32(self.normalIndex).XML() + "'"
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex='" + SFBool(self.normalPerVertex).XML() + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if self.texCoordIndex != list():
            result += " texCoordIndex='" + MFInt32(self.texCoordIndex).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></IndexedFaceSet>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.color: # output this SFNode
                result += self.color.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.coord: # output this SFNode
                result += self.coord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.fogCoord: # output this SFNode
                result += self.fogCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.normal: # output this SFNode
                result += self.normal.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.texCoord: # output this SFNode
                result += self.texCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.attrib: # walk each child in MFNode list, if any
            ### print('* IndexedFaceSet found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(attrib)=' + str(len(self.attrib)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.attrib:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</IndexedFaceSet>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function IndexedFaceSet.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'IndexedFaceSet' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'IndexedFaceSet' + ' {'
        if not self.ccw: # default=true
            result += " ccw " + SFBool(self.ccw).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.colorIndex != list():
            result += " colorIndex " + MFInt32(self.colorIndex).VRML() + ""
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex " + SFBool(self.colorPerVertex).VRML() + ""
        if not self.convex: # default=true
            result += " convex " + SFBool(self.convex).VRML() + ""
        if self.coordIndex != list():
            result += " coordIndex " + MFInt32(self.coordIndex).VRML() + ""
        if self.creaseAngle != 0:
            result += " creaseAngle " + SFFloat(self.creaseAngle).VRML() + ""
        if self.normalIndex != list():
            result += " normalIndex " + MFInt32(self.normalIndex).VRML() + ""
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex " + SFBool(self.normalPerVertex).VRML() + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.texCoordIndex != list():
            result += " texCoordIndex " + MFInt32(self.texCoordIndex).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.color: # output this SFNode
            result += '\n' + '  ' + indent + 'color ' + self.color.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.coord: # output this SFNode
            result += '\n' + '  ' + indent + 'coord ' + self.coord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.fogCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'fogCoord ' + self.fogCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.normal: # output this SFNode
            result += '\n' + '  ' + indent + 'normal ' + self.normal.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'texCoord ' + self.texCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.attrib: # walk each child in MFNode list, if any
            for each in self.attrib:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class IndexedLineSet(_X3DGeometryNode):
    """
    IndexedLineSet defines polyline segments using index lists corresponding to vertex coordinates.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'IndexedLineSet'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#IndexedLineSet'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IndexedLineSet'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('colorIndex', list(), FieldType.MFInt32, AccessType.initializeOnly, 'IndexedLineSet'),
            ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'IndexedLineSet'),
            ('coordIndex', list(), FieldType.MFInt32, AccessType.initializeOnly, 'IndexedLineSet'),
            ('color', None, FieldType.SFNode, AccessType.inputOutput, 'IndexedLineSet'),
            ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'IndexedLineSet'),
            ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'IndexedLineSet'),
            ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'IndexedLineSet'),
            ('attrib', list(), FieldType.MFNode, AccessType.inputOutput, 'IndexedLineSet'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 colorIndex=list(),
                 colorPerVertex=True,
                 coordIndex=list(),
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 attrib=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode IndexedLineSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.colorIndex = colorIndex
        self.colorPerVertex = colorPerVertex
        self.coordIndex = coordIndex
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def colorIndex(self):
        """[-1,+infinity) colorIndex values define the order in which Color|ColorRGBA values are applied to polygons (or vertices)."""
        return self.__colorIndex
    @colorIndex.setter
    def colorIndex(self, colorIndex):
        if  colorIndex is None:
            colorIndex = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(colorIndex)
        assertGreaterThanEquals('colorIndex', colorIndex, -1)
        self.__colorIndex = colorIndex
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color node color values are applied to each point vertex (true) or per polyline (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def coordIndex(self):
        """[-1,+infinity) coordIndex indices provide the order in which coordinates are applied to construct each polygon face."""
        return self.__coordIndex
    @coordIndex.setter
    def coordIndex(self, coordIndex):
        if  coordIndex is None:
            coordIndex = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(coordIndex)
        assertGreaterThanEquals('coordIndex', coordIndex, -1)
        self.__coordIndex = coordIndex
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that specifies color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None # default
        assertValidSFNode(color)
        if not isinstance(color, object):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that specifies a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None # default
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that specifies depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None # default
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None # default
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that specifies list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.attrib or self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function IndexedLineSet.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<IndexedLineSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.colorIndex != list():
            result += " colorIndex='" + MFInt32(self.colorIndex).XML() + "'"
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex='" + SFBool(self.colorPerVertex).XML() + "'"
        if self.coordIndex != list():
            result += " coordIndex='" + MFInt32(self.coordIndex).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></IndexedLineSet>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.color: # output this SFNode
                result += self.color.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.coord: # output this SFNode
                result += self.coord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.fogCoord: # output this SFNode
                result += self.fogCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.normal: # output this SFNode
                result += self.normal.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.attrib: # walk each child in MFNode list, if any
            ### print('* IndexedLineSet found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(attrib)=' + str(len(self.attrib)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.attrib:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</IndexedLineSet>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function IndexedLineSet.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'IndexedLineSet' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'IndexedLineSet' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.colorIndex != list():
            result += " colorIndex " + MFInt32(self.colorIndex).VRML() + ""
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex " + SFBool(self.colorPerVertex).VRML() + ""
        if self.coordIndex != list():
            result += " coordIndex " + MFInt32(self.coordIndex).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.color: # output this SFNode
            result += '\n' + '  ' + indent + 'color ' + self.color.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.coord: # output this SFNode
            result += '\n' + '  ' + indent + 'coord ' + self.coord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.fogCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'fogCoord ' + self.fogCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.normal: # output this SFNode
            result += '\n' + '  ' + indent + 'normal ' + self.normal.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.attrib: # walk each child in MFNode list, if any
            for each in self.attrib:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class IndexedQuadSet(_X3DComposedGeometryNode):
    """
    IndexedQuadSet is a geometry node that defines quadrilaterals.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'IndexedQuadSet'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/CADGeometry.html#IndexedQuadSet'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IndexedQuadSet'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('index', list(), FieldType.MFInt32, AccessType.initializeOnly, 'IndexedQuadSet'),
            ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('color', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('attrib', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 index=list(),
                 normalPerVertex=True,
                 solid=True,
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode IndexedQuadSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.index = index
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color|ColorRGBA values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def index(self):
        """[0,+infinity) index values provide order in which coordinates are applied."""
        return self.__index
    @index.setter
    def index(self, index):
        if  index is None:
            index = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(index)
        assertNonNegative('index', index)
        self.__index = index
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that specifies color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None # default
        assertValidSFNode(color)
        if not isinstance(color, object):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that specifies a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None # default
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that specifies depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None # default
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that specifies perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None # default
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that specifies coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None # default
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that specifies list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.attrib or self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function IndexedQuadSet.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<IndexedQuadSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.ccw: # default=true
            result += " ccw='" + SFBool(self.ccw).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex='" + SFBool(self.colorPerVertex).XML() + "'"
        if self.index != list():
            result += " index='" + MFInt32(self.index).XML() + "'"
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex='" + SFBool(self.normalPerVertex).XML() + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></IndexedQuadSet>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.color: # output this SFNode
                result += self.color.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.coord: # output this SFNode
                result += self.coord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.fogCoord: # output this SFNode
                result += self.fogCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.normal: # output this SFNode
                result += self.normal.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.texCoord: # output this SFNode
                result += self.texCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.attrib: # walk each child in MFNode list, if any
            ### print('* IndexedQuadSet found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(attrib)=' + str(len(self.attrib)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.attrib:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</IndexedQuadSet>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function IndexedQuadSet.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'IndexedQuadSet' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'IndexedQuadSet' + ' {'
        if not self.ccw: # default=true
            result += " ccw " + SFBool(self.ccw).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex " + SFBool(self.colorPerVertex).VRML() + ""
        if self.index != list():
            result += " index " + MFInt32(self.index).VRML() + ""
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex " + SFBool(self.normalPerVertex).VRML() + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.color: # output this SFNode
            result += '\n' + '  ' + indent + 'color ' + self.color.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.coord: # output this SFNode
            result += '\n' + '  ' + indent + 'coord ' + self.coord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.fogCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'fogCoord ' + self.fogCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.normal: # output this SFNode
            result += '\n' + '  ' + indent + 'normal ' + self.normal.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'texCoord ' + self.texCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.attrib: # walk each child in MFNode list, if any
            for each in self.attrib:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class IndexedTriangleFanSet(_X3DComposedGeometryNode):
    """
    IndexedTriangleFanSet is a geometry node containing a Coordinate|CoordinateDouble node, and can also contain Color|ColorRGBA, Normal and TextureCoordinate nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'IndexedTriangleFanSet'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#IndexedTriangleFanSet'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IndexedTriangleFanSet'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('index', list(), FieldType.MFInt32, AccessType.initializeOnly, 'IndexedTriangleFanSet'),
            ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('color', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('attrib', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 index=list(),
                 normalPerVertex=True,
                 solid=True,
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode IndexedTriangleFanSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.index = index
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color|ColorRGBA values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def index(self):
        """[-1,+infinity) index list specifies triangles by connecting Coordinate vertices, each individual fan separated by -1 sentinel value."""
        return self.__index
    @index.setter
    def index(self, index):
        if  index is None:
            index = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(index)
        assertGreaterThanEquals('index', index, -1)
        self.__index = index
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that specifies color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None # default
        assertValidSFNode(color)
        if not isinstance(color, object):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that specifies a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None # default
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that specifies depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None # default
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that specifies perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None # default
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that specifies coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None # default
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that specifies list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.attrib or self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function IndexedTriangleFanSet.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<IndexedTriangleFanSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.ccw: # default=true
            result += " ccw='" + SFBool(self.ccw).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex='" + SFBool(self.colorPerVertex).XML() + "'"
        if self.index != list():
            result += " index='" + MFInt32(self.index).XML() + "'"
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex='" + SFBool(self.normalPerVertex).XML() + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></IndexedTriangleFanSet>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.color: # output this SFNode
                result += self.color.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.coord: # output this SFNode
                result += self.coord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.fogCoord: # output this SFNode
                result += self.fogCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.normal: # output this SFNode
                result += self.normal.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.texCoord: # output this SFNode
                result += self.texCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.attrib: # walk each child in MFNode list, if any
            ### print('* IndexedTriangleFanSet found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(attrib)=' + str(len(self.attrib)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.attrib:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</IndexedTriangleFanSet>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function IndexedTriangleFanSet.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'IndexedTriangleFanSet' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'IndexedTriangleFanSet' + ' {'
        if not self.ccw: # default=true
            result += " ccw " + SFBool(self.ccw).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex " + SFBool(self.colorPerVertex).VRML() + ""
        if self.index != list():
            result += " index " + MFInt32(self.index).VRML() + ""
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex " + SFBool(self.normalPerVertex).VRML() + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.color: # output this SFNode
            result += '\n' + '  ' + indent + 'color ' + self.color.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.coord: # output this SFNode
            result += '\n' + '  ' + indent + 'coord ' + self.coord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.fogCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'fogCoord ' + self.fogCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.normal: # output this SFNode
            result += '\n' + '  ' + indent + 'normal ' + self.normal.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'texCoord ' + self.texCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.attrib: # walk each child in MFNode list, if any
            for each in self.attrib:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class IndexedTriangleSet(_X3DComposedGeometryNode):
    """
    IndexedTriangleSet is a geometry node containing a Coordinate|CoordinateDouble node, and can also contain Color|ColorRGBA, Normal and TextureCoordinate nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'IndexedTriangleSet'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#IndexedTriangleSet'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IndexedTriangleSet'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('index', list(), FieldType.MFInt32, AccessType.initializeOnly, 'IndexedTriangleSet'),
            ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('color', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('attrib', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 index=list(),
                 normalPerVertex=True,
                 solid=True,
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode IndexedTriangleSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.index = index
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color|ColorRGBA values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def index(self):
        """[0,+infinity) index list specifies triangles by connecting Coordinate vertices."""
        return self.__index
    @index.setter
    def index(self, index):
        if  index is None:
            index = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(index)
        assertNonNegative('index', index)
        self.__index = index
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that specifies color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None # default
        assertValidSFNode(color)
        if not isinstance(color, object):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that specifies a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None # default
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that specifies depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None # default
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that specifies perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None # default
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that specifies coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None # default
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that specifies list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.attrib or self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function IndexedTriangleSet.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<IndexedTriangleSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.ccw: # default=true
            result += " ccw='" + SFBool(self.ccw).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex='" + SFBool(self.colorPerVertex).XML() + "'"
        if self.index != list():
            result += " index='" + MFInt32(self.index).XML() + "'"
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex='" + SFBool(self.normalPerVertex).XML() + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></IndexedTriangleSet>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.color: # output this SFNode
                result += self.color.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.coord: # output this SFNode
                result += self.coord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.fogCoord: # output this SFNode
                result += self.fogCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.normal: # output this SFNode
                result += self.normal.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.texCoord: # output this SFNode
                result += self.texCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.attrib: # walk each child in MFNode list, if any
            ### print('* IndexedTriangleSet found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(attrib)=' + str(len(self.attrib)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.attrib:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</IndexedTriangleSet>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function IndexedTriangleSet.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'IndexedTriangleSet' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'IndexedTriangleSet' + ' {'
        if not self.ccw: # default=true
            result += " ccw " + SFBool(self.ccw).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex " + SFBool(self.colorPerVertex).VRML() + ""
        if self.index != list():
            result += " index " + MFInt32(self.index).VRML() + ""
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex " + SFBool(self.normalPerVertex).VRML() + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.color: # output this SFNode
            result += '\n' + '  ' + indent + 'color ' + self.color.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.coord: # output this SFNode
            result += '\n' + '  ' + indent + 'coord ' + self.coord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.fogCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'fogCoord ' + self.fogCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.normal: # output this SFNode
            result += '\n' + '  ' + indent + 'normal ' + self.normal.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'texCoord ' + self.texCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.attrib: # walk each child in MFNode list, if any
            for each in self.attrib:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class IndexedTriangleStripSet(_X3DComposedGeometryNode):
    """
    IndexedTriangleStripSet is a geometry node containing a Coordinate|CoordinateDouble node, and can also contain Color|ColorRGBA, Normal and TextureCoordinate nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'IndexedTriangleStripSet'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#IndexedTriangleStripSet'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IndexedTriangleStripSet'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('index', list(), FieldType.MFInt32, AccessType.initializeOnly, 'IndexedTriangleStripSet'),
            ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('color', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('attrib', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 index=list(),
                 normalPerVertex=True,
                 solid=True,
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode IndexedTriangleStripSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.index = index
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color|ColorRGBA values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def index(self):
        """[-1,+infinity) index list specifies triangles by connecting Coordinate vertices for each individual strip, separated by -1 sentinel values."""
        return self.__index
    @index.setter
    def index(self, index):
        if  index is None:
            index = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(index)
        assertGreaterThanEquals('index', index, -1)
        self.__index = index
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that specifies color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None # default
        assertValidSFNode(color)
        if not isinstance(color, object):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that specifies a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None # default
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that specifies depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None # default
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that specifies perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None # default
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that specifies coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None # default
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that specifies list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.attrib or self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function IndexedTriangleStripSet.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<IndexedTriangleStripSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.ccw: # default=true
            result += " ccw='" + SFBool(self.ccw).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex='" + SFBool(self.colorPerVertex).XML() + "'"
        if self.index != list():
            result += " index='" + MFInt32(self.index).XML() + "'"
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex='" + SFBool(self.normalPerVertex).XML() + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></IndexedTriangleStripSet>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.color: # output this SFNode
                result += self.color.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.coord: # output this SFNode
                result += self.coord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.fogCoord: # output this SFNode
                result += self.fogCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.normal: # output this SFNode
                result += self.normal.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.texCoord: # output this SFNode
                result += self.texCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.attrib: # walk each child in MFNode list, if any
            ### print('* IndexedTriangleStripSet found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(attrib)=' + str(len(self.attrib)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.attrib:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</IndexedTriangleStripSet>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function IndexedTriangleStripSet.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'IndexedTriangleStripSet' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'IndexedTriangleStripSet' + ' {'
        if not self.ccw: # default=true
            result += " ccw " + SFBool(self.ccw).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex " + SFBool(self.colorPerVertex).VRML() + ""
        if self.index != list():
            result += " index " + MFInt32(self.index).VRML() + ""
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex " + SFBool(self.normalPerVertex).VRML() + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.color: # output this SFNode
            result += '\n' + '  ' + indent + 'color ' + self.color.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.coord: # output this SFNode
            result += '\n' + '  ' + indent + 'coord ' + self.coord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.fogCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'fogCoord ' + self.fogCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.normal: # output this SFNode
            result += '\n' + '  ' + indent + 'normal ' + self.normal.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'texCoord ' + self.texCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.attrib: # walk each child in MFNode list, if any
            for each in self.attrib:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Inline(_X3DChildNode, _X3DBoundedObject, _X3DUrlObject):
    """
    Inline can load another X3D or VRML model into the current scene via url.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Inline'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/networking.html#Inline'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Inline'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DUrlObject'),
            ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
            ('refresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
            ('url', list(), FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 description='',
                 load=True,
                 refresh=0,
                 url=list(),
                 visible=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Inline __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.description = description
        self.load = load
        self.refresh = refresh
        self.url = url
        self.visible = visible
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def refresh(self):
        """refresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__refresh
    @refresh.setter
    def refresh(self, refresh):
        if  refresh is None:
            refresh = 0 # default
        assertValidSFTime(refresh)
        assertNonNegative('refresh', refresh)
        self.__refresh = refresh
    @property # getter - - - - - - - - - -
    def url(self):
        """Address of X3D world to load into current scene."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE(self)
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Inline.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Inline'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.load: # default=true
            result += " load='" + SFBool(self.load).XML() + "'"
        if self.refresh != 0:
            result += " refresh='" + SFTime(self.refresh).XML() + "'"
        if self.url != list():
            result += " url='" + MFString(self.url).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Inline>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Inline>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Inline.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Inline' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Inline' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.load: # default=true
            result += " load " + SFBool(self.load).VRML() + ""
        if self.refresh != 0:
            result += " refresh " + SFTime(self.refresh).VRML() + ""
        if self.url != list():
            result += " url " + MFString(self.url).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class IntegerSequencer(_X3DSequencerNode):
    """
    IntegerSequencer generates periodic discrete integer values.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'IntegerSequencer'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/eventUtilities.html#IntegerSequencer'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IntegerSequencer'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('key', list(), FieldType.MFFloat, AccessType.inputOutput, 'X3DSequencerNode'),
            ('keyValue', list(), FieldType.MFInt32, AccessType.inputOutput, 'IntegerSequencer'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode IntegerSequencer __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear sequencing, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(keyValue)
        self.__keyValue = keyValue
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function IntegerSequencer.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<IntegerSequencer'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + MFFloat(self.key).XML() + "'"
        if self.keyValue != list():
            result += " keyValue='" + MFInt32(self.keyValue).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></IntegerSequencer>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</IntegerSequencer>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function IntegerSequencer.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'IntegerSequencer' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'IntegerSequencer' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.key != list():
            result += " key " + MFFloat(self.key).VRML() + ""
        if self.keyValue != list():
            result += " keyValue " + MFInt32(self.keyValue).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class IntegerTrigger(_X3DTriggerNode):
    """
    IntegerTrigger converts set_boolean true input events to an integer value (for example, useful when animating whichChoice in a Switch node).
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'IntegerTrigger'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/eventUtilities.html#IntegerTrigger'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IntegerTrigger'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('integerKey', -1, FieldType.SFInt32, AccessType.inputOutput, 'IntegerTrigger'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 integerKey=-1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode IntegerTrigger __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.integerKey = integerKey
    @property # getter - - - - - - - - - -
    def integerKey(self):
        """integerKey is value for output when triggered."""
        return self.__integerKey
    @integerKey.setter
    def integerKey(self, integerKey):
        if  integerKey is None:
            integerKey = -1 # default
        assertValidSFInt32(integerKey)
        self.__integerKey = integerKey
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function IntegerTrigger.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<IntegerTrigger'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.integerKey != -1:
            result += " integerKey='" + SFInt32(self.integerKey).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></IntegerTrigger>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</IntegerTrigger>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function IntegerTrigger.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'IntegerTrigger' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'IntegerTrigger' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.integerKey != -1:
            result += " integerKey " + SFInt32(self.integerKey).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class IsoSurfaceVolumeData(_X3DVolumeDataNode):
    """
    IsoSurfaceVolumeData displays one or more surfaces extracted from a voxel dataset.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'IsoSurfaceVolumeData'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/volume.html#IsoSurfaceVolumeData'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#IsoSurfaceVolumeData'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DVolumeDataNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeDataNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DVolumeDataNode'),
            ('contourStepSize', 0, FieldType.SFFloat, AccessType.inputOutput, 'IsoSurfaceVolumeData'),
            ('dimensions', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'X3DVolumeDataNode'),
            ('surfaceTolerance', 0, FieldType.SFFloat, AccessType.inputOutput, 'IsoSurfaceVolumeData'),
            ('surfaceValues', list(), FieldType.MFFloat, AccessType.inputOutput, 'IsoSurfaceVolumeData'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeDataNode'),
            ('gradients', None, FieldType.SFNode, AccessType.inputOutput, 'IsoSurfaceVolumeData'),
            ('voxels', None, FieldType.SFNode, AccessType.inputOutput, 'IsoSurfaceVolumeData'),
            ('renderStyle', list(), FieldType.MFNode, AccessType.inputOutput, 'IsoSurfaceVolumeData'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 contourStepSize=0,
                 dimensions=(1, 1, 1),
                 surfaceTolerance=0,
                 surfaceValues=list(),
                 visible=True,
                 gradients=None,
                 voxels=None,
                 renderStyle=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode IsoSurfaceVolumeData __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.contourStepSize = contourStepSize
        self.dimensions = dimensions
        self.surfaceTolerance = surfaceTolerance
        self.surfaceValues = surfaceValues
        self.visible = visible
        self.gradients = gradients
        self.voxels = voxels
        self.renderStyle = renderStyle
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def contourStepSize(self):
        """If contourStepSize is non-zero, also render all isosurfaces that are multiples of that step size from initial surface value."""
        return self.__contourStepSize
    @contourStepSize.setter
    def contourStepSize(self, contourStepSize):
        if  contourStepSize is None:
            contourStepSize = 0 # default
        assertValidSFFloat(contourStepSize)
        self.__contourStepSize = contourStepSize
    @property # getter - - - - - - - - - -
    def dimensions(self):
        """Actual-size X-Y-Z dimensions of volume data in local coordinate system."""
        return self.__dimensions
    @dimensions.setter
    def dimensions(self, dimensions):
        if  dimensions is None:
            dimensions = (1, 1, 1) # default
        assertValidSFVec3f(dimensions)
        assertPositive('dimensions', dimensions)
        self.__dimensions = dimensions
    @property # getter - - - - - - - - - -
    def surfaceTolerance(self):
        """[0,+infinity) Threshold for gradient magnitude for voxel inolusion in isosurface."""
        return self.__surfaceTolerance
    @surfaceTolerance.setter
    def surfaceTolerance(self, surfaceTolerance):
        if  surfaceTolerance is None:
            surfaceTolerance = 0 # default
        assertValidSFFloat(surfaceTolerance)
        assertNonNegative('surfaceTolerance', surfaceTolerance)
        self.__surfaceTolerance = surfaceTolerance
    @property # getter - - - - - - - - - -
    def surfaceValues(self):
        """If surfaceValues has one value defined, render corresponding isosurface plus any isosurfaces based on contourStepSize."""
        return self.__surfaceValues
    @surfaceValues.setter
    def surfaceValues(self, surfaceValues):
        if  surfaceValues is None:
            surfaceValues = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(surfaceValues)
        self.__surfaceValues = surfaceValues
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def gradients(self):
        """[X3DTexture3DNode] Single contained X3DTexture3DNode (ComposedTexture3D, ImageTexture3D, PixelTexture3D) that provides explicit per-voxel gradient direction information for determining surface boundaries, rather than having it implicitly calculated by the implementation."""
        return self.__gradients
    @gradients.setter
    def gradients(self, gradients):
        if  gradients is None:
            gradients = None # default
        assertValidSFNode(gradients)
        if not isinstance(gradients, object):
            # print(flush=True)
            raise X3DTypeError(str(gradients) + ' does not have a valid node type object')
        self.__gradients = gradients
    @property # getter - - - - - - - - - -
    def voxels(self):
        """[X3DTexture3DNode] Single contained X3DTexture3DNode (ComposedTexture3D, ImageTexture3D, PixelTexture3D) that provides raw voxel information utilized by corresponding rendering styles."""
        return self.__voxels
    @voxels.setter
    def voxels(self, voxels):
        if  voxels is None:
            voxels = None # default
        assertValidSFNode(voxels)
        if not isinstance(voxels, object):
            # print(flush=True)
            raise X3DTypeError(str(voxels) + ' does not have a valid node type object')
        self.__voxels = voxels
    @property # getter - - - - - - - - - -
    def renderStyle(self):
        """[X3DVolumeRenderStyleNode] Multiple contained X3DVolumeRenderStyleNode nodes corresponding to each isosurface that define specific rendering technique for this volumetric object."""
        return self.__renderStyle
    @renderStyle.setter
    def renderStyle(self, renderStyle):
        if  renderStyle is None:
            renderStyle = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(renderStyle)
        self.__renderStyle = renderStyle
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.renderStyle or self.gradients or self.IS or self.metadata or self.voxels
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function IsoSurfaceVolumeData.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<IsoSurfaceVolumeData'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.contourStepSize != 0:
            result += " contourStepSize='" + SFFloat(self.contourStepSize).XML() + "'"
        if self.dimensions != (1, 1, 1):
            result += " dimensions='" + SFVec3f(self.dimensions).XML() + "'"
        if self.surfaceTolerance != 0:
            result += " surfaceTolerance='" + SFFloat(self.surfaceTolerance).XML() + "'"
        if self.surfaceValues != list():
            result += " surfaceValues='" + MFFloat(self.surfaceValues).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></IsoSurfaceVolumeData>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.gradients: # output this SFNode
                result += self.gradients.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.voxels: # output this SFNode
                result += self.voxels.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.renderStyle: # walk each child in MFNode list, if any
            ### print('* IsoSurfaceVolumeData found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(renderStyle)=' + str(len(self.renderStyle)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.renderStyle:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</IsoSurfaceVolumeData>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function IsoSurfaceVolumeData.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'IsoSurfaceVolumeData' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'IsoSurfaceVolumeData' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.contourStepSize != 0:
            result += " contourStepSize " + SFFloat(self.contourStepSize).VRML() + ""
        if self.dimensions != (1, 1, 1):
            result += " dimensions " + SFVec3f(self.dimensions).VRML() + ""
        if self.surfaceTolerance != 0:
            result += " surfaceTolerance " + SFFloat(self.surfaceTolerance).VRML() + ""
        if self.surfaceValues != list():
            result += " surfaceValues " + MFFloat(self.surfaceValues).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.gradients: # output this SFNode
            result += '\n' + '  ' + indent + 'gradients ' + self.gradients.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.voxels: # output this SFNode
            result += '\n' + '  ' + indent + 'voxels ' + self.voxels.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.renderStyle: # walk each child in MFNode list, if any
            for each in self.renderStyle:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class KeySensor(_X3DKeyDeviceSensorNode):
    """
    KeySensor generates events as the user presses keys on the keyboard.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'KeySensor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/keyDeviceSensor.html#KeySensor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#KeySensor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 enabled=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode KeySensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function KeySensor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<KeySensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></KeySensor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</KeySensor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function KeySensor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'KeySensor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'KeySensor' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Layer(_X3DLayerNode):
    """
    Layer contains a list of children nodes that define the contents of the layer.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Layer'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/layering.html#Layer'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Layer'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('objectType', ["ALL"], FieldType.MFString, AccessType.inputOutput, 'X3DLayerNode'),
            ('pickable', True, FieldType.SFBool, AccessType.inputOutput, 'X3DLayerNode'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DLayerNode'),
            ('viewport', None, FieldType.SFNode, AccessType.inputOutput, 'X3DLayerNode'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'Layer'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 objectType=["ALL"],
                 pickable=True,
                 visible=True,
                 viewport=None,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Layer __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.objectType = objectType
        self.pickable = pickable
        self.visible = visible
        self.viewport = viewport
        self.children = children
    @property # getter - - - - - - - - - -
    def objectType(self):
        """The objectType field specifies a set of labels used in the picking process."""
        return self.__objectType
    @objectType.setter
    def objectType(self, objectType):
        if  objectType is None:
            objectType = ["ALL"] # default
        assertValidMFString(objectType)
        self.__objectType = objectType
    @property # getter - - - - - - - - - -
    def pickable(self):
        """pickable determines whether pick traversal is performed for this layer."""
        return self.__pickable
    @pickable.setter
    def pickable(self, pickable):
        if  pickable is None:
            pickable = True # default
        assertValidSFBool(pickable)
        self.__pickable = pickable
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def viewport(self):
        """[X3DViewportNode] The viewport field is a single Viewport node that constrains layer output to a sub-region of the render surface."""
        return self.__viewport
    @viewport.setter
    def viewport(self, viewport):
        if  viewport is None:
            viewport = None # default
        assertValidSFNode(viewport)
        if not isinstance(viewport, object):
            # print(flush=True)
            raise X3DTypeError(str(viewport) + ' does not have a valid node type object')
        self.__viewport = viewport
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Nodes making up this layer."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.metadata or self.viewport
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Layer.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Layer'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.objectType != ["ALL"]:
            result += " objectType='" + MFString(self.objectType).XML() + "'"
        if not self.pickable: # default=true
            result += " pickable='" + SFBool(self.pickable).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Layer>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.viewport: # output this SFNode
                result += self.viewport.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* Layer found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Layer>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Layer.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Layer' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Layer' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.objectType != ["ALL"]:
            result += " objectType " + MFString(self.objectType).VRML() + ""
        if not self.pickable: # default=true
            result += " pickable " + SFBool(self.pickable).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.viewport: # output this SFNode
            result += '\n' + '  ' + indent + 'viewport ' + self.viewport.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class LayerSet(_X3DNode):
    """
    LayerSet defines a list of layers and a rendering order.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'LayerSet'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/layering.html#LayerSet'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LayerSet'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('activeLayer', 0, FieldType.SFInt32, AccessType.inputOutput, 'LayerSet'),
            ('order', [0], FieldType.MFInt32, AccessType.initializeOnly, 'LayerSet'),
            ('layers', list(), FieldType.MFNode, AccessType.inputOutput, 'LayerSet'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 activeLayer=0,
                 order=[0],
                 layers=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode LayerSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.activeLayer = activeLayer
        self.order = order
        self.layers = layers
    @property # getter - - - - - - - - - -
    def activeLayer(self):
        """[0,+infinity) activeLayer field specifies the layer in which navigation takes place."""
        return self.__activeLayer
    @activeLayer.setter
    def activeLayer(self, activeLayer):
        if  activeLayer is None:
            activeLayer = 0 # default
        assertValidSFInt32(activeLayer)
        assertNonNegative('activeLayer', activeLayer)
        self.__activeLayer = activeLayer
    @property # getter - - - - - - - - - -
    def order(self):
        """[0,+infinity) The order list defines the order in which layers are rendered."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = [0] # default
        assertValidMFInt32(order)
        assertNonNegative('order', order)
        self.__order = order
    @property # getter - - - - - - - - - -
    def layers(self):
        """[X3DLayerNode] The layers list defines a list of Layer nodes that contain the constituent parts of the scene."""
        return self.__layers
    @layers.setter
    def layers(self, layers):
        if  layers is None:
            layers = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(layers)
        self.__layers = layers
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.layers or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function LayerSet.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<LayerSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.activeLayer != 0:
            result += " activeLayer='" + SFInt32(self.activeLayer).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.order != [0]:
            result += " order='" + MFInt32(self.order).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></LayerSet>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.layers: # walk each child in MFNode list, if any
            ### print('* LayerSet found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(layers)=' + str(len(self.layers)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.layers:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</LayerSet>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function LayerSet.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'LayerSet' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'LayerSet' + ' {'
        if self.activeLayer != 0:
            result += " activeLayer " + SFInt32(self.activeLayer).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.order != [0]:
            result += " order " + MFInt32(self.order).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.layers: # walk each child in MFNode list, if any
            for each in self.layers:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Layout(_X3DLayoutNode): #  # TODO fix additional inheritance method resolution order (MRO)
    """
    Layout node is used as layout field of LayoutLayer and LayoutGroup nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Layout'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/layout.html#Layout'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Layout'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('align', ["CENTER", "CENTER"], FieldType.MFString, AccessType.inputOutput, 'Layout'),
            ('offset', [0, 0], FieldType.MFFloat, AccessType.inputOutput, 'Layout'),
            ('offsetUnits', ["WORLD", "WORLD"], FieldType.MFString, AccessType.inputOutput, 'Layout'),
            ('scaleMode', ["NONE", "NONE"], FieldType.MFString, AccessType.inputOutput, 'Layout'),
            ('size', [1, 1], FieldType.MFFloat, AccessType.initializeOnly, 'Layout'),
            ('sizeUnits', ["WORLD", "WORLD"], FieldType.MFString, AccessType.inputOutput, 'Layout'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 align=["CENTER", "CENTER"],
                 offset=[0, 0],
                 offsetUnits=["WORLD", "WORLD"],
                 scaleMode=["NONE", "NONE"],
                 size=[1, 1],
                 sizeUnits=["WORLD", "WORLD"],
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Layout __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.align = align
        self.offset = offset
        self.offsetUnits = offsetUnits
        self.scaleMode = scaleMode
        self.size = size
        self.sizeUnits = sizeUnits
    @property # getter - - - - - - - - - -
    def align(self):
        """The align field values align the sized rectangle to an edge or center of the parent rectangle."""
        return self.__align
    @align.setter
    def align(self, align):
        if  align is None:
            align = ["CENTER", "CENTER"] # default
        assertValidMFString(align)
        assertValidLayoutAlign('align', align)
        self.__align = align
    @property # getter - - - - - - - - - -
    def offset(self):
        """(-infinity,+infinity) The values of the offset field are used to translate the location of this rectangle after the initial alignment."""
        return self.__offset
    @offset.setter
    def offset(self, offset):
        if  offset is None:
            offset = [0, 0] # default
        assertValidMFFloat(offset)
        self.__offset = offset
    @property # getter - - - - - - - - - -
    def offsetUnits(self):
        """The offsetUnits field values are used to interprete the offset values."""
        return self.__offsetUnits
    @offsetUnits.setter
    def offsetUnits(self, offsetUnits):
        if  offsetUnits is None:
            offsetUnits = ["WORLD", "WORLD"] # default
        assertValidMFString(offsetUnits)
        assertValidLayoutUnits('offsetUnits', offsetUnits)
        self.__offsetUnits = offsetUnits
    @property # getter - - - - - - - - - -
    def scaleMode(self):
        """The scaleMode field specifies how the scale of the parent is modified."""
        return self.__scaleMode
    @scaleMode.setter
    def scaleMode(self, scaleMode):
        if  scaleMode is None:
            scaleMode = ["NONE", "NONE"] # default
        assertValidMFString(scaleMode)
        assertValidLayoutScaleMode('scaleMode', scaleMode)
        self.__scaleMode = scaleMode
    @property # getter - - - - - - - - - -
    def size(self):
        """(0,+infinity) The two values in the size field define the width and height of the layout rectangle."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = [1, 1] # default
        assertValidMFFloat(size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def sizeUnits(self):
        """The sizeUnits field values are used to interprete the offset values."""
        return self.__sizeUnits
    @sizeUnits.setter
    def sizeUnits(self, sizeUnits):
        if  sizeUnits is None:
            sizeUnits = ["WORLD", "WORLD"] # default
        assertValidMFString(sizeUnits)
        assertValidLayoutUnits('sizeUnits', sizeUnits)
        self.__sizeUnits = sizeUnits
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Layout.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Layout'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.align != ["CENTER", "CENTER"]:
            result += " align='" + MFString(self.align).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.offset != [0, 0]:
            result += " offset='" + MFFloat(self.offset).XML() + "'"
        if self.offsetUnits != ["WORLD", "WORLD"]:
            result += " offsetUnits='" + MFString(self.offsetUnits).XML() + "'"
        if self.scaleMode != ["NONE", "NONE"]:
            result += " scaleMode='" + MFString(self.scaleMode).XML() + "'"
        if self.size != [1, 1]:
            result += " size='" + MFFloat(self.size).XML() + "'"
        if self.sizeUnits != ["WORLD", "WORLD"]:
            result += " sizeUnits='" + MFString(self.sizeUnits).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Layout>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Layout>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Layout.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Layout' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Layout' + ' {'
        if self.align != ["CENTER", "CENTER"]:
            result += " align " + MFString(self.align).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.offset != [0, 0]:
            result += " offset " + MFFloat(self.offset).VRML() + ""
        if self.offsetUnits != ["WORLD", "WORLD"]:
            result += " offsetUnits " + MFString(self.offsetUnits).VRML() + ""
        if self.scaleMode != ["NONE", "NONE"]:
            result += " scaleMode " + MFString(self.scaleMode).VRML() + ""
        if self.size != [1, 1]:
            result += " size " + MFFloat(self.size).VRML() + ""
        if self.sizeUnits != ["WORLD", "WORLD"]:
            result += " sizeUnits " + MFString(self.sizeUnits).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class LayoutGroup(_X3DNode): # , _X3DGroupingNode # TODO fix additional inheritance method resolution order (MRO)
    """
    LayoutGroup is a Grouping node that can contain most nodes, whose children are related by a common layout within a parent layout.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'LayoutGroup'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/layout.html#LayoutGroup'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LayoutGroup'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('layout', None, FieldType.SFNode, AccessType.inputOutput, 'LayoutGroup'),
            ('viewport', None, FieldType.SFNode, AccessType.inputOutput, 'LayoutGroup'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'LayoutGroup'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 visible=True,
                 layout=None,
                 viewport=None,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode LayoutGroup __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.visible = visible
        self.layout = layout
        self.viewport = viewport
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def layout(self):
        """[X3DLayoutNode] The layout field contains an X3DLayoutNode node that provides the information required to locate and size the layout region of the LayoutGroup node relative to its parent’s layout region, and also to scale the contents of the LayoutGroup."""
        return self.__layout
    @layout.setter
    def layout(self, layout):
        if  layout is None:
            layout = None # default
        assertValidSFNode(layout)
        if not isinstance(layout, object):
            # print(flush=True)
            raise X3DTypeError(str(layout) + ' does not have a valid node type object')
        self.__layout = layout
    @property # getter - - - - - - - - - -
    def viewport(self):
        """[X3DViewportNode] The content of the LayoutGroup is clipped by the specified viewport."""
        return self.__viewport
    @viewport.setter
    def viewport(self, viewport):
        if  viewport is None:
            viewport = None # default
        assertValidSFNode(viewport)
        if not isinstance(viewport, object):
            # print(flush=True)
            raise X3DTypeError(str(viewport) + ' does not have a valid node type object')
        self.__viewport = viewport
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.layout or self.metadata or self.viewport
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function LayoutGroup.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<LayoutGroup'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></LayoutGroup>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.layout: # output this SFNode
                result += self.layout.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.viewport: # output this SFNode
                result += self.viewport.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* LayoutGroup found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</LayoutGroup>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function LayoutGroup.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'LayoutGroup' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'LayoutGroup' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.layout: # output this SFNode
            result += '\n' + '  ' + indent + 'layout ' + self.layout.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.viewport: # output this SFNode
            result += '\n' + '  ' + indent + 'viewport ' + self.viewport.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class LayoutLayer(_X3DLayerNode): #  # TODO fix additional inheritance method resolution order (MRO)
    """
    LayoutLayer is a Grouping node that can contain most nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'LayoutLayer'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/layout.html#LayoutLayer'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LayoutLayer'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('objectType', ["ALL"], FieldType.MFString, AccessType.inputOutput, 'X3DLayerNode'),
            ('pickable', True, FieldType.SFBool, AccessType.inputOutput, 'X3DLayerNode'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DLayerNode'),
            ('layout', None, FieldType.SFNode, AccessType.inputOutput, 'LayoutLayer'),
            ('viewport', None, FieldType.SFNode, AccessType.inputOutput, 'X3DLayerNode'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'LayoutLayer'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 objectType=["ALL"],
                 pickable=True,
                 visible=True,
                 layout=None,
                 viewport=None,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode LayoutLayer __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.objectType = objectType
        self.pickable = pickable
        self.visible = visible
        self.layout = layout
        self.viewport = viewport
        self.children = children
    @property # getter - - - - - - - - - -
    def objectType(self):
        """The objectType field specifies a set of labels used in the picking process."""
        return self.__objectType
    @objectType.setter
    def objectType(self, objectType):
        if  objectType is None:
            objectType = ["ALL"] # default
        assertValidMFString(objectType)
        self.__objectType = objectType
    @property # getter - - - - - - - - - -
    def pickable(self):
        """pickable determines whether pick traversal is performed for this layer."""
        return self.__pickable
    @pickable.setter
    def pickable(self, pickable):
        if  pickable is None:
            pickable = True # default
        assertValidSFBool(pickable)
        self.__pickable = pickable
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def layout(self):
        """[X3DLayoutNode] The layout field contains an X3DLayoutNode node that provides the information required to locate and size the layout region of the LayoutGroup node relative to its parent’s layout region, and also to scale the contents of the LayoutGroup."""
        return self.__layout
    @layout.setter
    def layout(self, layout):
        if  layout is None:
            layout = None # default
        assertValidSFNode(layout)
        if not isinstance(layout, object):
            # print(flush=True)
            raise X3DTypeError(str(layout) + ' does not have a valid node type object')
        self.__layout = layout
    @property # getter - - - - - - - - - -
    def viewport(self):
        """[X3DViewportNode] The content of the LayoutGroup is clipped by the specified viewport."""
        return self.__viewport
    @viewport.setter
    def viewport(self, viewport):
        if  viewport is None:
            viewport = None # default
        assertValidSFNode(viewport)
        if not isinstance(viewport, object):
            # print(flush=True)
            raise X3DTypeError(str(viewport) + ' does not have a valid node type object')
        self.__viewport = viewport
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.layout or self.metadata or self.viewport
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function LayoutLayer.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<LayoutLayer'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.objectType != ["ALL"]:
            result += " objectType='" + MFString(self.objectType).XML() + "'"
        if not self.pickable: # default=true
            result += " pickable='" + SFBool(self.pickable).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></LayoutLayer>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.layout: # output this SFNode
                result += self.layout.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.viewport: # output this SFNode
                result += self.viewport.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* LayoutLayer found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</LayoutLayer>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function LayoutLayer.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'LayoutLayer' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'LayoutLayer' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.objectType != ["ALL"]:
            result += " objectType " + MFString(self.objectType).VRML() + ""
        if not self.pickable: # default=true
            result += " pickable " + SFBool(self.pickable).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.layout: # output this SFNode
            result += '\n' + '  ' + indent + 'layout ' + self.layout.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.viewport: # output this SFNode
            result += '\n' + '  ' + indent + 'viewport ' + self.viewport.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class LinePickSensor(_X3DPickSensorNode):
    """
    LinePickSensor uses one or more pickingGeometry line segments to compute intersections with pickTarget shapes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'LinePickSensor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/picking.html#LinePickSensor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LinePickSensor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('intersectionType', 'BOUNDS', FieldType.SFString, AccessType.initializeOnly, 'X3DPickSensorNode'),
            ('matchCriterion', 'MATCH_ANY', FieldType.SFString, AccessType.inputOutput, 'X3DPickSensorNode'),
            ('objectType', ["ALL"], FieldType.MFString, AccessType.inputOutput, 'X3DPickSensorNode'),
            ('sortOrder', 'CLOSEST', FieldType.SFString, AccessType.initializeOnly, 'X3DPickSensorNode'),
            ('pickingGeometry', None, FieldType.SFNode, AccessType.inputOutput, 'X3DPickSensorNode'),
            ('pickTarget', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DPickSensorNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 enabled=True,
                 intersectionType='BOUNDS',
                 matchCriterion='MATCH_ANY',
                 objectType=["ALL"],
                 sortOrder='CLOSEST',
                 pickingGeometry=None,
                 pickTarget=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode LinePickSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.intersectionType = intersectionType
        self.matchCriterion = matchCriterion
        self.objectType = objectType
        self.sortOrder = sortOrder
        self.pickingGeometry = pickingGeometry
        self.pickTarget = pickTarget
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def intersectionType(self):
        """intersectionType specifies precision of the collision computation."""
        return self.__intersectionType
    @intersectionType.setter
    def intersectionType(self, intersectionType):
        if  intersectionType is None:
            intersectionType = 'BOUNDS' # default
        assertValidSFString(intersectionType)
        self.__intersectionType = intersectionType
    @property # getter - - - - - - - - - -
    def matchCriterion(self):
        """defines whether the intersection test (i."""
        return self.__matchCriterion
    @matchCriterion.setter
    def matchCriterion(self, matchCriterion):
        if  matchCriterion is None:
            matchCriterion = 'MATCH_ANY' # default
        assertValidSFString(matchCriterion)
        assertValidPickSensorMatchCriterion('matchCriterion', matchCriterion)
        self.__matchCriterion = matchCriterion
    @property # getter - - - - - - - - - -
    def objectType(self):
        """The objectType field specifies a set of labels used in the picking process."""
        return self.__objectType
    @objectType.setter
    def objectType(self, objectType):
        if  objectType is None:
            objectType = ["ALL"] # default
        assertValidMFString(objectType)
        self.__objectType = objectType
    @property # getter - - - - - - - - - -
    def sortOrder(self):
        """The sortOrder field determines the order provided for picked output events."""
        return self.__sortOrder
    @sortOrder.setter
    def sortOrder(self, sortOrder):
        if  sortOrder is None:
            sortOrder = 'CLOSEST' # default
        assertValidSFString(sortOrder)
        self.__sortOrder = sortOrder
    @property # getter - - - - - - - - - -
    def pickingGeometry(self):
        """[IndexedLineSet|LineSet] pickingGeometry specifies the exact geometry coordinates that are used to perform the intersection testing of the picking operation."""
        return self.__pickingGeometry
    @pickingGeometry.setter
    def pickingGeometry(self, pickingGeometry):
        if  pickingGeometry is None:
            pickingGeometry = None # default
        assertValidSFNode(pickingGeometry)
        if not isinstance(pickingGeometry, object):
            # print(flush=True)
            raise X3DTypeError(str(pickingGeometry) + ' does not have a valid node type object')
        self.__pickingGeometry = pickingGeometry
    @property # getter - - - - - - - - - -
    def pickTarget(self):
        """[X3DGroupingNode|X3DShapeNode|Inline] pickTarget specifies the list of nodes against which picking operations are performed."""
        return self.__pickTarget
    @pickTarget.setter
    def pickTarget(self, pickTarget):
        if  pickTarget is None:
            pickTarget = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(pickTarget)
        self.__pickTarget = pickTarget
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.pickTarget or self.IS or self.metadata or self.pickingGeometry
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function LinePickSensor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<LinePickSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.intersectionType != 'BOUNDS':
            result += " intersectionType='" + self.intersectionType + "'"
        if self.matchCriterion != 'MATCH_ANY':
            result += " matchCriterion='" + self.matchCriterion + "'"
        if self.objectType != ["ALL"]:
            result += " objectType='" + MFString(self.objectType).XML() + "'"
        if self.sortOrder != 'CLOSEST':
            result += " sortOrder='" + self.sortOrder + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></LinePickSensor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.pickingGeometry: # output this SFNode
                result += self.pickingGeometry.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.pickTarget: # walk each child in MFNode list, if any
            ### print('* LinePickSensor found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(pickTarget)=' + str(len(self.pickTarget)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.pickTarget:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</LinePickSensor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function LinePickSensor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'LinePickSensor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'LinePickSensor' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.intersectionType != 'BOUNDS':
            result += " intersectionType " +  '"' + self.intersectionType + '"' + ""
        if self.matchCriterion != 'MATCH_ANY':
            result += " matchCriterion " +  '"' + self.matchCriterion + '"' + ""
        if self.objectType != ["ALL"]:
            result += " objectType " + MFString(self.objectType).VRML() + ""
        if self.sortOrder != 'CLOSEST':
            result += " sortOrder " +  '"' + self.sortOrder + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.pickingGeometry: # output this SFNode
            result += '\n' + '  ' + indent + 'pickingGeometry ' + self.pickingGeometry.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.pickTarget: # walk each child in MFNode list, if any
            for each in self.pickTarget:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class LineProperties(_X3DAppearanceChildNode):
    """
    LineProperties allows precise fine-grained control over the rendering style of lines and edges for associated geometry nodes inside the same Shape.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'LineProperties'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shape.html#LineProperties'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LineProperties'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('applied', True, FieldType.SFBool, AccessType.inputOutput, 'LineProperties'),
            ('linetype', 1, FieldType.SFInt32, AccessType.inputOutput, 'LineProperties'),
            ('linewidthScaleFactor', 0, FieldType.SFFloat, AccessType.inputOutput, 'LineProperties'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 applied=True,
                 linetype=1,
                 linewidthScaleFactor=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode LineProperties __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.applied = applied
        self.linetype = linetype
        self.linewidthScaleFactor = linewidthScaleFactor
    @property # getter - - - - - - - - - -
    def applied(self):
        """Whether or not LineProperties are applied to associated geometry."""
        return self.__applied
    @applied.setter
    def applied(self, applied):
        if  applied is None:
            applied = True # default
        assertValidSFBool(applied)
        self.__applied = applied
    @property # getter - - - - - - - - - -
    def linetype(self):
        """linetype selects a line pattern, with solid default if defined value isn't supported."""
        return self.__linetype
    @linetype.setter
    def linetype(self, linetype):
        if  linetype is None:
            linetype = 1 # default
        assertValidSFInt32(linetype)
        assertGreaterThanEquals('linetype', linetype, 1)
        self.__linetype = linetype
    @property # getter - - - - - - - - - -
    def linewidthScaleFactor(self):
        """linewidthScaleFactor is a scale factor multiplied by browser-dependent nominal linewidth, mapped to nearest available line width."""
        return self.__linewidthScaleFactor
    @linewidthScaleFactor.setter
    def linewidthScaleFactor(self, linewidthScaleFactor):
        if  linewidthScaleFactor is None:
            linewidthScaleFactor = 0 # default
        assertValidSFFloat(linewidthScaleFactor)
        self.__linewidthScaleFactor = linewidthScaleFactor
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function LineProperties.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<LineProperties'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.applied: # default=true
            result += " applied='" + SFBool(self.applied).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.linetype != 1:
            result += " linetype='" + SFInt32(self.linetype).XML() + "'"
        if self.linewidthScaleFactor != 0:
            result += " linewidthScaleFactor='" + SFFloat(self.linewidthScaleFactor).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></LineProperties>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</LineProperties>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function LineProperties.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'LineProperties' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'LineProperties' + ' {'
        if not self.applied: # default=true
            result += " applied " + SFBool(self.applied).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.linetype != 1:
            result += " linetype " + SFInt32(self.linetype).VRML() + ""
        if self.linewidthScaleFactor != 0:
            result += " linewidthScaleFactor " + SFFloat(self.linewidthScaleFactor).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class LineSet(_X3DGeometryNode):
    """
    LineSet is a geometry node that can contain a Coordinate|CoordinateDouble node and optionally a Color|ColorRGBA node.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'LineSet'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#LineSet'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LineSet'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('vertexCount', list(), FieldType.MFInt32, AccessType.inputOutput, 'LineSet'),
            ('color', None, FieldType.SFNode, AccessType.inputOutput, 'LineSet'),
            ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'LineSet'),
            ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'LineSet'),
            ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'LineSet'),
            ('attrib', list(), FieldType.MFNode, AccessType.inputOutput, 'LineSet'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 vertexCount=list(),
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 attrib=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode LineSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.vertexCount = vertexCount
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def vertexCount(self):
        """[2,+infinity) vertexCount describes how many vertices are used in each individual polyline segment from the Coordinate point values."""
        return self.__vertexCount
    @vertexCount.setter
    def vertexCount(self, vertexCount):
        if  vertexCount is None:
            vertexCount = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(vertexCount)
        assertGreaterThanEquals('vertexCount', vertexCount, 2)
        self.__vertexCount = vertexCount
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that specifies color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None # default
        assertValidSFNode(color)
        if not isinstance(color, object):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that specifies a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None # default
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that specifies depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None # default
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None # default
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that specifies list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.attrib or self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function LineSet.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<LineSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.vertexCount != list():
            result += " vertexCount='" + MFInt32(self.vertexCount).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></LineSet>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.color: # output this SFNode
                result += self.color.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.coord: # output this SFNode
                result += self.coord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.fogCoord: # output this SFNode
                result += self.fogCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.normal: # output this SFNode
                result += self.normal.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.attrib: # walk each child in MFNode list, if any
            ### print('* LineSet found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(attrib)=' + str(len(self.attrib)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.attrib:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</LineSet>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function LineSet.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'LineSet' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'LineSet' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.vertexCount != list():
            result += " vertexCount " + MFInt32(self.vertexCount).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.color: # output this SFNode
            result += '\n' + '  ' + indent + 'color ' + self.color.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.coord: # output this SFNode
            result += '\n' + '  ' + indent + 'coord ' + self.coord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.fogCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'fogCoord ' + self.fogCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.normal: # output this SFNode
            result += '\n' + '  ' + indent + 'normal ' + self.normal.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.attrib: # walk each child in MFNode list, if any
            for each in self.attrib:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ListenerPointSource(_X3DSoundSourceNode):
    """
    ListenerPointSource node represents position and orientation of a person listening to virtual sound in the audio scene, and provides single or multiple sound channels as output.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ListenerPointSource'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#ListenerPointSource'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ListenerPointSource'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundSourceNode'),
            ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundSourceNode'),
            ('interauralDistance', 0, FieldType.SFFloat, AccessType.inputOutput, 'ListenerPointSource'),
            ('orientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'ListenerPointSource'),
            ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('position', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'ListenerPointSource'),
            ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('trackCurrentView', False, FieldType.SFBool, AccessType.inputOutput, 'ListenerPointSource'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 enabled=True,
                 gain=1,
                 interauralDistance=0,
                 orientation=(0, 0, 1, 0),
                 pauseTime=0,
                 position=(0, 0, 0),
                 resumeTime=0,
                 startTime=0,
                 stopTime=0,
                 trackCurrentView=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ListenerPointSource __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.interauralDistance = interauralDistance
        self.orientation = orientation
        self.pauseTime = pauseTime
        self.position = position
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.trackCurrentView = trackCurrentView
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1 # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def interauralDistance(self):
        """[0,+infinity) The interauralDistance field is."""
        return self.__interauralDistance
    @interauralDistance.setter
    def interauralDistance(self, interauralDistance):
        if  interauralDistance is None:
            interauralDistance = 0 # default
        assertValidSFFloat(interauralDistance)
        assertNonNegative('interauralDistance', interauralDistance)
        self.__interauralDistance = interauralDistance
    @property # getter - - - - - - - - - -
    def orientation(self):
        """Rotation (axis, angle in radians) of listening point direction relative to default -Z axis direction in local coordinate system."""
        return self.__orientation
    @orientation.setter
    def orientation(self, orientation):
        if  orientation is None:
            orientation = (0, 0, 1, 0) # default
        assertValidSFRotation(orientation)
        self.__orientation = orientation
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0 # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def position(self):
        """position (x, y, z in meters) relative to local coordinate system."""
        return self.__position
    @position.setter
    def position(self, position):
        if  position is None:
            position = (0, 0, 0) # default
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0 # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0 # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0 # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def trackCurrentView(self):
        """If trackCurrentView field is true then position and orientation match avatar's (user's) current view."""
        return self.__trackCurrentView
    @trackCurrentView.setter
    def trackCurrentView(self, trackCurrentView):
        if  trackCurrentView is None:
            trackCurrentView = False # default
        assertValidSFBool(trackCurrentView)
        self.__trackCurrentView = trackCurrentView
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ListenerPointSource.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ListenerPointSource'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.gain != 1:
            result += " gain='" + SFFloat(self.gain).XML() + "'"
        if self.interauralDistance != 0:
            result += " interauralDistance='" + SFFloat(self.interauralDistance).XML() + "'"
        if self.orientation != (0, 0, 1, 0):
            result += " orientation='" + SFRotation(self.orientation).XML() + "'"
        if self.pauseTime != 0:
            result += " pauseTime='" + SFTime(self.pauseTime).XML() + "'"
        if self.position != (0, 0, 0):
            result += " position='" + SFVec3f(self.position).XML() + "'"
        if self.resumeTime != 0:
            result += " resumeTime='" + SFTime(self.resumeTime).XML() + "'"
        if self.startTime != 0:
            result += " startTime='" + SFTime(self.startTime).XML() + "'"
        if self.stopTime != 0:
            result += " stopTime='" + SFTime(self.stopTime).XML() + "'"
        if self.trackCurrentView: # default=false
            result += " trackCurrentView='" + SFBool(self.trackCurrentView).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ListenerPointSource>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ListenerPointSource>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ListenerPointSource.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ListenerPointSource' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ListenerPointSource' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.gain != 1:
            result += " gain " + SFFloat(self.gain).VRML() + ""
        if self.interauralDistance != 0:
            result += " interauralDistance " + SFFloat(self.interauralDistance).VRML() + ""
        if self.orientation != (0, 0, 1, 0):
            result += " orientation " + SFRotation(self.orientation).VRML() + ""
        if self.pauseTime != 0:
            result += " pauseTime " + SFTime(self.pauseTime).VRML() + ""
        if self.position != (0, 0, 0):
            result += " position " + SFVec3f(self.position).VRML() + ""
        if self.resumeTime != 0:
            result += " resumeTime " + SFTime(self.resumeTime).VRML() + ""
        if self.startTime != 0:
            result += " startTime " + SFTime(self.startTime).VRML() + ""
        if self.stopTime != 0:
            result += " stopTime " + SFTime(self.stopTime).VRML() + ""
        if self.trackCurrentView: # default=false
            result += " trackCurrentView " + SFBool(self.trackCurrentView).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class LoadSensor(_X3DNetworkSensorNode):
    """
    LoadSensor generates events as watchList child nodes are either loaded or fail to load.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'LoadSensor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/networking.html#LoadSensor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LoadSensor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('timeOut', 0, FieldType.SFTime, AccessType.inputOutput, 'LoadSensor'),
            ('watchList', list(), FieldType.MFNode, AccessType.inputOutput, 'LoadSensor'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 enabled=True,
                 timeOut=0,
                 watchList=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode LoadSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.timeOut = timeOut
        self.watchList = watchList
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def timeOut(self):
        """Time in seconds of maximum load duration prior to declaring failure."""
        return self.__timeOut
    @timeOut.setter
    def timeOut(self, timeOut):
        if  timeOut is None:
            timeOut = 0 # default
        assertValidSFTime(timeOut)
        assertNonNegative('timeOut', timeOut)
        self.__timeOut = timeOut
    @property # getter - - - - - - - - - -
    def watchList(self):
        """[X3DUrlObject] The watchList field monitors one or more USE nodes that contain a valid url field."""
        return self.__watchList
    @watchList.setter
    def watchList(self, watchList):
        if  watchList is None:
            watchList = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(watchList)
        self.__watchList = watchList
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.watchList or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function LoadSensor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<LoadSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.timeOut != 0:
            result += " timeOut='" + SFTime(self.timeOut).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></LoadSensor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.watchList: # walk each child in MFNode list, if any
            ### print('* LoadSensor found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(watchList)=' + str(len(self.watchList)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.watchList:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</LoadSensor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function LoadSensor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'LoadSensor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'LoadSensor' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.timeOut != 0:
            result += " timeOut " + SFTime(self.timeOut).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.watchList: # walk each child in MFNode list, if any
            for each in self.watchList:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class LocalFog(_X3DChildNode, _X3DFogObject):
    """
    LocalFog simulates atmospheric effects by blending distant objects with fog color.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'LocalFog'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/environmentalEffects.html#LocalFog'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LocalFog'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'X3DFogObject'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'LocalFog'),
            ('fogType', 'LINEAR', FieldType.SFString, AccessType.inputOutput, 'X3DFogObject'),
            ('visibilityRange', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DFogObject'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 color=(1, 1, 1),
                 enabled=True,
                 fogType='LINEAR',
                 visibilityRange=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode LocalFog __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.color = color
        self.enabled = enabled
        self.fogType = fogType
        self.visibilityRange = visibilityRange
    @property # getter - - - - - - - - - -
    def color(self):
        """[0,1] Fog color."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = (1, 1, 1) # default
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def fogType(self):
        """Specifies algorithm for rate of increasing Fog, either LINEAR or EXPONENTIAL."""
        return self.__fogType
    @fogType.setter
    def fogType(self, fogType):
        if  fogType is None:
            fogType = 'LINEAR' # default
        assertValidSFString(fogType)
        assertValidFogType('fogType', fogType)
        self.__fogType = fogType
    @property # getter - - - - - - - - - -
    def visibilityRange(self):
        """Distance in meters where objects are totally obscured by the fog, using local coordinate system."""
        return self.__visibilityRange
    @visibilityRange.setter
    def visibilityRange(self, visibilityRange):
        if  visibilityRange is None:
            visibilityRange = 0 # default
        assertValidSFFloat(visibilityRange)
        assertNonNegative('visibilityRange', visibilityRange)
        self.__visibilityRange = visibilityRange
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function LocalFog.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<LocalFog'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.color != (1, 1, 1):
            result += " color='" + SFColor(self.color).XML() + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.fogType != 'LINEAR':
            result += " fogType='" + self.fogType + "'"
        if self.visibilityRange != 0:
            result += " visibilityRange='" + SFFloat(self.visibilityRange).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></LocalFog>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</LocalFog>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function LocalFog.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'LocalFog' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'LocalFog' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.color != (1, 1, 1):
            result += " color " + SFColor(self.color).VRML() + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.fogType != 'LINEAR':
            result += " fogType " +  '"' + self.fogType + '"' + ""
        if self.visibilityRange != 0:
            result += " visibilityRange " + SFFloat(self.visibilityRange).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class LOD(_X3DGroupingNode):
    """
    LOD (Level Of Detail) uses camera-to-object distance to switch among contained child levels.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'LOD'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/navigation.html#LOD'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#LOD'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'LOD'),
            ('forceTransitions', False, FieldType.SFBool, AccessType.initializeOnly, 'LOD'),
            ('range', list(), FieldType.MFFloat, AccessType.initializeOnly, 'LOD'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 center=(0, 0, 0),
                 forceTransitions=False,
                 range=list(),
                 visible=True,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode LOD __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.center = center
        self.forceTransitions = forceTransitions
        self.range = range
        self.visible = visible
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        """Viewpoint distance-measurement offset from origin of local coordinate system, used for LOD node distance calculations."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0) # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def forceTransitions(self):
        """Whether to perform every range-based transition, regardless of browser optimizations that might otherwise occur."""
        return self.__forceTransitions
    @forceTransitions.setter
    def forceTransitions(self, forceTransitions):
        if  forceTransitions is None:
            forceTransitions = False # default
        assertValidSFBool(forceTransitions)
        self.__forceTransitions = forceTransitions
    @property # getter - - - - - - - - - -
    def range(self):
        """(0,+infinity) Specifies ideal distances at which to switch between levels."""
        return self.__range
    @range.setter
    def range(self, range):
        if  range is None:
            range = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(range)
        self.__range = range
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function LOD.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<LOD'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.center != (0, 0, 0):
            result += " center='" + SFVec3f(self.center).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.forceTransitions: # default=false
            result += " forceTransitions='" + SFBool(self.forceTransitions).XML() + "'"
        if self.range != list():
            result += " range='" + MFFloat(self.range).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></LOD>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* LOD found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</LOD>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function LOD.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'LOD' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'LOD' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.center != (0, 0, 0):
            result += " center " + SFVec3f(self.center).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.forceTransitions: # default=false
            result += " forceTransitions " + SFBool(self.forceTransitions).VRML() + ""
        if self.range != list():
            result += " range " + MFFloat(self.range).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Material(_X3DOneSidedMaterialNode):
    """
    Material specifies surface rendering properties for associated geometry nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Material'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shape.html#Material'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Material'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ambientIntensity', 0.2, FieldType.SFFloat, AccessType.inputOutput, 'Material'),
            ('ambientTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'Material'),
            ('diffuseColor', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.inputOutput, 'Material'),
            ('diffuseTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'Material'),
            ('emissiveColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
            ('emissiveTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
            ('normalScale', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
            ('normalTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
            ('occlusionStrength', 1, FieldType.SFFloat, AccessType.inputOutput, 'Material'),
            ('occlusionTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'Material'),
            ('shininess', 0.2, FieldType.SFFloat, AccessType.inputOutput, 'Material'),
            ('shininessTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'Material'),
            ('specularColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput, 'Material'),
            ('specularTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'Material'),
            ('transparency', 0, FieldType.SFFloat, AccessType.inputOutput, 'Material'),
            ('ambientTexture', None, FieldType.SFNode, AccessType.inputOutput, 'Material'),
            ('diffuseTexture', None, FieldType.SFNode, AccessType.inputOutput, 'Material'),
            ('emissiveTexture', None, FieldType.SFNode, AccessType.inputOutput, 'Material'),
            ('normalTexture', None, FieldType.SFNode, AccessType.inputOutput, 'Material'),
            ('occlusionTexture', None, FieldType.SFNode, AccessType.inputOutput, 'Material'),
            ('shininessTexture', None, FieldType.SFNode, AccessType.inputOutput, 'Material'),
            ('specularTexture', None, FieldType.SFNode, AccessType.inputOutput, 'Material'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ambientIntensity=0.2,
                 ambientTextureMapping='',
                 diffuseColor=(0.8, 0.8, 0.8),
                 diffuseTextureMapping='',
                 emissiveColor=(0, 0, 0),
                 emissiveTextureMapping='',
                 normalScale=1,
                 normalTextureMapping='',
                 occlusionStrength=1,
                 occlusionTextureMapping='',
                 shininess=0.2,
                 shininessTextureMapping='',
                 specularColor=(0, 0, 0),
                 specularTextureMapping='',
                 transparency=0,
                 ambientTexture=None,
                 diffuseTexture=None,
                 emissiveTexture=None,
                 normalTexture=None,
                 occlusionTexture=None,
                 shininessTexture=None,
                 specularTexture=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Material __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.ambientTextureMapping = ambientTextureMapping
        self.diffuseColor = diffuseColor
        self.diffuseTextureMapping = diffuseTextureMapping
        self.emissiveColor = emissiveColor
        self.emissiveTextureMapping = emissiveTextureMapping
        self.normalScale = normalScale
        self.normalTextureMapping = normalTextureMapping
        self.occlusionStrength = occlusionStrength
        self.occlusionTextureMapping = occlusionTextureMapping
        self.shininess = shininess
        self.shininessTextureMapping = shininessTextureMapping
        self.specularColor = specularColor
        self.specularTextureMapping = specularTextureMapping
        self.transparency = transparency
        self.ambientTexture = ambientTexture
        self.diffuseTexture = diffuseTexture
        self.emissiveTexture = emissiveTexture
        self.normalTexture = normalTexture
        self.occlusionTexture = occlusionTexture
        self.shininessTexture = shininessTexture
        self.specularTexture = specularTexture
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        """[0,1] how much ambient omnidirectional light is reflected from all light sources."""
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity):
        if  ambientIntensity is None:
            ambientIntensity = 0.2 # default
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def ambientTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__ambientTextureMapping
    @ambientTextureMapping.setter
    def ambientTextureMapping(self, ambientTextureMapping):
        if  ambientTextureMapping is None:
            ambientTextureMapping = SFString.DEFAULT_VALUE(self)
        assertValidSFString(ambientTextureMapping)
        self.__ambientTextureMapping = ambientTextureMapping
    @property # getter - - - - - - - - - -
    def diffuseColor(self):
        """[0,1] how much direct, angle-dependent light is reflected from all light sources."""
        return self.__diffuseColor
    @diffuseColor.setter
    def diffuseColor(self, diffuseColor):
        if  diffuseColor is None:
            diffuseColor = (0.8, 0.8, 0.8) # default
        assertValidSFColor(diffuseColor)
        assertZeroToOne('diffuseColor', diffuseColor)
        self.__diffuseColor = diffuseColor
    @property # getter - - - - - - - - - -
    def diffuseTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__diffuseTextureMapping
    @diffuseTextureMapping.setter
    def diffuseTextureMapping(self, diffuseTextureMapping):
        if  diffuseTextureMapping is None:
            diffuseTextureMapping = SFString.DEFAULT_VALUE(self)
        assertValidSFString(diffuseTextureMapping)
        self.__diffuseTextureMapping = diffuseTextureMapping
    @property # getter - - - - - - - - - -
    def emissiveColor(self):
        """[0,1] how much glowing light is emitted from this object."""
        return self.__emissiveColor
    @emissiveColor.setter
    def emissiveColor(self, emissiveColor):
        if  emissiveColor is None:
            emissiveColor = (0, 0, 0) # default
        assertValidSFColor(emissiveColor)
        assertZeroToOne('emissiveColor', emissiveColor)
        self.__emissiveColor = emissiveColor
    @property # getter - - - - - - - - - -
    def emissiveTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__emissiveTextureMapping
    @emissiveTextureMapping.setter
    def emissiveTextureMapping(self, emissiveTextureMapping):
        if  emissiveTextureMapping is None:
            emissiveTextureMapping = SFString.DEFAULT_VALUE(self)
        assertValidSFString(emissiveTextureMapping)
        self.__emissiveTextureMapping = emissiveTextureMapping
    @property # getter - - - - - - - - - -
    def normalScale(self):
        """[0,infinity] normalScale controls the degree to which normalTexture RGB values apply XYZ-normal bump mapping to pixels in the parent material."""
        return self.__normalScale
    @normalScale.setter
    def normalScale(self, normalScale):
        if  normalScale is None:
            normalScale = 1 # default
        assertValidSFFloat(normalScale)
        assertNonNegative('normalScale', normalScale)
        self.__normalScale = normalScale
    @property # getter - - - - - - - - - -
    def normalTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__normalTextureMapping
    @normalTextureMapping.setter
    def normalTextureMapping(self, normalTextureMapping):
        if  normalTextureMapping is None:
            normalTextureMapping = SFString.DEFAULT_VALUE(self)
        assertValidSFString(normalTextureMapping)
        self.__normalTextureMapping = normalTextureMapping
    @property # getter - - - - - - - - - -
    def occlusionStrength(self):
        """[0,1] occlusionStrength indicates areas of indirect lighting, typically called ambient occlusion."""
        return self.__occlusionStrength
    @occlusionStrength.setter
    def occlusionStrength(self, occlusionStrength):
        if  occlusionStrength is None:
            occlusionStrength = 1 # default
        assertValidSFFloat(occlusionStrength)
        assertZeroToOne('occlusionStrength', occlusionStrength)
        self.__occlusionStrength = occlusionStrength
    @property # getter - - - - - - - - - -
    def occlusionTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__occlusionTextureMapping
    @occlusionTextureMapping.setter
    def occlusionTextureMapping(self, occlusionTextureMapping):
        if  occlusionTextureMapping is None:
            occlusionTextureMapping = SFString.DEFAULT_VALUE(self)
        assertValidSFString(occlusionTextureMapping)
        self.__occlusionTextureMapping = occlusionTextureMapping
    @property # getter - - - - - - - - - -
    def shininess(self):
        """[0,1] Lower shininess values provide soft specular glows, while higher values result in sharper, smaller highlights."""
        return self.__shininess
    @shininess.setter
    def shininess(self, shininess):
        if  shininess is None:
            shininess = 0.2 # default
        assertValidSFFloat(shininess)
        assertZeroToOne('shininess', shininess)
        self.__shininess = shininess
    @property # getter - - - - - - - - - -
    def shininessTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__shininessTextureMapping
    @shininessTextureMapping.setter
    def shininessTextureMapping(self, shininessTextureMapping):
        if  shininessTextureMapping is None:
            shininessTextureMapping = SFString.DEFAULT_VALUE(self)
        assertValidSFString(shininessTextureMapping)
        self.__shininessTextureMapping = shininessTextureMapping
    @property # getter - - - - - - - - - -
    def specularColor(self):
        """[0,1] specular highlights are brightness reflections (example: shiny spots on an apple)."""
        return self.__specularColor
    @specularColor.setter
    def specularColor(self, specularColor):
        if  specularColor is None:
            specularColor = (0, 0, 0) # default
        assertValidSFColor(specularColor)
        assertZeroToOne('specularColor', specularColor)
        self.__specularColor = specularColor
    @property # getter - - - - - - - - - -
    def specularTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__specularTextureMapping
    @specularTextureMapping.setter
    def specularTextureMapping(self, specularTextureMapping):
        if  specularTextureMapping is None:
            specularTextureMapping = SFString.DEFAULT_VALUE(self)
        assertValidSFString(specularTextureMapping)
        self.__specularTextureMapping = specularTextureMapping
    @property # getter - - - - - - - - - -
    def transparency(self):
        """[0,1] how "clear" an object is: 1."""
        return self.__transparency
    @transparency.setter
    def transparency(self, transparency):
        if  transparency is None:
            transparency = 0 # default
        assertValidSFFloat(transparency)
        assertZeroToOne('transparency', transparency)
        self.__transparency = transparency
    @property # getter - - - - - - - - - -
    def ambientTexture(self):
        """[X3DSingleTextureNode] When applying ambientIntensity for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__ambientTexture
    @ambientTexture.setter
    def ambientTexture(self, ambientTexture):
        if  ambientTexture is None:
            ambientTexture = None # default
        assertValidSFNode(ambientTexture)
        if not isinstance(ambientTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(ambientTexture) + ' does not have a valid node type object')
        self.__ambientTexture = ambientTexture
    @property # getter - - - - - - - - - -
    def diffuseTexture(self):
        """[X3DSingleTextureNode] When applying diffuseColor for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__diffuseTexture
    @diffuseTexture.setter
    def diffuseTexture(self, diffuseTexture):
        if  diffuseTexture is None:
            diffuseTexture = None # default
        assertValidSFNode(diffuseTexture)
        if not isinstance(diffuseTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(diffuseTexture) + ' does not have a valid node type object')
        self.__diffuseTexture = diffuseTexture
    @property # getter - - - - - - - - - -
    def emissiveTexture(self):
        """[X3DSingleTextureNode] When applying emissiveColor for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__emissiveTexture
    @emissiveTexture.setter
    def emissiveTexture(self, emissiveTexture):
        if  emissiveTexture is None:
            emissiveTexture = None # default
        assertValidSFNode(emissiveTexture)
        if not isinstance(emissiveTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(emissiveTexture) + ' does not have a valid node type object')
        self.__emissiveTexture = emissiveTexture
    @property # getter - - - - - - - - - -
    def normalTexture(self):
        """[X3DSingleTextureNode] When applying normalScale for this material node, the contained texture modulates the texture across the surface."""
        return self.__normalTexture
    @normalTexture.setter
    def normalTexture(self, normalTexture):
        if  normalTexture is None:
            normalTexture = None # default
        assertValidSFNode(normalTexture)
        if not isinstance(normalTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(normalTexture) + ' does not have a valid node type object')
        self.__normalTexture = normalTexture
    @property # getter - - - - - - - - - -
    def occlusionTexture(self):
        """[X3DSingleTextureNode] When applying occlusionStrength for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__occlusionTexture
    @occlusionTexture.setter
    def occlusionTexture(self, occlusionTexture):
        if  occlusionTexture is None:
            occlusionTexture = None # default
        assertValidSFNode(occlusionTexture)
        if not isinstance(occlusionTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(occlusionTexture) + ' does not have a valid node type object')
        self.__occlusionTexture = occlusionTexture
    @property # getter - - - - - - - - - -
    def shininessTexture(self):
        """[X3DSingleTextureNode] When applying shininess for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__shininessTexture
    @shininessTexture.setter
    def shininessTexture(self, shininessTexture):
        if  shininessTexture is None:
            shininessTexture = None # default
        assertValidSFNode(shininessTexture)
        if not isinstance(shininessTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(shininessTexture) + ' does not have a valid node type object')
        self.__shininessTexture = shininessTexture
    @property # getter - - - - - - - - - -
    def specularTexture(self):
        """[X3DSingleTextureNode] When applying specularColor for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__specularTexture
    @specularTexture.setter
    def specularTexture(self, specularTexture):
        if  specularTexture is None:
            specularTexture = None # default
        assertValidSFNode(specularTexture)
        if not isinstance(specularTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(specularTexture) + ' does not have a valid node type object')
        self.__specularTexture = specularTexture
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.ambientTexture or self.diffuseTexture or self.emissiveTexture or self.IS or self.metadata or self.normalTexture or self.occlusionTexture or self.shininessTexture or self.specularTexture
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Material.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Material'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ambientIntensity != 0.2:
            result += " ambientIntensity='" + SFFloat(self.ambientIntensity).XML() + "'"
        if self.ambientTextureMapping:
            result += " ambientTextureMapping='" + self.ambientTextureMapping + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.diffuseColor != (0.8, 0.8, 0.8):
            result += " diffuseColor='" + SFColor(self.diffuseColor).XML() + "'"
        if self.diffuseTextureMapping:
            result += " diffuseTextureMapping='" + self.diffuseTextureMapping + "'"
        if self.emissiveColor != (0, 0, 0):
            result += " emissiveColor='" + SFColor(self.emissiveColor).XML() + "'"
        if self.emissiveTextureMapping:
            result += " emissiveTextureMapping='" + self.emissiveTextureMapping + "'"
        if self.normalScale != 1:
            result += " normalScale='" + SFFloat(self.normalScale).XML() + "'"
        if self.normalTextureMapping:
            result += " normalTextureMapping='" + self.normalTextureMapping + "'"
        if self.occlusionStrength != 1:
            result += " occlusionStrength='" + SFFloat(self.occlusionStrength).XML() + "'"
        if self.occlusionTextureMapping:
            result += " occlusionTextureMapping='" + self.occlusionTextureMapping + "'"
        if self.shininess != 0.2:
            result += " shininess='" + SFFloat(self.shininess).XML() + "'"
        if self.shininessTextureMapping:
            result += " shininessTextureMapping='" + self.shininessTextureMapping + "'"
        if self.specularColor != (0, 0, 0):
            result += " specularColor='" + SFColor(self.specularColor).XML() + "'"
        if self.specularTextureMapping:
            result += " specularTextureMapping='" + self.specularTextureMapping + "'"
        if self.transparency != 0:
            result += " transparency='" + SFFloat(self.transparency).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Material>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.ambientTexture: # output this SFNode
                result += self.ambientTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.diffuseTexture: # output this SFNode
                result += self.diffuseTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.emissiveTexture: # output this SFNode
                result += self.emissiveTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.normalTexture: # output this SFNode
                result += self.normalTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.occlusionTexture: # output this SFNode
                result += self.occlusionTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.shininessTexture: # output this SFNode
                result += self.shininessTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.specularTexture: # output this SFNode
                result += self.specularTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Material>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Material.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Material' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Material' + ' {'
        if self.ambientIntensity != 0.2:
            result += " ambientIntensity " + SFFloat(self.ambientIntensity).VRML() + ""
        if self.ambientTextureMapping:
            result += " ambientTextureMapping " +  '"' + self.ambientTextureMapping + '"' + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.diffuseColor != (0.8, 0.8, 0.8):
            result += " diffuseColor " + SFColor(self.diffuseColor).VRML() + ""
        if self.diffuseTextureMapping:
            result += " diffuseTextureMapping " +  '"' + self.diffuseTextureMapping + '"' + ""
        if self.emissiveColor != (0, 0, 0):
            result += " emissiveColor " + SFColor(self.emissiveColor).VRML() + ""
        if self.emissiveTextureMapping:
            result += " emissiveTextureMapping " +  '"' + self.emissiveTextureMapping + '"' + ""
        if self.normalScale != 1:
            result += " normalScale " + SFFloat(self.normalScale).VRML() + ""
        if self.normalTextureMapping:
            result += " normalTextureMapping " +  '"' + self.normalTextureMapping + '"' + ""
        if self.occlusionStrength != 1:
            result += " occlusionStrength " + SFFloat(self.occlusionStrength).VRML() + ""
        if self.occlusionTextureMapping:
            result += " occlusionTextureMapping " +  '"' + self.occlusionTextureMapping + '"' + ""
        if self.shininess != 0.2:
            result += " shininess " + SFFloat(self.shininess).VRML() + ""
        if self.shininessTextureMapping:
            result += " shininessTextureMapping " +  '"' + self.shininessTextureMapping + '"' + ""
        if self.specularColor != (0, 0, 0):
            result += " specularColor " + SFColor(self.specularColor).VRML() + ""
        if self.specularTextureMapping:
            result += " specularTextureMapping " +  '"' + self.specularTextureMapping + '"' + ""
        if self.transparency != 0:
            result += " transparency " + SFFloat(self.transparency).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.ambientTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'ambientTexture ' + self.ambientTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.diffuseTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'diffuseTexture ' + self.diffuseTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.emissiveTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'emissiveTexture ' + self.emissiveTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.normalTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'normalTexture ' + self.normalTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.occlusionTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'occlusionTexture ' + self.occlusionTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.shininessTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'shininessTexture ' + self.shininessTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.specularTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'specularTexture ' + self.specularTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Matrix3VertexAttribute(_X3DVertexAttributeNode):
    """
    Matrix3VertexAttribute defines a set of per-vertex 3x3 matrix attributes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Matrix3VertexAttribute'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shaders.html#Matrix3VertexAttribute'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Matrix3VertexAttribute'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DVertexAttributeNode'),
            ('value', list(), FieldType.MFMatrix3f, AccessType.inputOutput, 'Matrix3VertexAttribute'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 name='',
                 value=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Matrix3VertexAttribute __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.value = value
    @property # getter - - - - - - - - - -
    def name(self):
        """Required name for this particular VertexAttribute instance."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def value(self):
        """value specifies an arbitrary collection of matrix values that will be passed to the shader as per-vertex information."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = MFMatrix3f.DEFAULT_VALUE(self)
        assertValidMFMatrix3f(value)
        self.__value = value
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Matrix3VertexAttribute.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Matrix3VertexAttribute'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.value != list():
            result += " value='" + MFMatrix3f(self.value).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Matrix3VertexAttribute>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Matrix3VertexAttribute>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Matrix3VertexAttribute.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Matrix3VertexAttribute' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Matrix3VertexAttribute' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if self.value != list():
            result += " value " + MFMatrix3f(self.value).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Matrix4VertexAttribute(_X3DVertexAttributeNode):
    """
    Matrix4VertexAttribute defines a set of per-vertex 4x4 matrix attributes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Matrix4VertexAttribute'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shaders.html#Matrix4VertexAttribute'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Matrix4VertexAttribute'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DVertexAttributeNode'),
            ('value', list(), FieldType.MFMatrix4f, AccessType.inputOutput, 'Matrix4VertexAttribute'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 name='',
                 value=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Matrix4VertexAttribute __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.value = value
    @property # getter - - - - - - - - - -
    def name(self):
        """Required name for this particular VertexAttribute instance."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def value(self):
        """value specifies an arbitrary collection of matrix values that will be passed to the shader as per-vertex information."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = MFMatrix4f.DEFAULT_VALUE(self)
        assertValidMFMatrix4f(value)
        self.__value = value
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Matrix4VertexAttribute.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Matrix4VertexAttribute'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.value != list():
            result += " value='" + MFMatrix4f(self.value).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Matrix4VertexAttribute>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Matrix4VertexAttribute>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Matrix4VertexAttribute.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Matrix4VertexAttribute' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Matrix4VertexAttribute' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if self.value != list():
            result += " value " + MFMatrix4f(self.value).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class MetadataBoolean(_X3DNode): # , _X3DMetadataObject # TODO fix additional inheritance method resolution order (MRO)
    """
    The metadata provided by this node is contained in the Boolean values of the value field.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'MetadataBoolean'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/core.html#MetadataBoolean'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataBoolean'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
            ('reference', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
            ('value', list(), FieldType.MFBool, AccessType.inputOutput, 'MetadataBoolean'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 name='',
                 reference='',
                 value=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MetadataBoolean __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.reference = reference
        self.value = value
    @property # getter - - - - - - - - - -
    def name(self):
        """Depending on the metadata vocabulary, the attribute name is usually required for metadata nodes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def reference(self):
        """Reference to the metadata standard or definition defining this particular metadata value."""
        return self.__reference
    @reference.setter
    def reference(self, reference):
        if  reference is None:
            reference = SFString.DEFAULT_VALUE(self)
        assertValidSFString(reference)
        self.__reference = reference
    @property # getter - - - - - - - - - -
    def value(self):
        """The value attribute is a strictly typed data array providing relevant metadata information."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = MFBool.DEFAULT_VALUE(self)
        assertValidMFBool(value)
        self.__value = value
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function MetadataBoolean.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<MetadataBoolean'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.reference:
            result += " reference='" + self.reference + "'"
        if self.value != list():
            result += " value='" + MFBool(self.value).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></MetadataBoolean>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</MetadataBoolean>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function MetadataBoolean.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'MetadataBoolean' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'MetadataBoolean' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if self.reference:
            result += " reference " +  '"' + self.reference + '"' + ""
        if self.value != list():
            result += " value " + MFBool(self.value).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class MetadataDouble(_X3DNode): # , _X3DMetadataObject # TODO fix additional inheritance method resolution order (MRO)
    """
    The metadata provided by this node is contained in the double-precision floating point numbers of the value field.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'MetadataDouble'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/core.html#MetadataDouble'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataDouble'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
            ('reference', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
            ('value', list(), FieldType.MFDouble, AccessType.inputOutput, 'MetadataDouble'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 name='',
                 reference='',
                 value=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MetadataDouble __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.reference = reference
        self.value = value
    @property # getter - - - - - - - - - -
    def name(self):
        """Depending on the metadata vocabulary, the attribute name is usually required for metadata nodes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def reference(self):
        """Reference to the metadata standard or definition defining this particular metadata value."""
        return self.__reference
    @reference.setter
    def reference(self, reference):
        if  reference is None:
            reference = SFString.DEFAULT_VALUE(self)
        assertValidSFString(reference)
        self.__reference = reference
    @property # getter - - - - - - - - - -
    def value(self):
        """The value attribute is a strictly typed data array providing relevant metadata information."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(value)
        self.__value = value
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function MetadataDouble.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<MetadataDouble'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.reference:
            result += " reference='" + self.reference + "'"
        if self.value != list():
            result += " value='" + MFDouble(self.value).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></MetadataDouble>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</MetadataDouble>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function MetadataDouble.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'MetadataDouble' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'MetadataDouble' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if self.reference:
            result += " reference " +  '"' + self.reference + '"' + ""
        if self.value != list():
            result += " value " + MFDouble(self.value).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class MetadataFloat(_X3DNode): # , _X3DMetadataObject # TODO fix additional inheritance method resolution order (MRO)
    """
    The metadata provided by this node is contained in the single-precision floating point numbers of the value field.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'MetadataFloat'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/core.html#MetadataFloat'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataFloat'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
            ('reference', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
            ('value', list(), FieldType.MFFloat, AccessType.inputOutput, 'MetadataFloat'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 name='',
                 reference='',
                 value=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MetadataFloat __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.reference = reference
        self.value = value
    @property # getter - - - - - - - - - -
    def name(self):
        """Depending on the metadata vocabulary, the attribute name is usually required for metadata nodes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def reference(self):
        """Reference to the metadata standard or definition defining this particular metadata value."""
        return self.__reference
    @reference.setter
    def reference(self, reference):
        if  reference is None:
            reference = SFString.DEFAULT_VALUE(self)
        assertValidSFString(reference)
        self.__reference = reference
    @property # getter - - - - - - - - - -
    def value(self):
        """The value attribute is a strictly typed data array providing relevant metadata information."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(value)
        self.__value = value
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function MetadataFloat.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<MetadataFloat'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.reference:
            result += " reference='" + self.reference + "'"
        if self.value != list():
            result += " value='" + MFFloat(self.value).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></MetadataFloat>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</MetadataFloat>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function MetadataFloat.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'MetadataFloat' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'MetadataFloat' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if self.reference:
            result += " reference " +  '"' + self.reference + '"' + ""
        if self.value != list():
            result += " value " + MFFloat(self.value).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class MetadataInteger(_X3DNode): # , _X3DMetadataObject # TODO fix additional inheritance method resolution order (MRO)
    """
    The metadata provided by this node is contained in the integer numbers of the value field.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'MetadataInteger'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/core.html#MetadataInteger'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataInteger'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
            ('reference', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
            ('value', list(), FieldType.MFInt32, AccessType.inputOutput, 'MetadataInteger'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 name='',
                 reference='',
                 value=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MetadataInteger __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.reference = reference
        self.value = value
    @property # getter - - - - - - - - - -
    def name(self):
        """Depending on the metadata vocabulary, the attribute name is usually required for metadata nodes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def reference(self):
        """Reference to the metadata standard or definition defining this particular metadata value."""
        return self.__reference
    @reference.setter
    def reference(self, reference):
        if  reference is None:
            reference = SFString.DEFAULT_VALUE(self)
        assertValidSFString(reference)
        self.__reference = reference
    @property # getter - - - - - - - - - -
    def value(self):
        """The value attribute is a strictly typed data array providing relevant metadata information."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(value)
        self.__value = value
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function MetadataInteger.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<MetadataInteger'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.reference:
            result += " reference='" + self.reference + "'"
        if self.value != list():
            result += " value='" + MFInt32(self.value).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></MetadataInteger>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</MetadataInteger>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function MetadataInteger.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'MetadataInteger' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'MetadataInteger' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if self.reference:
            result += " reference " +  '"' + self.reference + '"' + ""
        if self.value != list():
            result += " value " + MFInt32(self.value).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class MetadataSet(_X3DNode): # , _X3DMetadataObject # TODO fix additional inheritance method resolution order (MRO)
    """
    The metadata provided by this node is contained in the metadata nodes of the value field.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'MetadataSet'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/core.html#MetadataSet'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataSet'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
            ('reference', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
            ('value', list(), FieldType.MFNode, AccessType.inputOutput, 'MetadataSet'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'MetadataSet'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'MetadataSet')]
    def __init__(self,
                 name='',
                 reference='',
                 value=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MetadataSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.reference = reference
        self.value = value
    @property # getter - - - - - - - - - -
    def name(self):
        """Depending on the metadata vocabulary, the attribute name is usually required for metadata nodes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def reference(self):
        """Reference to the metadata standard or definition defining this particular metadata value."""
        return self.__reference
    @reference.setter
    def reference(self, reference):
        if  reference is None:
            reference = SFString.DEFAULT_VALUE(self)
        assertValidSFString(reference)
        self.__reference = reference
    @property # getter - - - - - - - - - -
    def value(self):
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(value)
        self.__value = value
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.value or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function MetadataSet.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<MetadataSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.reference:
            result += " reference='" + self.reference + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></MetadataSet>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.value: # walk each child in MFNode list, if any
            ### print('* MetadataSet found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(value)=' + str(len(self.value)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.value:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</MetadataSet>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function MetadataSet.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'MetadataSet' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'MetadataSet' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if self.reference:
            result += " reference " +  '"' + self.reference + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.value: # walk each child in MFNode list, if any
            for each in self.value:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class MetadataString(_X3DNode): # , _X3DMetadataObject # TODO fix additional inheritance method resolution order (MRO)
    """
    The metadata provided by this node is contained in the strings of the value field.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'MetadataString'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/core.html#MetadataString'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MetadataString'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
            ('reference', '', FieldType.SFString, AccessType.inputOutput, 'X3DMetadataObject'),
            ('value', list(), FieldType.MFString, AccessType.inputOutput, 'MetadataString'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 name='',
                 reference='',
                 value=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MetadataString __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.reference = reference
        self.value = value
    @property # getter - - - - - - - - - -
    def name(self):
        """Depending on the metadata vocabulary, the attribute name is usually required for metadata nodes."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def reference(self):
        """Reference to the metadata standard or definition defining this particular metadata value."""
        return self.__reference
    @reference.setter
    def reference(self, reference):
        if  reference is None:
            reference = SFString.DEFAULT_VALUE(self)
        assertValidSFString(reference)
        self.__reference = reference
    @property # getter - - - - - - - - - -
    def value(self):
        """The value attribute is a strictly typed data array providing relevant metadata information."""
        return self.__value
    @value.setter
    def value(self, value):
        if  value is None:
            value = MFString.DEFAULT_VALUE(self)
        assertValidMFString(value)
        self.__value = value
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function MetadataString.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<MetadataString'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if self.reference:
            result += " reference='" + self.reference + "'"
        if self.value != list():
            result += " value='" + MFString(self.value).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></MetadataString>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</MetadataString>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function MetadataString.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'MetadataString' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'MetadataString' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if self.reference:
            result += " reference " +  '"' + self.reference + '"' + ""
        if self.value != list():
            result += " value " + MFString(self.value).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class MicrophoneSource(_X3DSoundSourceNode):
    """
    MicrophoneSource captures input from a physical microphone in the real world.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'MicrophoneSource'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#MicrophoneSource'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MicrophoneSource'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundSourceNode'),
            ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundSourceNode'),
            ('mediaDeviceID', '', FieldType.SFString, AccessType.inputOutput, 'MicrophoneSource'),
            ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 enabled=True,
                 gain=1,
                 mediaDeviceID='',
                 pauseTime=0,
                 resumeTime=0,
                 startTime=0,
                 stopTime=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MicrophoneSource __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.mediaDeviceID = mediaDeviceID
        self.pauseTime = pauseTime
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1 # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def mediaDeviceID(self):
        """mediaDeviceID field provides ID parameter functionality."""
        return self.__mediaDeviceID
    @mediaDeviceID.setter
    def mediaDeviceID(self, mediaDeviceID):
        if  mediaDeviceID is None:
            mediaDeviceID = SFString.DEFAULT_VALUE(self)
        assertValidSFString(mediaDeviceID)
        self.__mediaDeviceID = mediaDeviceID
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0 # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0 # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0 # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0 # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function MicrophoneSource.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<MicrophoneSource'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.gain != 1:
            result += " gain='" + SFFloat(self.gain).XML() + "'"
        if self.mediaDeviceID:
            result += " mediaDeviceID='" + self.mediaDeviceID + "'"
        if self.pauseTime != 0:
            result += " pauseTime='" + SFTime(self.pauseTime).XML() + "'"
        if self.resumeTime != 0:
            result += " resumeTime='" + SFTime(self.resumeTime).XML() + "'"
        if self.startTime != 0:
            result += " startTime='" + SFTime(self.startTime).XML() + "'"
        if self.stopTime != 0:
            result += " stopTime='" + SFTime(self.stopTime).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></MicrophoneSource>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</MicrophoneSource>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function MicrophoneSource.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'MicrophoneSource' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'MicrophoneSource' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.gain != 1:
            result += " gain " + SFFloat(self.gain).VRML() + ""
        if self.mediaDeviceID:
            result += " mediaDeviceID " +  '"' + self.mediaDeviceID + '"' + ""
        if self.pauseTime != 0:
            result += " pauseTime " + SFTime(self.pauseTime).VRML() + ""
        if self.resumeTime != 0:
            result += " resumeTime " + SFTime(self.resumeTime).VRML() + ""
        if self.startTime != 0:
            result += " startTime " + SFTime(self.startTime).VRML() + ""
        if self.stopTime != 0:
            result += " stopTime " + SFTime(self.stopTime).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class MotorJoint(_X3DRigidJointNode):
    """
    MotorJoint drives relative angular velocities between body1 and body2 within a common reference frame.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'MotorJoint'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rigidBodyPhysics.html#MotorJoint'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MotorJoint'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('autoCalc', False, FieldType.SFBool, AccessType.initializeOnly, 'MotorJoint'),
            ('axis1Angle', 0, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
            ('axis1Torque', 0, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
            ('axis2Angle', 0, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
            ('axis2Torque', 0, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
            ('axis3Angle', 0, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
            ('axis3Torque', 0, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
            ('enabledAxes', 1, FieldType.SFInt32, AccessType.inputOutput, 'MotorJoint'),
            ('forceOutput', ["NONE"], FieldType.MFString, AccessType.inputOutput, 'X3DRigidJointNode'),
            ('motor1Axis', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'MotorJoint'),
            ('motor2Axis', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'MotorJoint'),
            ('motor3Axis', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'MotorJoint'),
            ('stop1Bounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
            ('stop1ErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
            ('stop2Bounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
            ('stop2ErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
            ('stop3Bounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
            ('stop3ErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'MotorJoint'),
            ('body1', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
            ('body2', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 autoCalc=False,
                 axis1Angle=0,
                 axis1Torque=0,
                 axis2Angle=0,
                 axis2Torque=0,
                 axis3Angle=0,
                 axis3Torque=0,
                 enabledAxes=1,
                 forceOutput=["NONE"],
                 motor1Axis=(0, 0, 0),
                 motor2Axis=(0, 0, 0),
                 motor3Axis=(0, 0, 0),
                 stop1Bounce=0,
                 stop1ErrorCorrection=0.8,
                 stop2Bounce=0,
                 stop2ErrorCorrection=0.8,
                 stop3Bounce=0,
                 stop3ErrorCorrection=0.8,
                 body1=None,
                 body2=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MotorJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.autoCalc = autoCalc
        self.axis1Angle = axis1Angle
        self.axis1Torque = axis1Torque
        self.axis2Angle = axis2Angle
        self.axis2Torque = axis2Torque
        self.axis3Angle = axis3Angle
        self.axis3Torque = axis3Torque
        self.enabledAxes = enabledAxes
        self.forceOutput = forceOutput
        self.motor1Axis = motor1Axis
        self.motor2Axis = motor2Axis
        self.motor3Axis = motor3Axis
        self.stop1Bounce = stop1Bounce
        self.stop1ErrorCorrection = stop1ErrorCorrection
        self.stop2Bounce = stop2Bounce
        self.stop2ErrorCorrection = stop2ErrorCorrection
        self.stop3Bounce = stop3Bounce
        self.stop3ErrorCorrection = stop3ErrorCorrection
        self.body1 = body1
        self.body2 = body2
    @property # getter - - - - - - - - - -
    def autoCalc(self):
        """autoCalc controls whether user manually provides individual angle rotations each frame (false) or if angle values are automatically calculated by motor implementations (true)."""
        return self.__autoCalc
    @autoCalc.setter
    def autoCalc(self, autoCalc):
        if  autoCalc is None:
            autoCalc = False # default
        assertValidSFBool(autoCalc)
        self.__autoCalc = autoCalc
    @property # getter - - - - - - - - - -
    def axis1Angle(self):
        """axis1Angle (radians) is rotation angle for corresponding motor axis when in user-calculated mode."""
        return self.__axis1Angle
    @axis1Angle.setter
    def axis1Angle(self, axis1Angle):
        if  axis1Angle is None:
            axis1Angle = 0 # default
        assertValidSFFloat(axis1Angle)
        self.__axis1Angle = axis1Angle
    @property # getter - - - - - - - - - -
    def axis1Torque(self):
        """axis1Torque is rotational torque applied by corresponding motor axis when in user-calculated mode."""
        return self.__axis1Torque
    @axis1Torque.setter
    def axis1Torque(self, axis1Torque):
        if  axis1Torque is None:
            axis1Torque = 0 # default
        assertValidSFFloat(axis1Torque)
        self.__axis1Torque = axis1Torque
    @property # getter - - - - - - - - - -
    def axis2Angle(self):
        """axis2Angle (radians) is rotation angle for corresponding motor axis when in user-calculated mode."""
        return self.__axis2Angle
    @axis2Angle.setter
    def axis2Angle(self, axis2Angle):
        if  axis2Angle is None:
            axis2Angle = 0 # default
        assertValidSFFloat(axis2Angle)
        self.__axis2Angle = axis2Angle
    @property # getter - - - - - - - - - -
    def axis2Torque(self):
        """axis2Torque is rotational torque applied by corresponding motor axis when in user-calculated mode."""
        return self.__axis2Torque
    @axis2Torque.setter
    def axis2Torque(self, axis2Torque):
        if  axis2Torque is None:
            axis2Torque = 0 # default
        assertValidSFFloat(axis2Torque)
        self.__axis2Torque = axis2Torque
    @property # getter - - - - - - - - - -
    def axis3Angle(self):
        """axis3Angle (radians) is rotation angle for corresponding motor axis when in user-calculated mode."""
        return self.__axis3Angle
    @axis3Angle.setter
    def axis3Angle(self, axis3Angle):
        if  axis3Angle is None:
            axis3Angle = 0 # default
        assertValidSFFloat(axis3Angle)
        self.__axis3Angle = axis3Angle
    @property # getter - - - - - - - - - -
    def axis3Torque(self):
        """axis3Torque is rotational torque applied by corresponding motor axis when in user-calculated mode."""
        return self.__axis3Torque
    @axis3Torque.setter
    def axis3Torque(self, axis3Torque):
        if  axis3Torque is None:
            axis3Torque = 0 # default
        assertValidSFFloat(axis3Torque)
        self.__axis3Torque = axis3Torque
    @property # getter - - - - - - - - - -
    def enabledAxes(self):
        """[0,3] enabledAxes indicates which motor axes are active."""
        return self.__enabledAxes
    @enabledAxes.setter
    def enabledAxes(self, enabledAxes):
        if  enabledAxes is None:
            enabledAxes = 1 # default
        assertValidSFInt32(enabledAxes)
        assertGreaterThanEquals('enabledAxes', enabledAxes, 0)
        assertLessThanEquals('enabledAxes', enabledAxes, 3)
        self.__enabledAxes = enabledAxes
    @property # getter - - - - - - - - - -
    def forceOutput(self):
        """forceOutput controls which output fields are generated for the next frame."""
        return self.__forceOutput
    @forceOutput.setter
    def forceOutput(self, forceOutput):
        if  forceOutput is None:
            forceOutput = ["NONE"] # default
        assertValidMFString(forceOutput)
        self.__forceOutput = forceOutput
    @property # getter - - - - - - - - - -
    def motor1Axis(self):
        """motor1Axis defines axis vector of corresponding motor axis."""
        return self.__motor1Axis
    @motor1Axis.setter
    def motor1Axis(self, motor1Axis):
        if  motor1Axis is None:
            motor1Axis = (0, 0, 0) # default
        assertValidSFVec3f(motor1Axis)
        self.__motor1Axis = motor1Axis
    @property # getter - - - - - - - - - -
    def motor2Axis(self):
        """motor2Axis defines axis vector of corresponding motor axis."""
        return self.__motor2Axis
    @motor2Axis.setter
    def motor2Axis(self, motor2Axis):
        if  motor2Axis is None:
            motor2Axis = (0, 0, 0) # default
        assertValidSFVec3f(motor2Axis)
        self.__motor2Axis = motor2Axis
    @property # getter - - - - - - - - - -
    def motor3Axis(self):
        """motor3Axis defines axis vector of corresponding motor axis."""
        return self.__motor3Axis
    @motor3Axis.setter
    def motor3Axis(self, motor3Axis):
        if  motor3Axis is None:
            motor3Axis = (0, 0, 0) # default
        assertValidSFVec3f(motor3Axis)
        self.__motor3Axis = motor3Axis
    @property # getter - - - - - - - - - -
    def stop1Bounce(self):
        """[0,1] stop1Bounce is velocity factor for bounce back once stop point is reached."""
        return self.__stop1Bounce
    @stop1Bounce.setter
    def stop1Bounce(self, stop1Bounce):
        if  stop1Bounce is None:
            stop1Bounce = 0 # default
        assertValidSFFloat(stop1Bounce)
        self.__stop1Bounce = stop1Bounce
    @property # getter - - - - - - - - - -
    def stop1ErrorCorrection(self):
        """[0,1] stop1ErrorCorrection is fraction of error correction performed during time step once stop point is reached."""
        return self.__stop1ErrorCorrection
    @stop1ErrorCorrection.setter
    def stop1ErrorCorrection(self, stop1ErrorCorrection):
        if  stop1ErrorCorrection is None:
            stop1ErrorCorrection = 0.8 # default
        assertValidSFFloat(stop1ErrorCorrection)
        self.__stop1ErrorCorrection = stop1ErrorCorrection
    @property # getter - - - - - - - - - -
    def stop2Bounce(self):
        """[0,1] stop2Bounce is velocity factor for bounce back once stop point is reached."""
        return self.__stop2Bounce
    @stop2Bounce.setter
    def stop2Bounce(self, stop2Bounce):
        if  stop2Bounce is None:
            stop2Bounce = 0 # default
        assertValidSFFloat(stop2Bounce)
        self.__stop2Bounce = stop2Bounce
    @property # getter - - - - - - - - - -
    def stop2ErrorCorrection(self):
        """[0,1] stop2ErrorCorrection is fraction of error correction performed during time step once stop point is reached."""
        return self.__stop2ErrorCorrection
    @stop2ErrorCorrection.setter
    def stop2ErrorCorrection(self, stop2ErrorCorrection):
        if  stop2ErrorCorrection is None:
            stop2ErrorCorrection = 0.8 # default
        assertValidSFFloat(stop2ErrorCorrection)
        self.__stop2ErrorCorrection = stop2ErrorCorrection
    @property # getter - - - - - - - - - -
    def stop3Bounce(self):
        """[0,1] stop3Bounce is velocity factor for bounce back once stop point is reached."""
        return self.__stop3Bounce
    @stop3Bounce.setter
    def stop3Bounce(self, stop3Bounce):
        if  stop3Bounce is None:
            stop3Bounce = 0 # default
        assertValidSFFloat(stop3Bounce)
        self.__stop3Bounce = stop3Bounce
    @property # getter - - - - - - - - - -
    def stop3ErrorCorrection(self):
        """[0,1] stop3ErrorCorrection is fraction of error correction performed during time step once stop point is reached."""
        return self.__stop3ErrorCorrection
    @stop3ErrorCorrection.setter
    def stop3ErrorCorrection(self, stop3ErrorCorrection):
        if  stop3ErrorCorrection is None:
            stop3ErrorCorrection = 0.8 # default
        assertValidSFFloat(stop3ErrorCorrection)
        self.__stop3ErrorCorrection = stop3ErrorCorrection
    @property # getter - - - - - - - - - -
    def body1(self):
        return self.__body1
    @body1.setter
    def body1(self, body1):
        if  body1 is None:
            body1 = None # default
        assertValidSFNode(body1)
        if not isinstance(body1, object):
            # print(flush=True)
            raise X3DTypeError(str(body1) + ' does not have a valid node type object')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        return self.__body2
    @body2.setter
    def body2(self, body2):
        if  body2 is None:
            body2 = None # default
        assertValidSFNode(body2)
        if not isinstance(body2, object):
            # print(flush=True)
            raise X3DTypeError(str(body2) + ' does not have a valid node type object')
        self.__body2 = body2
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.body1 or self.body2 or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function MotorJoint.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<MotorJoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.autoCalc: # default=false
            result += " autoCalc='" + SFBool(self.autoCalc).XML() + "'"
        if self.axis1Angle != 0:
            result += " axis1Angle='" + SFFloat(self.axis1Angle).XML() + "'"
        if self.axis1Torque != 0:
            result += " axis1Torque='" + SFFloat(self.axis1Torque).XML() + "'"
        if self.axis2Angle != 0:
            result += " axis2Angle='" + SFFloat(self.axis2Angle).XML() + "'"
        if self.axis2Torque != 0:
            result += " axis2Torque='" + SFFloat(self.axis2Torque).XML() + "'"
        if self.axis3Angle != 0:
            result += " axis3Angle='" + SFFloat(self.axis3Angle).XML() + "'"
        if self.axis3Torque != 0:
            result += " axis3Torque='" + SFFloat(self.axis3Torque).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.enabledAxes != 1:
            result += " enabledAxes='" + SFInt32(self.enabledAxes).XML() + "'"
        if self.forceOutput != ["NONE"]:
            result += " forceOutput='" + MFString(self.forceOutput).XML() + "'"
        if self.motor1Axis != (0, 0, 0):
            result += " motor1Axis='" + SFVec3f(self.motor1Axis).XML() + "'"
        if self.motor2Axis != (0, 0, 0):
            result += " motor2Axis='" + SFVec3f(self.motor2Axis).XML() + "'"
        if self.motor3Axis != (0, 0, 0):
            result += " motor3Axis='" + SFVec3f(self.motor3Axis).XML() + "'"
        if self.stop1Bounce != 0:
            result += " stop1Bounce='" + SFFloat(self.stop1Bounce).XML() + "'"
        if self.stop1ErrorCorrection != 0.8:
            result += " stop1ErrorCorrection='" + SFFloat(self.stop1ErrorCorrection).XML() + "'"
        if self.stop2Bounce != 0:
            result += " stop2Bounce='" + SFFloat(self.stop2Bounce).XML() + "'"
        if self.stop2ErrorCorrection != 0.8:
            result += " stop2ErrorCorrection='" + SFFloat(self.stop2ErrorCorrection).XML() + "'"
        if self.stop3Bounce != 0:
            result += " stop3Bounce='" + SFFloat(self.stop3Bounce).XML() + "'"
        if self.stop3ErrorCorrection != 0.8:
            result += " stop3ErrorCorrection='" + SFFloat(self.stop3ErrorCorrection).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></MotorJoint>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.body1: # output this SFNode
                result += self.body1.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.body2: # output this SFNode
                result += self.body2.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</MotorJoint>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function MotorJoint.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'MotorJoint' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'MotorJoint' + ' {'
        if self.autoCalc: # default=false
            result += " autoCalc " + SFBool(self.autoCalc).VRML() + ""
        if self.axis1Angle != 0:
            result += " axis1Angle " + SFFloat(self.axis1Angle).VRML() + ""
        if self.axis1Torque != 0:
            result += " axis1Torque " + SFFloat(self.axis1Torque).VRML() + ""
        if self.axis2Angle != 0:
            result += " axis2Angle " + SFFloat(self.axis2Angle).VRML() + ""
        if self.axis2Torque != 0:
            result += " axis2Torque " + SFFloat(self.axis2Torque).VRML() + ""
        if self.axis3Angle != 0:
            result += " axis3Angle " + SFFloat(self.axis3Angle).VRML() + ""
        if self.axis3Torque != 0:
            result += " axis3Torque " + SFFloat(self.axis3Torque).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.enabledAxes != 1:
            result += " enabledAxes " + SFInt32(self.enabledAxes).VRML() + ""
        if self.forceOutput != ["NONE"]:
            result += " forceOutput " + MFString(self.forceOutput).VRML() + ""
        if self.motor1Axis != (0, 0, 0):
            result += " motor1Axis " + SFVec3f(self.motor1Axis).VRML() + ""
        if self.motor2Axis != (0, 0, 0):
            result += " motor2Axis " + SFVec3f(self.motor2Axis).VRML() + ""
        if self.motor3Axis != (0, 0, 0):
            result += " motor3Axis " + SFVec3f(self.motor3Axis).VRML() + ""
        if self.stop1Bounce != 0:
            result += " stop1Bounce " + SFFloat(self.stop1Bounce).VRML() + ""
        if self.stop1ErrorCorrection != 0.8:
            result += " stop1ErrorCorrection " + SFFloat(self.stop1ErrorCorrection).VRML() + ""
        if self.stop2Bounce != 0:
            result += " stop2Bounce " + SFFloat(self.stop2Bounce).VRML() + ""
        if self.stop2ErrorCorrection != 0.8:
            result += " stop2ErrorCorrection " + SFFloat(self.stop2ErrorCorrection).VRML() + ""
        if self.stop3Bounce != 0:
            result += " stop3Bounce " + SFFloat(self.stop3Bounce).VRML() + ""
        if self.stop3ErrorCorrection != 0.8:
            result += " stop3ErrorCorrection " + SFFloat(self.stop3ErrorCorrection).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.body1: # output this SFNode
            result += '\n' + '  ' + indent + 'body1 ' + self.body1.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.body2: # output this SFNode
            result += '\n' + '  ' + indent + 'body2 ' + self.body2.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class MovieTexture(_X3DSoundSourceNode, _X3DTexture2DNode, _X3DUrlObject):
    """
    MovieTexture applies a 2D movie image to surface geometry, or provides audio for a Sound node.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'MovieTexture'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texturing.html#MovieTexture'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MovieTexture'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundSourceNode'),
            ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundSourceNode'),
            ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
            ('loop', False, FieldType.SFBool, AccessType.inputOutput, 'MovieTexture'),
            ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('pitch', 1.0, FieldType.SFFloat, AccessType.inputOutput, 'MovieTexture'),
            ('refresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
            ('repeatS', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture2DNode'),
            ('repeatT', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture2DNode'),
            ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('speed', 1.0, FieldType.SFFloat, AccessType.inputOutput, 'MovieTexture'),
            ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('url', list(), FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
            ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly, 'MovieTexture'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 enabled=True,
                 gain=1,
                 load=True,
                 loop=False,
                 pauseTime=0,
                 pitch=1.0,
                 refresh=0,
                 repeatS=True,
                 repeatT=True,
                 resumeTime=0,
                 speed=1.0,
                 startTime=0,
                 stopTime=0,
                 url=list(),
                 textureProperties=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MovieTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.load = load
        self.loop = loop
        self.pauseTime = pauseTime
        self.pitch = pitch
        self.refresh = refresh
        self.repeatS = repeatS
        self.repeatT = repeatT
        self.resumeTime = resumeTime
        self.speed = speed
        self.startTime = startTime
        self.stopTime = stopTime
        self.url = url
        self.textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1 # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def loop(self):
        """Repeat indefinitely when loop=true, repeat only once when loop=false."""
        return self.__loop
    @loop.setter
    def loop(self, loop):
        if  loop is None:
            loop = False # default
        assertValidSFBool(loop)
        self.__loop = loop
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and MovieTexture becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0 # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def pitch(self):
        return self.__pitch
    @pitch.setter
    def pitch(self, pitch):
        if  pitch is None:
            pitch = 1.0 # default
        assertValidSFFloat(pitch)
        assertPositive('pitch', pitch)
        self.__pitch = pitch
    @property # getter - - - - - - - - - -
    def refresh(self):
        """refresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__refresh
    @refresh.setter
    def refresh(self, refresh):
        if  refresh is None:
            refresh = 0 # default
        assertValidSFTime(refresh)
        assertNonNegative('refresh', refresh)
        self.__refresh = refresh
    @property # getter - - - - - - - - - -
    def repeatS(self):
        """Whether to horizontally repeat texture along S axis."""
        return self.__repeatS
    @repeatS.setter
    def repeatS(self, repeatS):
        if  repeatS is None:
            repeatS = True # default
        assertValidSFBool(repeatS)
        self.__repeatS = repeatS
    @property # getter - - - - - - - - - -
    def repeatT(self):
        """Whether to vertically repeat texture along T axis."""
        return self.__repeatT
    @repeatT.setter
    def repeatT(self, repeatT):
        if  repeatT is None:
            repeatT = True # default
        assertValidSFBool(repeatT)
        self.__repeatT = repeatT
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and MovieTexture becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0 # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def speed(self):
        """Factor for how fast the movie (or soundtrack) is played."""
        return self.__speed
    @speed.setter
    def speed(self, speed):
        if  speed is None:
            speed = 1.0 # default
        assertValidSFFloat(speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0 # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0 # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def url(self):
        """Location and filename of movie file or stream."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE(self)
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties):
        if  textureProperties is None:
            textureProperties = None # default
        assertValidSFNode(textureProperties)
        if not isinstance(textureProperties, object):
            # print(flush=True)
            raise X3DTypeError(str(textureProperties) + ' does not have a valid node type object')
        self.__textureProperties = textureProperties
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.textureProperties
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function MovieTexture.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<MovieTexture'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.gain != 1:
            result += " gain='" + SFFloat(self.gain).XML() + "'"
        if not self.load: # default=true
            result += " load='" + SFBool(self.load).XML() + "'"
        if self.loop: # default=false
            result += " loop='" + SFBool(self.loop).XML() + "'"
        if self.pauseTime != 0:
            result += " pauseTime='" + SFTime(self.pauseTime).XML() + "'"
        if self.pitch != 1.0:
            result += " pitch='" + SFFloat(self.pitch).XML() + "'"
        if self.refresh != 0:
            result += " refresh='" + SFTime(self.refresh).XML() + "'"
        if not self.repeatS: # default=true
            result += " repeatS='" + SFBool(self.repeatS).XML() + "'"
        if not self.repeatT: # default=true
            result += " repeatT='" + SFBool(self.repeatT).XML() + "'"
        if self.resumeTime != 0:
            result += " resumeTime='" + SFTime(self.resumeTime).XML() + "'"
        if self.speed != 1.0:
            result += " speed='" + SFFloat(self.speed).XML() + "'"
        if self.startTime != 0:
            result += " startTime='" + SFTime(self.startTime).XML() + "'"
        if self.stopTime != 0:
            result += " stopTime='" + SFTime(self.stopTime).XML() + "'"
        if self.url != list():
            result += " url='" + MFString(self.url).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></MovieTexture>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.textureProperties: # output this SFNode
                result += self.textureProperties.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</MovieTexture>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function MovieTexture.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'MovieTexture' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'MovieTexture' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.gain != 1:
            result += " gain " + SFFloat(self.gain).VRML() + ""
        if not self.load: # default=true
            result += " load " + SFBool(self.load).VRML() + ""
        if self.loop: # default=false
            result += " loop " + SFBool(self.loop).VRML() + ""
        if self.pauseTime != 0:
            result += " pauseTime " + SFTime(self.pauseTime).VRML() + ""
        if self.pitch != 1.0:
            result += " pitch " + SFFloat(self.pitch).VRML() + ""
        if self.refresh != 0:
            result += " refresh " + SFTime(self.refresh).VRML() + ""
        if not self.repeatS: # default=true
            result += " repeatS " + SFBool(self.repeatS).VRML() + ""
        if not self.repeatT: # default=true
            result += " repeatT " + SFBool(self.repeatT).VRML() + ""
        if self.resumeTime != 0:
            result += " resumeTime " + SFTime(self.resumeTime).VRML() + ""
        if self.speed != 1.0:
            result += " speed " + SFFloat(self.speed).VRML() + ""
        if self.startTime != 0:
            result += " startTime " + SFTime(self.startTime).VRML() + ""
        if self.stopTime != 0:
            result += " stopTime " + SFTime(self.stopTime).VRML() + ""
        if self.url != list():
            result += " url " + MFString(self.url).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.textureProperties: # output this SFNode
            result += '\n' + '  ' + indent + 'textureProperties ' + self.textureProperties.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class MultiTexture(_X3DTextureNode):
    """
    MultiTexture applies several individual textures to a single geometry node, enabling a variety of visual effects that include light mapping and environment mapping.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'MultiTexture'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texturing.html#MultiTexture'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MultiTexture'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('alpha', 1, FieldType.SFFloat, AccessType.inputOutput, 'MultiTexture'),
            ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'MultiTexture'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureNode'),
            ('function', list(), FieldType.MFString, AccessType.inputOutput, 'MultiTexture'),
            ('mode', list(), FieldType.MFString, AccessType.inputOutput, 'MultiTexture'),
            ('source', list(), FieldType.MFString, AccessType.inputOutput, 'MultiTexture'),
            ('texture', list(), FieldType.MFNode, AccessType.inputOutput, 'MultiTexture'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 alpha=1,
                 color=(1, 1, 1),
                 description='',
                 function=list(),
                 mode=list(),
                 source=list(),
                 texture=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MultiTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.alpha = alpha
        self.color = color
        self.description = description
        self.function = function
        self.mode = mode
        self.source = source
        self.texture = texture
    @property # getter - - - - - - - - - -
    def alpha(self):
        """[0,1] The alpha field defines the alpha (1-transparency) base value for mode operations."""
        return self.__alpha
    @alpha.setter
    def alpha(self, alpha):
        if  alpha is None:
            alpha = 1 # default
        assertValidSFFloat(alpha)
        assertZeroToOne('alpha', alpha)
        self.__alpha = alpha
    @property # getter - - - - - - - - - -
    def color(self):
        """[0,1] The color field defines the RGB base values for mode operations."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = (1, 1, 1) # default
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def function(self):
        """function operators COMPLEMENT or ALPHAREPLICATE can be applied after the mode blending operation."""
        return self.__function
    @function.setter
    def function(self, function):
        if  function is None:
            function = MFString.DEFAULT_VALUE(self)
        assertValidMFString(function)
        self.__function = function
    @property # getter - - - - - - - - - -
    def mode(self):
        """mode field indicates the type of blending operation, both for color and for alpha channel."""
        return self.__mode
    @mode.setter
    def mode(self, mode):
        if  mode is None:
            mode = MFString.DEFAULT_VALUE(self)
        assertValidMFString(mode)
        self.__mode = mode
    @property # getter - - - - - - - - - -
    def source(self):
        """source field determines whether each image source is treated as DIFFUSE, SPECULAR or a multiplicative FACTOR."""
        return self.__source
    @source.setter
    def source(self, source):
        if  source is None:
            source = MFString.DEFAULT_VALUE(self)
        assertValidMFString(source)
        self.__source = source
    @property # getter - - - - - - - - - -
    def texture(self):
        """[X3DSingleTextureNode] Contained texture nodes (ImageTexture, MovieTexture, PixelTexture) that map image(s) to surface geometry, defining each of the different texture channels."""
        return self.__texture
    @texture.setter
    def texture(self, texture):
        if  texture is None:
            texture = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(texture)
        self.__texture = texture
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.texture or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function MultiTexture.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<MultiTexture'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.alpha != 1:
            result += " alpha='" + SFFloat(self.alpha).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.color != (1, 1, 1):
            result += " color='" + SFColor(self.color).XML() + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.function != list():
            result += " function='" + MFString(self.function).XML() + "'"
        if self.mode != list():
            result += " mode='" + MFString(self.mode).XML() + "'"
        if self.source != list():
            result += " source='" + MFString(self.source).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></MultiTexture>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.texture: # walk each child in MFNode list, if any
            ### print('* MultiTexture found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(texture)=' + str(len(self.texture)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.texture:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</MultiTexture>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function MultiTexture.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'MultiTexture' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'MultiTexture' + ' {'
        if self.alpha != 1:
            result += " alpha " + SFFloat(self.alpha).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.color != (1, 1, 1):
            result += " color " + SFColor(self.color).VRML() + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.function != list():
            result += " function " + MFString(self.function).VRML() + ""
        if self.mode != list():
            result += " mode " + MFString(self.mode).VRML() + ""
        if self.source != list():
            result += " source " + MFString(self.source).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texture: # walk each child in MFNode list, if any
            for each in self.texture:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class MultiTextureCoordinate(_X3DTextureCoordinateNode):
    """
    MultiTextureCoordinate contains multiple TextureCoordinate or TextureCoordinateGenerator nodes, for use by a parent polygonal geometry node such as IndexedFaceSet or a Triangle* node.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'MultiTextureCoordinate'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texturing.html#MultiTextureCoordinate'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MultiTextureCoordinate'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('texCoord', list(), FieldType.MFNode, AccessType.inputOutput, 'MultiTextureCoordinate'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 texCoord=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MultiTextureCoordinate __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.texCoord = texCoord
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DSingleTextureCoordinateNode] Zero or more contained TextureCoordinate or TextureCoordinateGenerator nodes that specify texture coordinates for the different texture channels, used for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(texCoord)
        self.__texCoord = texCoord
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.texCoord or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function MultiTextureCoordinate.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<MultiTextureCoordinate'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></MultiTextureCoordinate>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.texCoord: # walk each child in MFNode list, if any
            ### print('* MultiTextureCoordinate found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(texCoord)=' + str(len(self.texCoord)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.texCoord:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</MultiTextureCoordinate>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function MultiTextureCoordinate.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'MultiTextureCoordinate' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'MultiTextureCoordinate' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texCoord: # walk each child in MFNode list, if any
            for each in self.texCoord:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class MultiTextureTransform(_X3DTextureTransformNode):
    """
    MultiTextureTransform contains multiple TextureTransform nodes, each provided for use by corresponding ImageTexture MovieTexture or PixelTexture nodes within a sibling MultiTexture node.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'MultiTextureTransform'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texturing.html#MultiTextureTransform'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#MultiTextureTransform'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('textureTransform', list(), FieldType.MFNode, AccessType.inputOutput, 'MultiTextureTransform'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 textureTransform=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode MultiTextureTransform __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.textureTransform = textureTransform
    @property # getter - - - - - - - - - -
    def textureTransform(self):
        """[X3DSingleTextureTransformNode] Zero or more contained TextureTransform nodes, for each of the different texture channels, that define 2D transformation applied to texture coordinates."""
        return self.__textureTransform
    @textureTransform.setter
    def textureTransform(self, textureTransform):
        if  textureTransform is None:
            textureTransform = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(textureTransform)
        self.__textureTransform = textureTransform
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.textureTransform or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function MultiTextureTransform.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<MultiTextureTransform'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></MultiTextureTransform>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.textureTransform: # walk each child in MFNode list, if any
            ### print('* MultiTextureTransform found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(textureTransform)=' + str(len(self.textureTransform)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.textureTransform:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</MultiTextureTransform>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function MultiTextureTransform.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'MultiTextureTransform' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'MultiTextureTransform' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.textureTransform: # walk each child in MFNode list, if any
            for each in self.textureTransform:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class NavigationInfo(_X3DBindableNode):
    """
    NavigationInfo describes the user's viewing model, user navigation-interaction modalities, and also dimensional characteristics of the user's (typically invisible) avatar.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'NavigationInfo'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/navigation.html#NavigationInfo'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NavigationInfo'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('avatarSize', [0.25, 1.6, 0.75], FieldType.MFFloat, AccessType.inputOutput, 'NavigationInfo'),
            ('headlight', True, FieldType.SFBool, AccessType.inputOutput, 'NavigationInfo'),
            ('speed', 1, FieldType.SFFloat, AccessType.inputOutput, 'NavigationInfo'),
            ('transitionTime', 1.0, FieldType.SFTime, AccessType.inputOutput, 'NavigationInfo'),
            ('transitionType', ["LINEAR"], FieldType.MFString, AccessType.inputOutput, 'NavigationInfo'),
            ('type', ["EXAMINE", "ANY"], FieldType.MFString, AccessType.inputOutput, 'NavigationInfo'),
            ('visibilityLimit', 0, FieldType.SFFloat, AccessType.inputOutput, 'NavigationInfo'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 avatarSize=[0.25, 1.6, 0.75],
                 headlight=True,
                 speed=1,
                 transitionTime=1.0,
                 transitionType=["LINEAR"],
                 type=["EXAMINE", "ANY"],
                 visibilityLimit=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NavigationInfo __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.avatarSize = avatarSize
        self.headlight = headlight
        self.speed = speed
        self.transitionTime = transitionTime
        self.transitionType = transitionType
        self.type = type
        self.visibilityLimit = visibilityLimit
    @property # getter - - - - - - - - - -
    def avatarSize(self):
        """avatarSize triplet values define three separate parameters: (a) collisionDistance between user and geometry, i."""
        return self.__avatarSize
    @avatarSize.setter
    def avatarSize(self, avatarSize):
        if  avatarSize is None:
            avatarSize = [0.25, 1.6, 0.75] # default
        assertValidMFFloat(avatarSize)
        assertNonNegative('avatarSize', avatarSize)
        self.__avatarSize = avatarSize
    @property # getter - - - - - - - - - -
    def headlight(self):
        """Enable/disable directional light that always points in the direction the user is looking."""
        return self.__headlight
    @headlight.setter
    def headlight(self, headlight):
        if  headlight is None:
            headlight = True # default
        assertValidSFBool(headlight)
        self.__headlight = headlight
    @property # getter - - - - - - - - - -
    def speed(self):
        """[0,+infinity) Default rate at which viewer travels through scene, meters/second."""
        return self.__speed
    @speed.setter
    def speed(self, speed):
        if  speed is None:
            speed = 1 # default
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def transitionTime(self):
        """transitionTime defines the expected duration of viewpoint transition in seconds."""
        return self.__transitionTime
    @transitionTime.setter
    def transitionTime(self, transitionTime):
        if  transitionTime is None:
            transitionTime = 1.0 # default
        assertValidSFTime(transitionTime)
        assertNonNegative('transitionTime', transitionTime)
        self.__transitionTime = transitionTime
    @property # getter - - - - - - - - - -
    def transitionType(self):
        """Camera transition between viewpoints."""
        return self.__transitionType
    @transitionType.setter
    def transitionType(self, transitionType):
        if  transitionType is None:
            transitionType = ["LINEAR"] # default
        assertValidMFString(transitionType)
        self.__transitionType = transitionType
    @property # getter - - - - - - - - - -
    def type(self):
        """Enter one or more quoted SFString values: "EXAMINE" "WALK" "FLY" "LOOKAT" "EXPLORE" "ANY" "NONE"."""
        return self.__type
    @type.setter
    def type(self, type):
        if  type is None:
            type = ["EXAMINE", "ANY"] # default
        assertValidMFString(type)
        self.__type = type
    @property # getter - - - - - - - - - -
    def visibilityLimit(self):
        """Geometry beyond the visibilityLimit may not be rendered (far clipping plane of the view frustrum)."""
        return self.__visibilityLimit
    @visibilityLimit.setter
    def visibilityLimit(self, visibilityLimit):
        if  visibilityLimit is None:
            visibilityLimit = 0 # default
        assertValidSFFloat(visibilityLimit)
        assertNonNegative('visibilityLimit', visibilityLimit)
        self.__visibilityLimit = visibilityLimit
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function NavigationInfo.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<NavigationInfo'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.avatarSize != [0.25, 1.6, 0.75]:
            result += " avatarSize='" + MFFloat(self.avatarSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.headlight: # default=true
            result += " headlight='" + SFBool(self.headlight).XML() + "'"
        if self.speed != 1:
            result += " speed='" + SFFloat(self.speed).XML() + "'"
        if self.transitionTime != 1.0:
            result += " transitionTime='" + SFTime(self.transitionTime).XML() + "'"
        if self.transitionType != ["LINEAR"]:
            result += " transitionType='" + MFString(self.transitionType).XML() + "'"
        if self.type != ["EXAMINE", "ANY"]:
            result += " type='" + MFString(self.type).XML() + "'"
        if self.visibilityLimit != 0:
            result += " visibilityLimit='" + SFFloat(self.visibilityLimit).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></NavigationInfo>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</NavigationInfo>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function NavigationInfo.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'NavigationInfo' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'NavigationInfo' + ' {'
        if self.avatarSize != [0.25, 1.6, 0.75]:
            result += " avatarSize " + MFFloat(self.avatarSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.headlight: # default=true
            result += " headlight " + SFBool(self.headlight).VRML() + ""
        if self.speed != 1:
            result += " speed " + SFFloat(self.speed).VRML() + ""
        if self.transitionTime != 1.0:
            result += " transitionTime " + SFTime(self.transitionTime).VRML() + ""
        if self.transitionType != ["LINEAR"]:
            result += " transitionType " + MFString(self.transitionType).VRML() + ""
        if self.type != ["EXAMINE", "ANY"]:
            result += " type " + MFString(self.type).VRML() + ""
        if self.visibilityLimit != 0:
            result += " visibilityLimit " + SFFloat(self.visibilityLimit).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Normal(_X3DNormalNode):
    """
    Normal defines a set of 3D surface-normal vectors that apply either to a sibling Coordinate|CoordinateDouble node, or else to a parent ElevationGrid node.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Normal'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#Normal'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Normal'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('vector', list(), FieldType.MFVec3f, AccessType.inputOutput, 'Normal'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 vector=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Normal __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.vector = vector
    @property # getter - - - - - - - - - -
    def vector(self):
        """set of unit-length normal vectors, corresponding to indexed polygons or vertices."""
        return self.__vector
    @vector.setter
    def vector(self, vector):
        if  vector is None:
            vector = MFVec3f.DEFAULT_VALUE(self)
        assertValidMFVec3f(vector)
        assertGreaterThanEquals('vector', vector, -1)
        assertLessThanEquals('vector', vector, 1)
        self.__vector = vector
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Normal.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Normal'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.vector != list():
            result += " vector='" + MFVec3f(self.vector).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Normal>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Normal>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Normal.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Normal' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Normal' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.vector != list():
            result += " vector " + MFVec3f(self.vector).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class NormalInterpolator(_X3DInterpolatorNode):
    """
    NormalInterpolator generates a series of normal (perpendicular) 3-tuple SFVec3f values.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'NormalInterpolator'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/interpolators.html#NormalInterpolator'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NormalInterpolator'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('key', list(), FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
            ('keyValue', list(), FieldType.MFVec3f, AccessType.inputOutput, 'NormalInterpolator'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NormalInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFVec3f.DEFAULT_VALUE(self)
        assertValidMFVec3f(keyValue)
        self.__keyValue = keyValue
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function NormalInterpolator.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<NormalInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + MFFloat(self.key).XML() + "'"
        if self.keyValue != list():
            result += " keyValue='" + MFVec3f(self.keyValue).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></NormalInterpolator>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</NormalInterpolator>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function NormalInterpolator.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'NormalInterpolator' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'NormalInterpolator' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.key != list():
            result += " key " + MFFloat(self.key).VRML() + ""
        if self.keyValue != list():
            result += " keyValue " + MFVec3f(self.keyValue).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class NurbsCurve(_X3DParametricGeometryNode):
    """
    NurbsCurve is a 3D curve analogous to NurbsPatchSurface.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'NurbsCurve'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/nurbs.html#NurbsCurve'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsCurve'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('closed', False, FieldType.SFBool, AccessType.initializeOnly, 'NurbsCurve'),
            ('knot', list(), FieldType.MFDouble, AccessType.initializeOnly, 'NurbsCurve'),
            ('order', 3, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsCurve'),
            ('tessellation', 0, FieldType.SFInt32, AccessType.inputOutput, 'NurbsCurve'),
            ('weight', list(), FieldType.MFDouble, AccessType.inputOutput, 'NurbsCurve'),
            ('controlPoint', None, FieldType.SFNode, AccessType.inputOutput, 'NurbsCurve'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 closed=False,
                 knot=list(),
                 order=3,
                 tessellation=0,
                 weight=list(),
                 controlPoint=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsCurve __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.closed = closed
        self.knot = knot
        self.order = order
        self.tessellation = tessellation
        self.weight = weight
        self.controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def closed(self):
        """Whether or not the curve is closed (i."""
        return self.__closed
    @closed.setter
    def closed(self, closed):
        if  closed is None:
            closed = False # default
        assertValidSFBool(closed)
        self.__closed = closed
    @property # getter - - - - - - - - - -
    def knot(self):
        """knot vector, where size = number of control points + order of curve."""
        return self.__knot
    @knot.setter
    def knot(self, knot):
        if  knot is None:
            knot = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(knot)
        self.__knot = knot
    @property # getter - - - - - - - - - -
    def order(self):
        """define order of surface by polynomials of degree = order-1."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3 # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 2)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tessellation(self):
        """hint for surface tessellation."""
        return self.__tessellation
    @tessellation.setter
    def tessellation(self, tessellation):
        if  tessellation is None:
            tessellation = 0 # default
        assertValidSFInt32(tessellation)
        self.__tessellation = tessellation
    @property # getter - - - - - - - - - -
    def weight(self):
        """Vector assigning relative weight value to each control point."""
        return self.__weight
    @weight.setter
    def weight(self, weight):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(weight)
        assertPositive('weight', weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint):
        if  controlPoint is None:
            controlPoint = None # default
        assertValidSFNode(controlPoint)
        if not isinstance(controlPoint, object):
            # print(flush=True)
            raise X3DTypeError(str(controlPoint) + ' does not have a valid node type object')
        self.__controlPoint = controlPoint
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.controlPoint or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function NurbsCurve.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<NurbsCurve'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.closed: # default=false
            result += " closed='" + SFBool(self.closed).XML() + "'"
        if self.knot != list():
            result += " knot='" + MFDouble(self.knot).XML() + "'"
        if self.order != 3:
            result += " order='" + SFInt32(self.order).XML() + "'"
        if self.tessellation != 0:
            result += " tessellation='" + SFInt32(self.tessellation).XML() + "'"
        if self.weight != list():
            result += " weight='" + MFDouble(self.weight).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></NurbsCurve>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.controlPoint: # output this SFNode
                result += self.controlPoint.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</NurbsCurve>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function NurbsCurve.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'NurbsCurve' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'NurbsCurve' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.closed: # default=false
            result += " closed " + SFBool(self.closed).VRML() + ""
        if self.knot != list():
            result += " knot " + MFDouble(self.knot).VRML() + ""
        if self.order != 3:
            result += " order " + SFInt32(self.order).VRML() + ""
        if self.tessellation != 0:
            result += " tessellation " + SFInt32(self.tessellation).VRML() + ""
        if self.weight != list():
            result += " weight " + MFDouble(self.weight).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.controlPoint: # output this SFNode
            result += '\n' + '  ' + indent + 'controlPoint ' + self.controlPoint.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class NurbsCurve2D(_X3DNurbsControlCurveNode):
    """
    NurbsCurve2D defines a trimming segment that is part of a trimming contour in the u-v domain of a surface.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'NurbsCurve2D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/nurbs.html#NurbsCurve2D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsCurve2D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('closed', False, FieldType.SFBool, AccessType.initializeOnly, 'NurbsCurve2D'),
            ('controlPoint', list(), FieldType.MFVec2d, AccessType.inputOutput, 'X3DNurbsControlCurveNode'),
            ('knot', list(), FieldType.MFDouble, AccessType.initializeOnly, 'NurbsCurve2D'),
            ('order', 3, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsCurve2D'),
            ('tessellation', 0, FieldType.SFInt32, AccessType.inputOutput, 'NurbsCurve2D'),
            ('weight', list(), FieldType.MFDouble, AccessType.inputOutput, 'NurbsCurve2D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 closed=False,
                 controlPoint=list(),
                 knot=list(),
                 order=3,
                 tessellation=0,
                 weight=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsCurve2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.closed = closed
        self.controlPoint = controlPoint
        self.knot = knot
        self.order = order
        self.tessellation = tessellation
        self.weight = weight
    @property # getter - - - - - - - - - -
    def closed(self):
        """Whether or not the curve is closed (i."""
        return self.__closed
    @closed.setter
    def closed(self, closed):
        if  closed is None:
            closed = False # default
        assertValidSFBool(closed)
        self.__closed = closed
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        """controlPoint defines a set of control points of dimension uDimension by vDimension, and defines a mesh where the points do not have uniform spacing."""
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint):
        if  controlPoint is None:
            controlPoint = MFVec2d.DEFAULT_VALUE(self)
        assertValidMFVec2d(controlPoint)
        self.__controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def knot(self):
        """knot vector, where size = number of control points + order of curve."""
        return self.__knot
    @knot.setter
    def knot(self, knot):
        if  knot is None:
            knot = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(knot)
        self.__knot = knot
    @property # getter - - - - - - - - - -
    def order(self):
        """define order of surface by polynomials of degree = order-1."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3 # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 2)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tessellation(self):
        """hint for surface tessellation."""
        return self.__tessellation
    @tessellation.setter
    def tessellation(self, tessellation):
        if  tessellation is None:
            tessellation = 0 # default
        assertValidSFInt32(tessellation)
        self.__tessellation = tessellation
    @property # getter - - - - - - - - - -
    def weight(self):
        """Vector assigning relative weight value to each control point."""
        return self.__weight
    @weight.setter
    def weight(self, weight):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(weight)
        assertPositive('weight', weight)
        self.__weight = weight
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function NurbsCurve2D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<NurbsCurve2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.closed: # default=false
            result += " closed='" + SFBool(self.closed).XML() + "'"
        if self.controlPoint != list():
            result += " controlPoint='" + MFVec2d(self.controlPoint).XML() + "'"
        if self.knot != list():
            result += " knot='" + MFDouble(self.knot).XML() + "'"
        if self.order != 3:
            result += " order='" + SFInt32(self.order).XML() + "'"
        if self.tessellation != 0:
            result += " tessellation='" + SFInt32(self.tessellation).XML() + "'"
        if self.weight != list():
            result += " weight='" + MFDouble(self.weight).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></NurbsCurve2D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</NurbsCurve2D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function NurbsCurve2D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'NurbsCurve2D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'NurbsCurve2D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.closed: # default=false
            result += " closed " + SFBool(self.closed).VRML() + ""
        if self.controlPoint != list():
            result += " controlPoint " + MFVec2d(self.controlPoint).VRML() + ""
        if self.knot != list():
            result += " knot " + MFDouble(self.knot).VRML() + ""
        if self.order != 3:
            result += " order " + SFInt32(self.order).VRML() + ""
        if self.tessellation != 0:
            result += " tessellation " + SFInt32(self.tessellation).VRML() + ""
        if self.weight != list():
            result += " weight " + MFDouble(self.weight).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class NurbsOrientationInterpolator(_X3DChildNode):
    """
    NurbsOrientationInterpolator describes a 3D NURBS curve and outputs interpolated orientation values.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'NurbsOrientationInterpolator'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/nurbs.html#NurbsOrientationInterpolator'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsOrientationInterpolator'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('knot', list(), FieldType.MFDouble, AccessType.initializeOnly, 'NurbsOrientationInterpolator'),
            ('order', 3, FieldType.SFInt32, AccessType.inputOutput, 'NurbsOrientationInterpolator'),
            ('weight', list(), FieldType.MFDouble, AccessType.inputOutput, 'NurbsOrientationInterpolator'),
            ('controlPoint', None, FieldType.SFNode, AccessType.inputOutput, 'NurbsOrientationInterpolator'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 knot=list(),
                 order=3,
                 weight=list(),
                 controlPoint=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsOrientationInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.knot = knot
        self.order = order
        self.weight = weight
        self.controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def knot(self):
        """knot vector, where size = number of control points + order of curve."""
        return self.__knot
    @knot.setter
    def knot(self, knot):
        if  knot is None:
            knot = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(knot)
        self.__knot = knot
    @property # getter - - - - - - - - - -
    def order(self):
        """define order of surface by polynomials of degree = order-1."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3 # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 2)
        self.__order = order
    @property # getter - - - - - - - - - -
    def weight(self):
        """Output values for computational interpolation, each corresponding to knots."""
        return self.__weight
    @weight.setter
    def weight(self, weight):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that specifies control points for NURBS geometry definitions."""
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint):
        if  controlPoint is None:
            controlPoint = None # default
        assertValidSFNode(controlPoint)
        if not isinstance(controlPoint, object):
            # print(flush=True)
            raise X3DTypeError(str(controlPoint) + ' does not have a valid node type object')
        self.__controlPoint = controlPoint
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.controlPoint or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function NurbsOrientationInterpolator.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<NurbsOrientationInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.knot != list():
            result += " knot='" + MFDouble(self.knot).XML() + "'"
        if self.order != 3:
            result += " order='" + SFInt32(self.order).XML() + "'"
        if self.weight != list():
            result += " weight='" + MFDouble(self.weight).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></NurbsOrientationInterpolator>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.controlPoint: # output this SFNode
                result += self.controlPoint.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</NurbsOrientationInterpolator>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function NurbsOrientationInterpolator.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'NurbsOrientationInterpolator' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'NurbsOrientationInterpolator' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.knot != list():
            result += " knot " + MFDouble(self.knot).VRML() + ""
        if self.order != 3:
            result += " order " + SFInt32(self.order).VRML() + ""
        if self.weight != list():
            result += " weight " + MFDouble(self.weight).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.controlPoint: # output this SFNode
            result += '\n' + '  ' + indent + 'controlPoint ' + self.controlPoint.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class NurbsPatchSurface(_X3DNurbsSurfaceGeometryNode):
    """
    NurbsPatchSurface defines a contiguous 3D Non-Uniform Rational B-Spline (NURBS) surface.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'NurbsPatchSurface'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/nurbs.html#NurbsPatchSurface'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsPatchSurface'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
            ('uClosed', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
            ('uDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
            ('uKnot', list(), FieldType.MFDouble, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
            ('uOrder', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
            ('uTessellation', 0, FieldType.SFInt32, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
            ('vClosed', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
            ('vDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
            ('vKnot', list(), FieldType.MFDouble, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
            ('vOrder', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
            ('vTessellation', 0, FieldType.SFInt32, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
            ('weight', list(), FieldType.MFDouble, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
            ('controlPoint', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
            ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 solid=True,
                 uClosed=False,
                 uDimension=0,
                 uKnot=list(),
                 uOrder=3,
                 uTessellation=0,
                 vClosed=False,
                 vDimension=0,
                 vKnot=list(),
                 vOrder=3,
                 vTessellation=0,
                 weight=list(),
                 controlPoint=None,
                 texCoord=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsPatchSurface __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.solid = solid
        self.uClosed = uClosed
        self.uDimension = uDimension
        self.uKnot = uKnot
        self.uOrder = uOrder
        self.uTessellation = uTessellation
        self.vClosed = vClosed
        self.vDimension = vDimension
        self.vKnot = vKnot
        self.vOrder = vOrder
        self.vTessellation = vTessellation
        self.weight = weight
        self.controlPoint = controlPoint
        self.texCoord = texCoord
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def uClosed(self):
        """Whether opposite surface sides are closed (seamless) across u dimension."""
        return self.__uClosed
    @uClosed.setter
    def uClosed(self, uClosed):
        if  uClosed is None:
            uClosed = False # default
        assertValidSFBool(uClosed)
        self.__uClosed = uClosed
    @property # getter - - - - - - - - - -
    def uDimension(self):
        """Number of control points in u dimension."""
        return self.__uDimension
    @uDimension.setter
    def uDimension(self, uDimension):
        if  uDimension is None:
            uDimension = 0 # default
        assertValidSFInt32(uDimension)
        assertNonNegative('uDimension', uDimension)
        self.__uDimension = uDimension
    @property # getter - - - - - - - - - -
    def uKnot(self):
        """knot vector, where size = number of control points + order of curve."""
        return self.__uKnot
    @uKnot.setter
    def uKnot(self, uKnot):
        if  uKnot is None:
            uKnot = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(uKnot)
        self.__uKnot = uKnot
    @property # getter - - - - - - - - - -
    def uOrder(self):
        """define order of surface by polynomials of degree = order-1."""
        return self.__uOrder
    @uOrder.setter
    def uOrder(self, uOrder):
        if  uOrder is None:
            uOrder = 3 # default
        assertValidSFInt32(uOrder)
        assertGreaterThanEquals('uOrder', uOrder, 2)
        self.__uOrder = uOrder
    @property # getter - - - - - - - - - -
    def uTessellation(self):
        """hint for surface tessellation."""
        return self.__uTessellation
    @uTessellation.setter
    def uTessellation(self, uTessellation):
        if  uTessellation is None:
            uTessellation = 0 # default
        assertValidSFInt32(uTessellation)
        self.__uTessellation = uTessellation
    @property # getter - - - - - - - - - -
    def vClosed(self):
        """Whether opposite surface sides are closed (seamless) across u dimension."""
        return self.__vClosed
    @vClosed.setter
    def vClosed(self, vClosed):
        if  vClosed is None:
            vClosed = False # default
        assertValidSFBool(vClosed)
        self.__vClosed = vClosed
    @property # getter - - - - - - - - - -
    def vDimension(self):
        """Number of control points in v dimension."""
        return self.__vDimension
    @vDimension.setter
    def vDimension(self, vDimension):
        if  vDimension is None:
            vDimension = 0 # default
        assertValidSFInt32(vDimension)
        assertNonNegative('vDimension', vDimension)
        self.__vDimension = vDimension
    @property # getter - - - - - - - - - -
    def vKnot(self):
        """knot vector, where size = number of control points + order of curve."""
        return self.__vKnot
    @vKnot.setter
    def vKnot(self, vKnot):
        if  vKnot is None:
            vKnot = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(vKnot)
        self.__vKnot = vKnot
    @property # getter - - - - - - - - - -
    def vOrder(self):
        """define order of surface by polynomials of degree = order-1."""
        return self.__vOrder
    @vOrder.setter
    def vOrder(self, vOrder):
        if  vOrder is None:
            vOrder = 3 # default
        assertValidSFInt32(vOrder)
        assertGreaterThanEquals('vOrder', vOrder, 2)
        self.__vOrder = vOrder
    @property # getter - - - - - - - - - -
    def vTessellation(self):
        """hint for surface tessellation."""
        return self.__vTessellation
    @vTessellation.setter
    def vTessellation(self, vTessellation):
        if  vTessellation is None:
            vTessellation = 0 # default
        assertValidSFInt32(vTessellation)
        self.__vTessellation = vTessellation
    @property # getter - - - - - - - - - -
    def weight(self):
        """Vector assigning relative weight value to each control point."""
        return self.__weight
    @weight.setter
    def weight(self, weight):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(weight)
        assertPositive('weight', weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that specifies control points for NURBS geometry definitions."""
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint):
        if  controlPoint is None:
            controlPoint = None # default
        assertValidSFNode(controlPoint)
        if not isinstance(controlPoint, object):
            # print(flush=True)
            raise X3DTypeError(str(controlPoint) + ' does not have a valid node type object')
        self.__controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode|NurbsTextureCoordinate] Single contained NurbsTextureCoordinate, TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that specifies coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None # default
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.controlPoint or self.IS or self.metadata or self.texCoord
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function NurbsPatchSurface.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<NurbsPatchSurface'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if self.uClosed: # default=false
            result += " uClosed='" + SFBool(self.uClosed).XML() + "'"
        if self.uDimension != 0:
            result += " uDimension='" + SFInt32(self.uDimension).XML() + "'"
        if self.uKnot != list():
            result += " uKnot='" + MFDouble(self.uKnot).XML() + "'"
        if self.uOrder != 3:
            result += " uOrder='" + SFInt32(self.uOrder).XML() + "'"
        if self.uTessellation != 0:
            result += " uTessellation='" + SFInt32(self.uTessellation).XML() + "'"
        if self.vClosed: # default=false
            result += " vClosed='" + SFBool(self.vClosed).XML() + "'"
        if self.vDimension != 0:
            result += " vDimension='" + SFInt32(self.vDimension).XML() + "'"
        if self.vKnot != list():
            result += " vKnot='" + MFDouble(self.vKnot).XML() + "'"
        if self.vOrder != 3:
            result += " vOrder='" + SFInt32(self.vOrder).XML() + "'"
        if self.vTessellation != 0:
            result += " vTessellation='" + SFInt32(self.vTessellation).XML() + "'"
        if self.weight != list():
            result += " weight='" + MFDouble(self.weight).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></NurbsPatchSurface>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.controlPoint: # output this SFNode
                result += self.controlPoint.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.texCoord: # output this SFNode
                result += self.texCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</NurbsPatchSurface>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function NurbsPatchSurface.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'NurbsPatchSurface' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'NurbsPatchSurface' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.uClosed: # default=false
            result += " uClosed " + SFBool(self.uClosed).VRML() + ""
        if self.uDimension != 0:
            result += " uDimension " + SFInt32(self.uDimension).VRML() + ""
        if self.uKnot != list():
            result += " uKnot " + MFDouble(self.uKnot).VRML() + ""
        if self.uOrder != 3:
            result += " uOrder " + SFInt32(self.uOrder).VRML() + ""
        if self.uTessellation != 0:
            result += " uTessellation " + SFInt32(self.uTessellation).VRML() + ""
        if self.vClosed: # default=false
            result += " vClosed " + SFBool(self.vClosed).VRML() + ""
        if self.vDimension != 0:
            result += " vDimension " + SFInt32(self.vDimension).VRML() + ""
        if self.vKnot != list():
            result += " vKnot " + MFDouble(self.vKnot).VRML() + ""
        if self.vOrder != 3:
            result += " vOrder " + SFInt32(self.vOrder).VRML() + ""
        if self.vTessellation != 0:
            result += " vTessellation " + SFInt32(self.vTessellation).VRML() + ""
        if self.weight != list():
            result += " weight " + MFDouble(self.weight).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.controlPoint: # output this SFNode
            result += '\n' + '  ' + indent + 'controlPoint ' + self.controlPoint.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'texCoord ' + self.texCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class NurbsPositionInterpolator(_X3DChildNode):
    """
    NurbsPositionInterpolator describes a 3D NURBS curve and outputs interpolated position values.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'NurbsPositionInterpolator'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/nurbs.html#NurbsPositionInterpolator'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsPositionInterpolator'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('knot', list(), FieldType.MFDouble, AccessType.initializeOnly, 'NurbsPositionInterpolator'),
            ('order', 3, FieldType.SFInt32, AccessType.inputOutput, 'NurbsPositionInterpolator'),
            ('weight', list(), FieldType.MFDouble, AccessType.inputOutput, 'NurbsPositionInterpolator'),
            ('controlPoint', None, FieldType.SFNode, AccessType.inputOutput, 'NurbsPositionInterpolator'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 knot=list(),
                 order=3,
                 weight=list(),
                 controlPoint=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsPositionInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.knot = knot
        self.order = order
        self.weight = weight
        self.controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def knot(self):
        """knot vector, where size = number of control points + order of curve."""
        return self.__knot
    @knot.setter
    def knot(self, knot):
        if  knot is None:
            knot = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(knot)
        self.__knot = knot
    @property # getter - - - - - - - - - -
    def order(self):
        """define order of surface by polynomials of degree = order-1."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3 # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 2)
        self.__order = order
    @property # getter - - - - - - - - - -
    def weight(self):
        """Output values for linear interpolation, each corresponding to knots."""
        return self.__weight
    @weight.setter
    def weight(self, weight):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that specifies control points for NURBS geometry definitions."""
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint):
        if  controlPoint is None:
            controlPoint = None # default
        assertValidSFNode(controlPoint)
        if not isinstance(controlPoint, object):
            # print(flush=True)
            raise X3DTypeError(str(controlPoint) + ' does not have a valid node type object')
        self.__controlPoint = controlPoint
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.controlPoint or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function NurbsPositionInterpolator.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<NurbsPositionInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.knot != list():
            result += " knot='" + MFDouble(self.knot).XML() + "'"
        if self.order != 3:
            result += " order='" + SFInt32(self.order).XML() + "'"
        if self.weight != list():
            result += " weight='" + MFDouble(self.weight).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></NurbsPositionInterpolator>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.controlPoint: # output this SFNode
                result += self.controlPoint.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</NurbsPositionInterpolator>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function NurbsPositionInterpolator.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'NurbsPositionInterpolator' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'NurbsPositionInterpolator' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.knot != list():
            result += " knot " + MFDouble(self.knot).VRML() + ""
        if self.order != 3:
            result += " order " + SFInt32(self.order).VRML() + ""
        if self.weight != list():
            result += " weight " + MFDouble(self.weight).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.controlPoint: # output this SFNode
            result += '\n' + '  ' + indent + 'controlPoint ' + self.controlPoint.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class NurbsSet(_X3DChildNode, _X3DBoundedObject):
    """
    NurbsSet collects a set of NurbsSurface nodes into a common group and treats NurbsSurface set as a unit during tessellation, thereby enforcing tessellation continuity along borders.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'NurbsSet'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/nurbs.html#NurbsSet'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsSet'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('tessellationScale', 1.0, FieldType.SFFloat, AccessType.inputOutput, 'NurbsSet'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('geometry', list(), FieldType.MFNode, AccessType.inputOutput, 'NurbsSet'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 tessellationScale=1.0,
                 visible=True,
                 geometry=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.tessellationScale = tessellationScale
        self.visible = visible
        self.geometry = geometry
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def tessellationScale(self):
        """scale for surface tessellation in children NurbsSurface nodes."""
        return self.__tessellationScale
    @tessellationScale.setter
    def tessellationScale(self, tessellationScale):
        if  tessellationScale is None:
            tessellationScale = 1.0 # default
        assertValidSFFloat(tessellationScale)
        assertPositive('tessellationScale', tessellationScale)
        self.__tessellationScale = tessellationScale
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def geometry(self):
        """[NurbsPatchSurface|NurbsTrimmedSurface] The children form a closed loop with first point of first child repeated as last point of last child, and the last point of a segment repeated as first point of the consecutive one."""
        return self.__geometry
    @geometry.setter
    def geometry(self, geometry):
        if  geometry is None:
            geometry = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(geometry)
        self.__geometry = geometry
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.geometry or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function NurbsSet.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<NurbsSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.tessellationScale != 1.0:
            result += " tessellationScale='" + SFFloat(self.tessellationScale).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></NurbsSet>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.geometry: # walk each child in MFNode list, if any
            ### print('* NurbsSet found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(geometry)=' + str(len(self.geometry)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.geometry:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</NurbsSet>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function NurbsSet.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'NurbsSet' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'NurbsSet' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.tessellationScale != 1.0:
            result += " tessellationScale " + SFFloat(self.tessellationScale).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.geometry: # walk each child in MFNode list, if any
            for each in self.geometry:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class NurbsSurfaceInterpolator(_X3DChildNode):
    """
    NurbsSurfaceInterpolator describes a 3D NURBS curve and outputs interpolated position and normal values.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'NurbsSurfaceInterpolator'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/nurbs.html#NurbsSurfaceInterpolator'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsSurfaceInterpolator'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('uDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsSurfaceInterpolator'),
            ('uKnot', list(), FieldType.MFDouble, AccessType.initializeOnly, 'NurbsSurfaceInterpolator'),
            ('uOrder', 3, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsSurfaceInterpolator'),
            ('vDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsSurfaceInterpolator'),
            ('vKnot', list(), FieldType.MFDouble, AccessType.initializeOnly, 'NurbsSurfaceInterpolator'),
            ('vOrder', 3, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsSurfaceInterpolator'),
            ('weight', list(), FieldType.MFDouble, AccessType.inputOutput, 'NurbsSurfaceInterpolator'),
            ('controlPoint', None, FieldType.SFNode, AccessType.inputOutput, 'NurbsSurfaceInterpolator'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 uDimension=0,
                 uKnot=list(),
                 uOrder=3,
                 vDimension=0,
                 vKnot=list(),
                 vOrder=3,
                 weight=list(),
                 controlPoint=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsSurfaceInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.uDimension = uDimension
        self.uKnot = uKnot
        self.uOrder = uOrder
        self.vDimension = vDimension
        self.vKnot = vKnot
        self.vOrder = vOrder
        self.weight = weight
        self.controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def uDimension(self):
        """Number of control points in u dimension."""
        return self.__uDimension
    @uDimension.setter
    def uDimension(self, uDimension):
        if  uDimension is None:
            uDimension = 0 # default
        assertValidSFInt32(uDimension)
        assertNonNegative('uDimension', uDimension)
        self.__uDimension = uDimension
    @property # getter - - - - - - - - - -
    def uKnot(self):
        """Knot vector, where size = number of control points + order of curve."""
        return self.__uKnot
    @uKnot.setter
    def uKnot(self, uKnot):
        if  uKnot is None:
            uKnot = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(uKnot)
        self.__uKnot = uKnot
    @property # getter - - - - - - - - - -
    def uOrder(self):
        """Define order of surface by polynomials of degree = order-1."""
        return self.__uOrder
    @uOrder.setter
    def uOrder(self, uOrder):
        if  uOrder is None:
            uOrder = 3 # default
        assertValidSFInt32(uOrder)
        assertGreaterThanEquals('uOrder', uOrder, 2)
        self.__uOrder = uOrder
    @property # getter - - - - - - - - - -
    def vDimension(self):
        """Number of control points in v dimension."""
        return self.__vDimension
    @vDimension.setter
    def vDimension(self, vDimension):
        if  vDimension is None:
            vDimension = 0 # default
        assertValidSFInt32(vDimension)
        assertNonNegative('vDimension', vDimension)
        self.__vDimension = vDimension
    @property # getter - - - - - - - - - -
    def vKnot(self):
        """Knot vector, where size = number of control points + order of curve."""
        return self.__vKnot
    @vKnot.setter
    def vKnot(self, vKnot):
        if  vKnot is None:
            vKnot = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(vKnot)
        self.__vKnot = vKnot
    @property # getter - - - - - - - - - -
    def vOrder(self):
        """Define order of surface by polynomials of degree = order-1."""
        return self.__vOrder
    @vOrder.setter
    def vOrder(self, vOrder):
        if  vOrder is None:
            vOrder = 3 # default
        assertValidSFInt32(vOrder)
        assertGreaterThanEquals('vOrder', vOrder, 2)
        self.__vOrder = vOrder
    @property # getter - - - - - - - - - -
    def weight(self):
        """Output values for linear interpolation, each corresponding to knots."""
        return self.__weight
    @weight.setter
    def weight(self, weight):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that specifies control points for NURBS geometry definitions."""
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint):
        if  controlPoint is None:
            controlPoint = None # default
        assertValidSFNode(controlPoint)
        if not isinstance(controlPoint, object):
            # print(flush=True)
            raise X3DTypeError(str(controlPoint) + ' does not have a valid node type object')
        self.__controlPoint = controlPoint
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.controlPoint or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function NurbsSurfaceInterpolator.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<NurbsSurfaceInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.uDimension != 0:
            result += " uDimension='" + SFInt32(self.uDimension).XML() + "'"
        if self.uKnot != list():
            result += " uKnot='" + MFDouble(self.uKnot).XML() + "'"
        if self.uOrder != 3:
            result += " uOrder='" + SFInt32(self.uOrder).XML() + "'"
        if self.vDimension != 0:
            result += " vDimension='" + SFInt32(self.vDimension).XML() + "'"
        if self.vKnot != list():
            result += " vKnot='" + MFDouble(self.vKnot).XML() + "'"
        if self.vOrder != 3:
            result += " vOrder='" + SFInt32(self.vOrder).XML() + "'"
        if self.weight != list():
            result += " weight='" + MFDouble(self.weight).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></NurbsSurfaceInterpolator>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.controlPoint: # output this SFNode
                result += self.controlPoint.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</NurbsSurfaceInterpolator>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function NurbsSurfaceInterpolator.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'NurbsSurfaceInterpolator' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'NurbsSurfaceInterpolator' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.uDimension != 0:
            result += " uDimension " + SFInt32(self.uDimension).VRML() + ""
        if self.uKnot != list():
            result += " uKnot " + MFDouble(self.uKnot).VRML() + ""
        if self.uOrder != 3:
            result += " uOrder " + SFInt32(self.uOrder).VRML() + ""
        if self.vDimension != 0:
            result += " vDimension " + SFInt32(self.vDimension).VRML() + ""
        if self.vKnot != list():
            result += " vKnot " + MFDouble(self.vKnot).VRML() + ""
        if self.vOrder != 3:
            result += " vOrder " + SFInt32(self.vOrder).VRML() + ""
        if self.weight != list():
            result += " weight " + MFDouble(self.weight).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.controlPoint: # output this SFNode
            result += '\n' + '  ' + indent + 'controlPoint ' + self.controlPoint.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class NurbsSweptSurface(_X3DParametricGeometryNode):
    """
    NurbsSweptSurface contains a crossSectionCurve and a trajectoryCurve [NurbsCurve].
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'NurbsSweptSurface'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/nurbs.html#NurbsSweptSurface'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsSweptSurface'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'NurbsSweptSurface'),
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'NurbsSweptSurface'),
            ('crossSectionCurve', None, FieldType.SFNode, AccessType.inputOutput, 'NurbsSweptSurface'),
            ('trajectoryCurve', None, FieldType.SFNode, AccessType.inputOutput, 'NurbsSweptSurface'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ccw=True,
                 solid=True,
                 crossSectionCurve=None,
                 trajectoryCurve=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsSweptSurface __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.solid = solid
        self.crossSectionCurve = crossSectionCurve
        self.trajectoryCurve = trajectoryCurve
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def crossSectionCurve(self):
        return self.__crossSectionCurve
    @crossSectionCurve.setter
    def crossSectionCurve(self, crossSectionCurve):
        if  crossSectionCurve is None:
            crossSectionCurve = None # default
        assertValidSFNode(crossSectionCurve)
        if not isinstance(crossSectionCurve, object):
            # print(flush=True)
            raise X3DTypeError(str(crossSectionCurve) + ' does not have a valid node type object')
        self.__crossSectionCurve = crossSectionCurve
    @property # getter - - - - - - - - - -
    def trajectoryCurve(self):
        return self.__trajectoryCurve
    @trajectoryCurve.setter
    def trajectoryCurve(self, trajectoryCurve):
        if  trajectoryCurve is None:
            trajectoryCurve = None # default
        assertValidSFNode(trajectoryCurve)
        if not isinstance(trajectoryCurve, object):
            # print(flush=True)
            raise X3DTypeError(str(trajectoryCurve) + ' does not have a valid node type object')
        self.__trajectoryCurve = trajectoryCurve
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.crossSectionCurve or self.IS or self.metadata or self.trajectoryCurve
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function NurbsSweptSurface.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<NurbsSweptSurface'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.ccw: # default=true
            result += " ccw='" + SFBool(self.ccw).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></NurbsSweptSurface>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.crossSectionCurve: # output this SFNode
                result += self.crossSectionCurve.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.trajectoryCurve: # output this SFNode
                result += self.trajectoryCurve.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</NurbsSweptSurface>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function NurbsSweptSurface.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'NurbsSweptSurface' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'NurbsSweptSurface' + ' {'
        if not self.ccw: # default=true
            result += " ccw " + SFBool(self.ccw).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.crossSectionCurve: # output this SFNode
            result += '\n' + '  ' + indent + 'crossSectionCurve ' + self.crossSectionCurve.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.trajectoryCurve: # output this SFNode
            result += '\n' + '  ' + indent + 'trajectoryCurve ' + self.trajectoryCurve.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class NurbsSwungSurface(_X3DParametricGeometryNode):
    """
    NurbsSwungSurface contains a profileCurve and a trajectoryCurve [X3DNurbsControlCurveNode].
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'NurbsSwungSurface'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/nurbs.html#NurbsSwungSurface'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsSwungSurface'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'NurbsSwungSurface'),
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'NurbsSwungSurface'),
            ('profileCurve', None, FieldType.SFNode, AccessType.inputOutput, 'NurbsSwungSurface'),
            ('trajectoryCurve', None, FieldType.SFNode, AccessType.inputOutput, 'NurbsSwungSurface'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ccw=True,
                 solid=True,
                 profileCurve=None,
                 trajectoryCurve=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsSwungSurface __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.solid = solid
        self.profileCurve = profileCurve
        self.trajectoryCurve = trajectoryCurve
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def profileCurve(self):
        return self.__profileCurve
    @profileCurve.setter
    def profileCurve(self, profileCurve):
        if  profileCurve is None:
            profileCurve = None # default
        assertValidSFNode(profileCurve)
        if not isinstance(profileCurve, object):
            # print(flush=True)
            raise X3DTypeError(str(profileCurve) + ' does not have a valid node type object')
        self.__profileCurve = profileCurve
    @property # getter - - - - - - - - - -
    def trajectoryCurve(self):
        return self.__trajectoryCurve
    @trajectoryCurve.setter
    def trajectoryCurve(self, trajectoryCurve):
        if  trajectoryCurve is None:
            trajectoryCurve = None # default
        assertValidSFNode(trajectoryCurve)
        if not isinstance(trajectoryCurve, object):
            # print(flush=True)
            raise X3DTypeError(str(trajectoryCurve) + ' does not have a valid node type object')
        self.__trajectoryCurve = trajectoryCurve
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.profileCurve or self.trajectoryCurve
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function NurbsSwungSurface.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<NurbsSwungSurface'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.ccw: # default=true
            result += " ccw='" + SFBool(self.ccw).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></NurbsSwungSurface>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.profileCurve: # output this SFNode
                result += self.profileCurve.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.trajectoryCurve: # output this SFNode
                result += self.trajectoryCurve.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</NurbsSwungSurface>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function NurbsSwungSurface.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'NurbsSwungSurface' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'NurbsSwungSurface' + ' {'
        if not self.ccw: # default=true
            result += " ccw " + SFBool(self.ccw).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.profileCurve: # output this SFNode
            result += '\n' + '  ' + indent + 'profileCurve ' + self.profileCurve.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.trajectoryCurve: # output this SFNode
            result += '\n' + '  ' + indent + 'trajectoryCurve ' + self.trajectoryCurve.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class NurbsTextureCoordinate(_X3DNode):
    """
    NurbsTextureCoordinate describes a 3D NURBS surface in the parametric domain of its surface host, specifying mapping of texture onto the surface.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'NurbsTextureCoordinate'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/nurbs.html#NurbsTextureCoordinate'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsTextureCoordinate'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('controlPoint', list(), FieldType.MFVec2f, AccessType.inputOutput, 'NurbsTextureCoordinate'),
            ('uDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsTextureCoordinate'),
            ('uKnot', list(), FieldType.MFDouble, AccessType.initializeOnly, 'NurbsTextureCoordinate'),
            ('uOrder', 3, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsTextureCoordinate'),
            ('vDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsTextureCoordinate'),
            ('vKnot', list(), FieldType.MFDouble, AccessType.initializeOnly, 'NurbsTextureCoordinate'),
            ('vOrder', 3, FieldType.SFInt32, AccessType.initializeOnly, 'NurbsTextureCoordinate'),
            ('weight', list(), FieldType.MFFloat, AccessType.inputOutput, 'NurbsTextureCoordinate'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 controlPoint=list(),
                 uDimension=0,
                 uKnot=list(),
                 uOrder=3,
                 vDimension=0,
                 vKnot=list(),
                 vOrder=3,
                 weight=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsTextureCoordinate __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.controlPoint = controlPoint
        self.uDimension = uDimension
        self.uKnot = uKnot
        self.uOrder = uOrder
        self.vDimension = vDimension
        self.vKnot = vKnot
        self.vOrder = vOrder
        self.weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        """controlPoint defines a set of control points of dimension uDimension by vDimension, and defines a mesh where the points do not have uniform spacing."""
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint):
        if  controlPoint is None:
            controlPoint = MFVec2f.DEFAULT_VALUE(self)
        assertValidMFVec2f(controlPoint)
        self.__controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def uDimension(self):
        """Number of control points in u dimension."""
        return self.__uDimension
    @uDimension.setter
    def uDimension(self, uDimension):
        if  uDimension is None:
            uDimension = 0 # default
        assertValidSFInt32(uDimension)
        assertNonNegative('uDimension', uDimension)
        self.__uDimension = uDimension
    @property # getter - - - - - - - - - -
    def uKnot(self):
        """Knot vector, where size = number of control points + order of curve."""
        return self.__uKnot
    @uKnot.setter
    def uKnot(self, uKnot):
        if  uKnot is None:
            uKnot = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(uKnot)
        self.__uKnot = uKnot
    @property # getter - - - - - - - - - -
    def uOrder(self):
        """Define order of surface by polynomials of degree = order-1."""
        return self.__uOrder
    @uOrder.setter
    def uOrder(self, uOrder):
        if  uOrder is None:
            uOrder = 3 # default
        assertValidSFInt32(uOrder)
        assertGreaterThanEquals('uOrder', uOrder, 2)
        self.__uOrder = uOrder
    @property # getter - - - - - - - - - -
    def vDimension(self):
        """Number of control points in v dimension."""
        return self.__vDimension
    @vDimension.setter
    def vDimension(self, vDimension):
        if  vDimension is None:
            vDimension = 0 # default
        assertValidSFInt32(vDimension)
        assertNonNegative('vDimension', vDimension)
        self.__vDimension = vDimension
    @property # getter - - - - - - - - - -
    def vKnot(self):
        """Knot vector, where size = number of control points + order of curve."""
        return self.__vKnot
    @vKnot.setter
    def vKnot(self, vKnot):
        if  vKnot is None:
            vKnot = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(vKnot)
        self.__vKnot = vKnot
    @property # getter - - - - - - - - - -
    def vOrder(self):
        """Define order of surface by polynomials of degree = order-1."""
        return self.__vOrder
    @vOrder.setter
    def vOrder(self, vOrder):
        if  vOrder is None:
            vOrder = 3 # default
        assertValidSFInt32(vOrder)
        assertGreaterThanEquals('vOrder', vOrder, 2)
        self.__vOrder = vOrder
    @property # getter - - - - - - - - - -
    def weight(self):
        """Output values for linear interpolation, each corresponding to knots."""
        return self.__weight
    @weight.setter
    def weight(self, weight):
        if  weight is None:
            weight = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(weight)
        assertPositive('weight', weight)
        self.__weight = weight
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function NurbsTextureCoordinate.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<NurbsTextureCoordinate'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.controlPoint != list():
            result += " controlPoint='" + MFVec2f(self.controlPoint).XML() + "'"
        if self.uDimension != 0:
            result += " uDimension='" + SFInt32(self.uDimension).XML() + "'"
        if self.uKnot != list():
            result += " uKnot='" + MFDouble(self.uKnot).XML() + "'"
        if self.uOrder != 3:
            result += " uOrder='" + SFInt32(self.uOrder).XML() + "'"
        if self.vDimension != 0:
            result += " vDimension='" + SFInt32(self.vDimension).XML() + "'"
        if self.vKnot != list():
            result += " vKnot='" + MFDouble(self.vKnot).XML() + "'"
        if self.vOrder != 3:
            result += " vOrder='" + SFInt32(self.vOrder).XML() + "'"
        if self.weight != list():
            result += " weight='" + MFFloat(self.weight).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></NurbsTextureCoordinate>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</NurbsTextureCoordinate>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function NurbsTextureCoordinate.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'NurbsTextureCoordinate' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'NurbsTextureCoordinate' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.controlPoint != list():
            result += " controlPoint " + MFVec2f(self.controlPoint).VRML() + ""
        if self.uDimension != 0:
            result += " uDimension " + SFInt32(self.uDimension).VRML() + ""
        if self.uKnot != list():
            result += " uKnot " + MFDouble(self.uKnot).VRML() + ""
        if self.uOrder != 3:
            result += " uOrder " + SFInt32(self.uOrder).VRML() + ""
        if self.vDimension != 0:
            result += " vDimension " + SFInt32(self.vDimension).VRML() + ""
        if self.vKnot != list():
            result += " vKnot " + MFDouble(self.vKnot).VRML() + ""
        if self.vOrder != 3:
            result += " vOrder " + SFInt32(self.vOrder).VRML() + ""
        if self.weight != list():
            result += " weight " + MFFloat(self.weight).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class NurbsTrimmedSurface(_X3DNurbsSurfaceGeometryNode):
    """
    NurbsTrimmedSurface generates texture coordinates from a Non-Uniform Rational B-Spline (NURBS) surface.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'NurbsTrimmedSurface'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/nurbs.html#NurbsTrimmedSurface'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#NurbsTrimmedSurface'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
            ('uClosed', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
            ('uDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
            ('uKnot', list(), FieldType.MFDouble, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
            ('uOrder', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
            ('uTessellation', 0, FieldType.SFInt32, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
            ('vClosed', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
            ('vDimension', 0, FieldType.SFInt32, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
            ('vKnot', list(), FieldType.MFDouble, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
            ('vOrder', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DNurbsSurfaceGeometryNode'),
            ('vTessellation', 0, FieldType.SFInt32, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
            ('weight', list(), FieldType.MFDouble, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
            ('controlPoint', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
            ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNurbsSurfaceGeometryNode'),
            ('trimmingContour', list(), FieldType.MFNode, AccessType.inputOutput, 'NurbsTrimmedSurface'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 solid=True,
                 uClosed=False,
                 uDimension=0,
                 uKnot=list(),
                 uOrder=3,
                 uTessellation=0,
                 vClosed=False,
                 vDimension=0,
                 vKnot=list(),
                 vOrder=3,
                 vTessellation=0,
                 weight=list(),
                 controlPoint=None,
                 texCoord=None,
                 trimmingContour=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode NurbsTrimmedSurface __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.solid = solid
        self.uClosed = uClosed
        self.uDimension = uDimension
        self.uKnot = uKnot
        self.uOrder = uOrder
        self.uTessellation = uTessellation
        self.vClosed = vClosed
        self.vDimension = vDimension
        self.vKnot = vKnot
        self.vOrder = vOrder
        self.vTessellation = vTessellation
        self.weight = weight
        self.controlPoint = controlPoint
        self.texCoord = texCoord
        self.trimmingContour = trimmingContour
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def uClosed(self):
        """Whether opposite surface sides are closed (seamless) across u dimension."""
        return self.__uClosed
    @uClosed.setter
    def uClosed(self, uClosed):
        if  uClosed is None:
            uClosed = False # default
        assertValidSFBool(uClosed)
        self.__uClosed = uClosed
    @property # getter - - - - - - - - - -
    def uDimension(self):
        """Number of control points in u dimension."""
        return self.__uDimension
    @uDimension.setter
    def uDimension(self, uDimension):
        if  uDimension is None:
            uDimension = 0 # default
        assertValidSFInt32(uDimension)
        assertNonNegative('uDimension', uDimension)
        self.__uDimension = uDimension
    @property # getter - - - - - - - - - -
    def uKnot(self):
        """Knot vector, where size = number of control points + order of curve."""
        return self.__uKnot
    @uKnot.setter
    def uKnot(self, uKnot):
        if  uKnot is None:
            uKnot = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(uKnot)
        self.__uKnot = uKnot
    @property # getter - - - - - - - - - -
    def uOrder(self):
        """Define order of surface by polynomials of degree = order-1."""
        return self.__uOrder
    @uOrder.setter
    def uOrder(self, uOrder):
        if  uOrder is None:
            uOrder = 3 # default
        assertValidSFInt32(uOrder)
        assertGreaterThanEquals('uOrder', uOrder, 2)
        self.__uOrder = uOrder
    @property # getter - - - - - - - - - -
    def uTessellation(self):
        """hint for surface tessellation."""
        return self.__uTessellation
    @uTessellation.setter
    def uTessellation(self, uTessellation):
        if  uTessellation is None:
            uTessellation = 0 # default
        assertValidSFInt32(uTessellation)
        self.__uTessellation = uTessellation
    @property # getter - - - - - - - - - -
    def vClosed(self):
        """Whether opposite surface sides are closed (seamless) across u dimension."""
        return self.__vClosed
    @vClosed.setter
    def vClosed(self, vClosed):
        if  vClosed is None:
            vClosed = False # default
        assertValidSFBool(vClosed)
        self.__vClosed = vClosed
    @property # getter - - - - - - - - - -
    def vDimension(self):
        """Number of control points in v dimension."""
        return self.__vDimension
    @vDimension.setter
    def vDimension(self, vDimension):
        if  vDimension is None:
            vDimension = 0 # default
        assertValidSFInt32(vDimension)
        assertNonNegative('vDimension', vDimension)
        self.__vDimension = vDimension
    @property # getter - - - - - - - - - -
    def vKnot(self):
        """Knot vector, where size = number of control points + order of curve."""
        return self.__vKnot
    @vKnot.setter
    def vKnot(self, vKnot):
        if  vKnot is None:
            vKnot = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(vKnot)
        self.__vKnot = vKnot
    @property # getter - - - - - - - - - -
    def vOrder(self):
        """Define order of surface by polynomials of degree = order-1."""
        return self.__vOrder
    @vOrder.setter
    def vOrder(self, vOrder):
        if  vOrder is None:
            vOrder = 3 # default
        assertValidSFInt32(vOrder)
        assertGreaterThanEquals('vOrder', vOrder, 2)
        self.__vOrder = vOrder
    @property # getter - - - - - - - - - -
    def vTessellation(self):
        """hint for surface tessellation."""
        return self.__vTessellation
    @vTessellation.setter
    def vTessellation(self, vTessellation):
        if  vTessellation is None:
            vTessellation = 0 # default
        assertValidSFInt32(vTessellation)
        self.__vTessellation = vTessellation
    @property # getter - - - - - - - - - -
    def weight(self):
        """Vector assigning relative weight value to each control point."""
        return self.__weight
    @weight.setter
    def weight(self, weight):
        if  weight is None:
            weight = MFDouble.DEFAULT_VALUE(self)
        assertValidMFDouble(weight)
        assertPositive('weight', weight)
        self.__weight = weight
    @property # getter - - - - - - - - - -
    def controlPoint(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that specifies control points for NURBS geometry definitions."""
        return self.__controlPoint
    @controlPoint.setter
    def controlPoint(self, controlPoint):
        if  controlPoint is None:
            controlPoint = None # default
        assertValidSFNode(controlPoint)
        if not isinstance(controlPoint, object):
            # print(flush=True)
            raise X3DTypeError(str(controlPoint) + ' does not have a valid node type object')
        self.__controlPoint = controlPoint
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode|NurbsTextureCoordinate] Single contained NurbsTextureCoordinate, TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that specifies coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None # default
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def trimmingContour(self):
        """[Contour2D] A set of Contour2D nodes are used as trimming loops."""
        return self.__trimmingContour
    @trimmingContour.setter
    def trimmingContour(self, trimmingContour):
        if  trimmingContour is None:
            trimmingContour = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(trimmingContour)
        self.__trimmingContour = trimmingContour
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.trimmingContour or self.controlPoint or self.IS or self.metadata or self.texCoord
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function NurbsTrimmedSurface.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<NurbsTrimmedSurface'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if self.uClosed: # default=false
            result += " uClosed='" + SFBool(self.uClosed).XML() + "'"
        if self.uDimension != 0:
            result += " uDimension='" + SFInt32(self.uDimension).XML() + "'"
        if self.uKnot != list():
            result += " uKnot='" + MFDouble(self.uKnot).XML() + "'"
        if self.uOrder != 3:
            result += " uOrder='" + SFInt32(self.uOrder).XML() + "'"
        if self.uTessellation != 0:
            result += " uTessellation='" + SFInt32(self.uTessellation).XML() + "'"
        if self.vClosed: # default=false
            result += " vClosed='" + SFBool(self.vClosed).XML() + "'"
        if self.vDimension != 0:
            result += " vDimension='" + SFInt32(self.vDimension).XML() + "'"
        if self.vKnot != list():
            result += " vKnot='" + MFDouble(self.vKnot).XML() + "'"
        if self.vOrder != 3:
            result += " vOrder='" + SFInt32(self.vOrder).XML() + "'"
        if self.vTessellation != 0:
            result += " vTessellation='" + SFInt32(self.vTessellation).XML() + "'"
        if self.weight != list():
            result += " weight='" + MFDouble(self.weight).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></NurbsTrimmedSurface>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.controlPoint: # output this SFNode
                result += self.controlPoint.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.texCoord: # output this SFNode
                result += self.texCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.trimmingContour: # walk each child in MFNode list, if any
            ### print('* NurbsTrimmedSurface found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(trimmingContour)=' + str(len(self.trimmingContour)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.trimmingContour:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</NurbsTrimmedSurface>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function NurbsTrimmedSurface.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'NurbsTrimmedSurface' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'NurbsTrimmedSurface' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.uClosed: # default=false
            result += " uClosed " + SFBool(self.uClosed).VRML() + ""
        if self.uDimension != 0:
            result += " uDimension " + SFInt32(self.uDimension).VRML() + ""
        if self.uKnot != list():
            result += " uKnot " + MFDouble(self.uKnot).VRML() + ""
        if self.uOrder != 3:
            result += " uOrder " + SFInt32(self.uOrder).VRML() + ""
        if self.uTessellation != 0:
            result += " uTessellation " + SFInt32(self.uTessellation).VRML() + ""
        if self.vClosed: # default=false
            result += " vClosed " + SFBool(self.vClosed).VRML() + ""
        if self.vDimension != 0:
            result += " vDimension " + SFInt32(self.vDimension).VRML() + ""
        if self.vKnot != list():
            result += " vKnot " + MFDouble(self.vKnot).VRML() + ""
        if self.vOrder != 3:
            result += " vOrder " + SFInt32(self.vOrder).VRML() + ""
        if self.vTessellation != 0:
            result += " vTessellation " + SFInt32(self.vTessellation).VRML() + ""
        if self.weight != list():
            result += " weight " + MFDouble(self.weight).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.controlPoint: # output this SFNode
            result += '\n' + '  ' + indent + 'controlPoint ' + self.controlPoint.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'texCoord ' + self.texCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.trimmingContour: # walk each child in MFNode list, if any
            for each in self.trimmingContour:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class OpacityMapVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    OpacityMapVolumeStyle specifies that volumetric data is rendered using opacity mapped to a transfer function texture.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'OpacityMapVolumeStyle'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/volume.html#OpacityMapVolumeStyle'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#OpacityMapVolumeStyle'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
            ('transferFunction', None, FieldType.SFNode, AccessType.inputOutput, 'OpacityMapVolumeStyle'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 enabled=True,
                 transferFunction=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode OpacityMapVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.transferFunction = transferFunction
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def transferFunction(self):
        return self.__transferFunction
    @transferFunction.setter
    def transferFunction(self, transferFunction):
        if  transferFunction is None:
            transferFunction = None # default
        assertValidSFNode(transferFunction)
        if not isinstance(transferFunction, object):
            # print(flush=True)
            raise X3DTypeError(str(transferFunction) + ' does not have a valid node type object')
        self.__transferFunction = transferFunction
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.transferFunction
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function OpacityMapVolumeStyle.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<OpacityMapVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></OpacityMapVolumeStyle>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.transferFunction: # output this SFNode
                result += self.transferFunction.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</OpacityMapVolumeStyle>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function OpacityMapVolumeStyle.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'OpacityMapVolumeStyle' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'OpacityMapVolumeStyle' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.transferFunction: # output this SFNode
            result += '\n' + '  ' + indent + 'transferFunction ' + self.transferFunction.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class OrientationChaser(_X3DChaserNode):
    """
    OrientationChaser generates a series of 4-tuple axis-angle SFRotation values that progressively change from initial value to destination value.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'OrientationChaser'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/followers.html#OrientationChaser'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#OrientationChaser'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('duration', 1, FieldType.SFTime, AccessType.initializeOnly, 'X3DChaserNode'),
            ('initialDestination', (0, 1, 0, 0), FieldType.SFRotation, AccessType.initializeOnly, 'OrientationChaser'),
            ('initialValue', (0, 1, 0, 0), FieldType.SFRotation, AccessType.initializeOnly, 'OrientationChaser'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 duration=1,
                 initialDestination=(0, 1, 0, 0),
                 initialValue=(0, 1, 0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode OrientationChaser __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
    @property # getter - - - - - - - - - -
    def duration(self):
        """[0,+infinity) duration is the time interval for filter response in seconds."""
        return self.__duration
    @duration.setter
    def duration(self, duration):
        if  duration is None:
            duration = 1 # default
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = (0, 1, 0, 0) # default
        assertValidSFRotation(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = (0, 1, 0, 0) # default
        assertValidSFRotation(initialValue)
        self.__initialValue = initialValue
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function OrientationChaser.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<OrientationChaser'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.duration != 1:
            result += " duration='" + SFTime(self.duration).XML() + "'"
        if self.initialDestination != (0, 1, 0, 0):
            result += " initialDestination='" + SFRotation(self.initialDestination).XML() + "'"
        if self.initialValue != (0, 1, 0, 0):
            result += " initialValue='" + SFRotation(self.initialValue).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></OrientationChaser>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</OrientationChaser>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function OrientationChaser.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'OrientationChaser' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'OrientationChaser' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.duration != 1:
            result += " duration " + SFTime(self.duration).VRML() + ""
        if self.initialDestination != (0, 1, 0, 0):
            result += " initialDestination " + SFRotation(self.initialDestination).VRML() + ""
        if self.initialValue != (0, 1, 0, 0):
            result += " initialValue " + SFRotation(self.initialValue).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class OrientationDamper(_X3DDamperNode):
    """
    OrientationDamper generates a series of 4-tuple axis-angle SFRotation values that progressively change from initial value to destination value.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'OrientationDamper'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/followers.html#OrientationDamper'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#OrientationDamper'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('initialDestination', (0, 1, 0, 0), FieldType.SFRotation, AccessType.initializeOnly, 'OrientationDamper'),
            ('initialValue', (0, 1, 0, 0), FieldType.SFRotation, AccessType.initializeOnly, 'OrientationDamper'),
            ('order', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DDamperNode'),
            ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput, 'X3DDamperNode'),
            ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DDamperNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 initialDestination=(0, 1, 0, 0),
                 initialValue=(0, 1, 0, 0),
                 order=3,
                 tau=0.3,
                 tolerance=-1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode OrientationDamper __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = (0, 1, 0, 0) # default
        assertValidSFRotation(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = (0, 1, 0, 0) # default
        assertValidSFRotation(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        """[0,5] order defines the number of internal filters (larger means smoother response, longer delay)."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3 # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        """[0,+infinity) tau is the exponential-decay time constant for filter response in seconds."""
        return self.__tau
    @tau.setter
    def tau(self, tau):
        if  tau is None:
            tau = 0.3 # default
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        """[0,+infinity) or -1."""
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance):
        if  tolerance is None:
            tolerance = -1 # default
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function OrientationDamper.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<OrientationDamper'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.initialDestination != (0, 1, 0, 0):
            result += " initialDestination='" + SFRotation(self.initialDestination).XML() + "'"
        if self.initialValue != (0, 1, 0, 0):
            result += " initialValue='" + SFRotation(self.initialValue).XML() + "'"
        if self.order != 3:
            result += " order='" + SFInt32(self.order).XML() + "'"
        if self.tau != 0.3:
            result += " tau='" + SFTime(self.tau).XML() + "'"
        if self.tolerance != -1:
            result += " tolerance='" + SFFloat(self.tolerance).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></OrientationDamper>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</OrientationDamper>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function OrientationDamper.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'OrientationDamper' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'OrientationDamper' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.initialDestination != (0, 1, 0, 0):
            result += " initialDestination " + SFRotation(self.initialDestination).VRML() + ""
        if self.initialValue != (0, 1, 0, 0):
            result += " initialValue " + SFRotation(self.initialValue).VRML() + ""
        if self.order != 3:
            result += " order " + SFInt32(self.order).VRML() + ""
        if self.tau != 0.3:
            result += " tau " + SFTime(self.tau).VRML() + ""
        if self.tolerance != -1:
            result += " tolerance " + SFFloat(self.tolerance).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class OrientationInterpolator(_X3DInterpolatorNode):
    """
    OrientationInterpolator generates a series of 4-tuple axis-angle SFRotation values.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'OrientationInterpolator'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/interpolators.html#OrientationInterpolator'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#OrientationInterpolator'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('key', list(), FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
            ('keyValue', list(), FieldType.MFRotation, AccessType.inputOutput, 'OrientationInterpolator'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode OrientationInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFRotation.DEFAULT_VALUE(self)
        assertValidMFRotation(keyValue)
        self.__keyValue = keyValue
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function OrientationInterpolator.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<OrientationInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + MFFloat(self.key).XML() + "'"
        if self.keyValue != list():
            result += " keyValue='" + MFRotation(self.keyValue).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></OrientationInterpolator>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</OrientationInterpolator>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function OrientationInterpolator.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'OrientationInterpolator' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'OrientationInterpolator' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.key != list():
            result += " key " + MFFloat(self.key).VRML() + ""
        if self.keyValue != list():
            result += " keyValue " + MFRotation(self.keyValue).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class OrthoViewpoint(_X3DViewpointNode):
    """
    OrthoViewpoint provides an orthographic perspective-free view of a scene from a specific location and direction.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'OrthoViewpoint'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/navigation.html#OrthoViewpoint'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#OrthoViewpoint'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('centerOfRotation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'OrthoViewpoint'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DViewpointNode'),
            ('farDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DViewpointNode'),
            ('fieldOfView', [-1, -1, 1, 1], FieldType.MFFloat, AccessType.inputOutput, 'OrthoViewpoint'),
            ('jump', True, FieldType.SFBool, AccessType.inputOutput, 'X3DViewpointNode'),
            ('nearDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DViewpointNode'),
            ('orientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'X3DViewpointNode'),
            ('position', (0, 0, 10), FieldType.SFVec3f, AccessType.inputOutput, 'OrthoViewpoint'),
            ('retainUserOffsets', False, FieldType.SFBool, AccessType.inputOutput, 'X3DViewpointNode'),
            ('viewAll', False, FieldType.SFBool, AccessType.inputOutput, 'X3DViewpointNode'),
            ('navigationInfo', None, FieldType.SFNode, AccessType.inputOutput, 'X3DViewpointNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 centerOfRotation=(0, 0, 0),
                 description='',
                 farDistance=-1,
                 fieldOfView=[-1, -1, 1, 1],
                 jump=True,
                 nearDistance=-1,
                 orientation=(0, 0, 1, 0),
                 position=(0, 0, 10),
                 retainUserOffsets=False,
                 viewAll=False,
                 navigationInfo=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode OrthoViewpoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.centerOfRotation = centerOfRotation
        self.description = description
        self.farDistance = farDistance
        self.fieldOfView = fieldOfView
        self.jump = jump
        self.nearDistance = nearDistance
        self.orientation = orientation
        self.position = position
        self.retainUserOffsets = retainUserOffsets
        self.viewAll = viewAll
        self.navigationInfo = navigationInfo
    @property # getter - - - - - - - - - -
    def centerOfRotation(self):
        """centerOfRotation specifies center point about which to rotate user's eyepoint when in EXAMINE or LOOKAT mode."""
        return self.__centerOfRotation
    @centerOfRotation.setter
    def centerOfRotation(self, centerOfRotation):
        if  centerOfRotation is None:
            centerOfRotation = (0, 0, 0) # default
        assertValidSFVec3f(centerOfRotation)
        self.__centerOfRotation = centerOfRotation
    @property # getter - - - - - - - - - -
    def description(self):
        """Text description or navigation hint to describe the significance of this model Viewpoint."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def farDistance(self):
        """or (0,+infinity) farDistance defines maximum clipping plane distance allowed for object display."""
        return self.__farDistance
    @farDistance.setter
    def farDistance(self, farDistance):
        if  farDistance is None:
            farDistance = -1 # default
        assertValidSFFloat(farDistance)
        self.__farDistance = farDistance
    @property # getter - - - - - - - - - -
    def fieldOfView(self):
        """Minimum and maximum extents of view in units of local coordinate system."""
        return self.__fieldOfView
    @fieldOfView.setter
    def fieldOfView(self, fieldOfView):
        if  fieldOfView is None:
            fieldOfView = [-1, -1, 1, 1] # default
        assertValidMFFloat(fieldOfView)
        self.__fieldOfView = fieldOfView
    @property # getter - - - - - - - - - -
    def jump(self):
        """Transition instantly by jumping, otherwise smoothly adjust offsets in place when changing to this Viewpoint."""
        return self.__jump
    @jump.setter
    def jump(self, jump):
        if  jump is None:
            jump = True # default
        assertValidSFBool(jump)
        self.__jump = jump
    @property # getter - - - - - - - - - -
    def nearDistance(self):
        """or (0,+infinity) nearDistance defines minimum clipping plane distance necessary for object display."""
        return self.__nearDistance
    @nearDistance.setter
    def nearDistance(self, nearDistance):
        if  nearDistance is None:
            nearDistance = -1 # default
        assertValidSFFloat(nearDistance)
        self.__nearDistance = nearDistance
    @property # getter - - - - - - - - - -
    def orientation(self):
        """Rotation (axis, angle in radians) of Viewpoint, relative to default -Z axis direction in local coordinate system."""
        return self.__orientation
    @orientation.setter
    def orientation(self, orientation):
        if  orientation is None:
            orientation = (0, 0, 1, 0) # default
        assertValidSFRotation(orientation)
        self.__orientation = orientation
    @property # getter - - - - - - - - - -
    def position(self):
        """position (x, y, z in meters) relative to local coordinate system."""
        return self.__position
    @position.setter
    def position(self, position):
        if  position is None:
            position = (0, 0, 10) # default
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def retainUserOffsets(self):
        """Retain (true) or reset to zero (false) any prior user navigation offsets from defined viewpoint position, orientation."""
        return self.__retainUserOffsets
    @retainUserOffsets.setter
    def retainUserOffsets(self, retainUserOffsets):
        if  retainUserOffsets is None:
            retainUserOffsets = False # default
        assertValidSFBool(retainUserOffsets)
        self.__retainUserOffsets = retainUserOffsets
    @property # getter - - - - - - - - - -
    def viewAll(self):
        return self.__viewAll
    @viewAll.setter
    def viewAll(self, viewAll):
        if  viewAll is None:
            viewAll = False # default
        assertValidSFBool(viewAll)
        self.__viewAll = viewAll
    @property # getter - - - - - - - - - -
    def navigationInfo(self):
        return self.__navigationInfo
    @navigationInfo.setter
    def navigationInfo(self, navigationInfo):
        if  navigationInfo is None:
            navigationInfo = None # default
        assertValidSFNode(navigationInfo)
        if not isinstance(navigationInfo, object):
            # print(flush=True)
            raise X3DTypeError(str(navigationInfo) + ' does not have a valid node type object')
        self.__navigationInfo = navigationInfo
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.navigationInfo
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function OrthoViewpoint.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<OrthoViewpoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.centerOfRotation != (0, 0, 0):
            result += " centerOfRotation='" + SFVec3f(self.centerOfRotation).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.farDistance != -1:
            result += " farDistance='" + SFFloat(self.farDistance).XML() + "'"
        if self.fieldOfView != [-1, -1, 1, 1]:
            result += " fieldOfView='" + MFFloat(self.fieldOfView).XML() + "'"
        if not self.jump: # default=true
            result += " jump='" + SFBool(self.jump).XML() + "'"
        if self.nearDistance != -1:
            result += " nearDistance='" + SFFloat(self.nearDistance).XML() + "'"
        if self.orientation != (0, 0, 1, 0):
            result += " orientation='" + SFRotation(self.orientation).XML() + "'"
        if self.position != (0, 0, 10):
            result += " position='" + SFVec3f(self.position).XML() + "'"
        if self.retainUserOffsets: # default=false
            result += " retainUserOffsets='" + SFBool(self.retainUserOffsets).XML() + "'"
        if self.viewAll: # default=false
            result += " viewAll='" + SFBool(self.viewAll).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></OrthoViewpoint>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.navigationInfo: # output this SFNode
                result += self.navigationInfo.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</OrthoViewpoint>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function OrthoViewpoint.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'OrthoViewpoint' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'OrthoViewpoint' + ' {'
        if self.centerOfRotation != (0, 0, 0):
            result += " centerOfRotation " + SFVec3f(self.centerOfRotation).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.farDistance != -1:
            result += " farDistance " + SFFloat(self.farDistance).VRML() + ""
        if self.fieldOfView != [-1, -1, 1, 1]:
            result += " fieldOfView " + MFFloat(self.fieldOfView).VRML() + ""
        if not self.jump: # default=true
            result += " jump " + SFBool(self.jump).VRML() + ""
        if self.nearDistance != -1:
            result += " nearDistance " + SFFloat(self.nearDistance).VRML() + ""
        if self.orientation != (0, 0, 1, 0):
            result += " orientation " + SFRotation(self.orientation).VRML() + ""
        if self.position != (0, 0, 10):
            result += " position " + SFVec3f(self.position).VRML() + ""
        if self.retainUserOffsets: # default=false
            result += " retainUserOffsets " + SFBool(self.retainUserOffsets).VRML() + ""
        if self.viewAll: # default=false
            result += " viewAll " + SFBool(self.viewAll).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.navigationInfo: # output this SFNode
            result += '\n' + '  ' + indent + 'navigationInfo ' + self.navigationInfo.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class OscillatorSource(_X3DSoundSourceNode):
    """
    OscillatorSource node represents an audio source generating a periodic waveform, providing a constant tone.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'OscillatorSource'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#OscillatorSource'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#OscillatorSource'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('detune', 0, FieldType.SFFloat, AccessType.inputOutput, 'OscillatorSource'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundSourceNode'),
            ('frequency', 0, FieldType.SFFloat, AccessType.inputOutput, 'OscillatorSource'),
            ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundSourceNode'),
            ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 detune=0,
                 enabled=True,
                 frequency=0,
                 gain=1,
                 pauseTime=0,
                 resumeTime=0,
                 startTime=0,
                 stopTime=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode OscillatorSource __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.detune = detune
        self.enabled = enabled
        self.frequency = frequency
        self.gain = gain
        self.pauseTime = pauseTime
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def detune(self):
        """(0,+infinity) The detune ffield is an a-rate AudioParam representing detuning of oscillation in cents (though the AudioParam returned is read-only, the value it represents is not)."""
        return self.__detune
    @detune.setter
    def detune(self, detune):
        if  detune is None:
            detune = 0 # default
        assertValidSFFloat(detune)
        assertNonNegative('detune', detune)
        self.__detune = detune
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def frequency(self):
        return self.__frequency
    @frequency.setter
    def frequency(self, frequency):
        if  frequency is None:
            frequency = 0 # default
        assertValidSFFloat(frequency)
        assertNonNegative('frequency', frequency)
        self.__frequency = frequency
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1 # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0 # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0 # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0 # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0 # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function OscillatorSource.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<OscillatorSource'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.detune != 0:
            result += " detune='" + SFFloat(self.detune).XML() + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.frequency != 0:
            result += " frequency='" + SFFloat(self.frequency).XML() + "'"
        if self.gain != 1:
            result += " gain='" + SFFloat(self.gain).XML() + "'"
        if self.pauseTime != 0:
            result += " pauseTime='" + SFTime(self.pauseTime).XML() + "'"
        if self.resumeTime != 0:
            result += " resumeTime='" + SFTime(self.resumeTime).XML() + "'"
        if self.startTime != 0:
            result += " startTime='" + SFTime(self.startTime).XML() + "'"
        if self.stopTime != 0:
            result += " stopTime='" + SFTime(self.stopTime).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></OscillatorSource>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</OscillatorSource>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function OscillatorSource.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'OscillatorSource' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'OscillatorSource' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.detune != 0:
            result += " detune " + SFFloat(self.detune).VRML() + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.frequency != 0:
            result += " frequency " + SFFloat(self.frequency).VRML() + ""
        if self.gain != 1:
            result += " gain " + SFFloat(self.gain).VRML() + ""
        if self.pauseTime != 0:
            result += " pauseTime " + SFTime(self.pauseTime).VRML() + ""
        if self.resumeTime != 0:
            result += " resumeTime " + SFTime(self.resumeTime).VRML() + ""
        if self.startTime != 0:
            result += " startTime " + SFTime(self.startTime).VRML() + ""
        if self.stopTime != 0:
            result += " stopTime " + SFTime(self.stopTime).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PackagedShader(_X3DShaderNode): # , _X3DUrlObject, _X3DProgrammableShaderObject # TODO fix additional inheritance method resolution order (MRO)
    """
    PackagedShader can contain field declarations, but no CDATA section of plain-text source code.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PackagedShader'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shaders.html#PackagedShader'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PackagedShader'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DUrlObject'),
            ('language', '', FieldType.SFString, AccessType.initializeOnly, 'X3DShaderNode'),
            ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
            ('refresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
            ('url', list(), FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
            ('field', list(), FieldType.MFNode, AccessType.inputOutput, 'PackagedShader'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'PackagedShader'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'PackagedShader')]
    def __init__(self,
                 description='',
                 language='',
                 load=True,
                 refresh=0,
                 url=list(),
                 field=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PackagedShader __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.language = language
        self.load = load
        self.refresh = refresh
        self.url = url
        self.field = field
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def language(self):
        """The language field indicates to the X3D player which shading language is used."""
        return self.__language
    @language.setter
    def language(self, language):
        if  language is None:
            language = SFString.DEFAULT_VALUE(self)
        assertValidSFString(language)
        self.__language = language
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def refresh(self):
        """refresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__refresh
    @refresh.setter
    def refresh(self, refresh):
        if  refresh is None:
            refresh = 0 # default
        assertValidSFTime(refresh)
        assertNonNegative('refresh', refresh)
        self.__refresh = refresh
    @property # getter - - - - - - - - - -
    def url(self):
        """url points to a shader source-code file that may contain a number of shaders and combined effects."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE(self)
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def field(self):
        """Include a field statement for each field declaration in the PackagedShader node."""
        return self.__field
    @field.setter
    def field(self, field):
        if  field is None:
            field = MFNode.DEFAULT_VALUE(self)
        # TODO type-aware checks for field
        if field: # walk each child in MFNode list, if any
            for each in field:
                assertValidFieldInitializationValue(each.name, each.type, each.value, parent='PackagedShader')
        self.__field = field
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.field or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PackagedShader.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PackagedShader'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.language:
            result += " language='" + self.language + "'"
        if not self.load: # default=true
            result += " load='" + SFBool(self.load).XML() + "'"
        if self.refresh != 0:
            result += " refresh='" + SFTime(self.refresh).XML() + "'"
        if self.url != list():
            result += " url='" + MFString(self.url).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PackagedShader>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.field: # walk each child in MFNode list, if any
            ### print('* PackagedShader found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(field)=' + str(len(self.field)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.field:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PackagedShader>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PackagedShader.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PackagedShader' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PackagedShader' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.language:
            result += " language " +  '"' + self.language + '"' + ""
        if not self.load: # default=true
            result += " load " + SFBool(self.load).VRML() + ""
        if self.refresh != 0:
            result += " refresh " + SFTime(self.refresh).VRML() + ""
        if self.url != list():
            result += " url " + MFString(self.url).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.field: # walk each child in MFNode list, if any
            for each in self.field:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ParticleSystem(_X3DShapeNode):
    """
    ParticleSystem specifies a complete particle system.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ParticleSystem'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/particleSystems.html#ParticleSystem'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ParticleSystem'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DShapeNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DShapeNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DShapeNode'),
            ('castShadow', True, FieldType.SFBool, AccessType.inputOutput, 'X3DShapeNode'),
            ('colorKey', list(), FieldType.MFFloat, AccessType.initializeOnly, 'ParticleSystem'),
            ('createParticles', True, FieldType.SFBool, AccessType.inputOutput, 'ParticleSystem'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'ParticleSystem'),
            ('geometryType', 'QUAD', FieldType.SFString, AccessType.initializeOnly, 'ParticleSystem'),
            ('lifetimeVariation', 0.25, FieldType.SFFloat, AccessType.inputOutput, 'ParticleSystem'),
            ('maxParticles', 200, FieldType.SFInt32, AccessType.inputOutput, 'ParticleSystem'),
            ('particleLifetime', 5, FieldType.SFFloat, AccessType.inputOutput, 'ParticleSystem'),
            ('particleSize', (0.02, 0.02), FieldType.SFVec2f, AccessType.inputOutput, 'ParticleSystem'),
            ('texCoordKey', list(), FieldType.MFFloat, AccessType.initializeOnly, 'ParticleSystem'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DShapeNode'),
            ('appearance', None, FieldType.SFNode, AccessType.inputOutput, 'X3DShapeNode'),
            ('colorRamp', None, FieldType.SFNode, AccessType.initializeOnly, 'ParticleSystem'),
            ('emitter', None, FieldType.SFNode, AccessType.initializeOnly, 'ParticleSystem'),
            ('geometry', None, FieldType.SFNode, AccessType.inputOutput, 'ParticleSystem'),
            ('texCoordRamp', None, FieldType.SFNode, AccessType.initializeOnly, 'ParticleSystem'),
            ('physics', list(), FieldType.MFNode, AccessType.initializeOnly, 'ParticleSystem'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 castShadow=True,
                 colorKey=list(),
                 createParticles=True,
                 enabled=True,
                 geometryType='QUAD',
                 lifetimeVariation=0.25,
                 maxParticles=200,
                 particleLifetime=5,
                 particleSize=(0.02, 0.02),
                 texCoordKey=list(),
                 visible=True,
                 appearance=None,
                 colorRamp=None,
                 emitter=None,
                 geometry=None,
                 texCoordRamp=None,
                 physics=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ParticleSystem __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.castShadow = castShadow
        self.colorKey = colorKey
        self.createParticles = createParticles
        self.enabled = enabled
        self.geometryType = geometryType
        self.lifetimeVariation = lifetimeVariation
        self.maxParticles = maxParticles
        self.particleLifetime = particleLifetime
        self.particleSize = particleSize
        self.texCoordKey = texCoordKey
        self.visible = visible
        self.appearance = appearance
        self.colorRamp = colorRamp
        self.emitter = emitter
        self.geometry = geometry
        self.texCoordRamp = texCoordRamp
        self.physics = physics
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def castShadow(self):
        return self.__castShadow
    @castShadow.setter
    def castShadow(self, castShadow):
        if  castShadow is None:
            castShadow = True # default
        assertValidSFBool(castShadow)
        self.__castShadow = castShadow
    @property # getter - - - - - - - - - -
    def colorKey(self):
        """[0,+infinity) Array of time intervals in seconds, corresponding to particle lifetime, that are used to interpolate colorRamp array values."""
        return self.__colorKey
    @colorKey.setter
    def colorKey(self, colorKey):
        if  colorKey is None:
            colorKey = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(colorKey)
        assertNonNegative('colorKey', colorKey)
        self.__colorKey = colorKey
    @property # getter - - - - - - - - - -
    def createParticles(self):
        """Enables/disables creation of new particles, while any existing particles remain in existence and continue to animate until the end of their lifetimes."""
        return self.__createParticles
    @createParticles.setter
    def createParticles(self, createParticles):
        if  createParticles is None:
            createParticles = True # default
        assertValidSFBool(createParticles)
        self.__createParticles = createParticles
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def geometryType(self):
        """specifies type of geometry used to represent individual particles."""
        return self.__geometryType
    @geometryType.setter
    def geometryType(self, geometryType):
        if  geometryType is None:
            geometryType = 'QUAD' # default
        assertValidSFString(geometryType)
        self.__geometryType = geometryType
    @property # getter - - - - - - - - - -
    def lifetimeVariation(self):
        """[0,1) TODO not properly defined in X3D spedification."""
        return self.__lifetimeVariation
    @lifetimeVariation.setter
    def lifetimeVariation(self, lifetimeVariation):
        if  lifetimeVariation is None:
            lifetimeVariation = 0.25 # default
        assertValidSFFloat(lifetimeVariation)
        assertZeroToOne('lifetimeVariation', lifetimeVariation)
        self.__lifetimeVariation = lifetimeVariation
    @property # getter - - - - - - - - - -
    def maxParticles(self):
        """[0,+infinity) Maximum number of particles to be generated at one time (subject to player limitations)."""
        return self.__maxParticles
    @maxParticles.setter
    def maxParticles(self, maxParticles):
        if  maxParticles is None:
            maxParticles = 200 # default
        assertValidSFInt32(maxParticles)
        assertNonNegative('maxParticles', maxParticles)
        self.__maxParticles = maxParticles
    @property # getter - - - - - - - - - -
    def particleLifetime(self):
        """[0,+infinity) TODO not properly defined in X3D spedification."""
        return self.__particleLifetime
    @particleLifetime.setter
    def particleLifetime(self, particleLifetime):
        if  particleLifetime is None:
            particleLifetime = 5 # default
        assertValidSFFloat(particleLifetime)
        assertNonNegative('particleLifetime', particleLifetime)
        self.__particleLifetime = particleLifetime
    @property # getter - - - - - - - - - -
    def particleSize(self):
        """[0,+infinity) particleSize describes width and height dimensions for each particle in length base units (default is meters)."""
        return self.__particleSize
    @particleSize.setter
    def particleSize(self, particleSize):
        if  particleSize is None:
            particleSize = (0.02, 0.02) # default
        assertValidSFVec2f(particleSize)
        assertNonNegative('particleSize', particleSize)
        self.__particleSize = particleSize
    @property # getter - - - - - - - - - -
    def texCoordKey(self):
        """[0,+infinity) Array of time intervals in seconds, corresponding to particle lifetime, that are used to sequence texCoordRamp array values."""
        return self.__texCoordKey
    @texCoordKey.setter
    def texCoordKey(self, texCoordKey):
        if  texCoordKey is None:
            texCoordKey = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(texCoordKey)
        assertNonNegative('texCoordKey', texCoordKey)
        self.__texCoordKey = texCoordKey
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def appearance(self):
        """[X3DAppearanceNode] The appearance field holds an Appearance node that is used for the geometry."""
        return self.__appearance
    @appearance.setter
    def appearance(self, appearance):
        if  appearance is None:
            appearance = None # default
        assertValidSFNode(appearance)
        if not isinstance(appearance, object):
            # print(flush=True)
            raise X3DTypeError(str(appearance) + ' does not have a valid node type object')
        self.__appearance = appearance
    @property # getter - - - - - - - - - -
    def colorRamp(self):
        """[X3DColorNode] The colorRamp Color|ColorRGBA node holds a series of color values to be used at the given colorKey points in time."""
        return self.__colorRamp
    @colorRamp.setter
    def colorRamp(self, colorRamp):
        if  colorRamp is None:
            colorRamp = None # default
        assertValidSFNode(colorRamp)
        if not isinstance(colorRamp, object):
            # print(flush=True)
            raise X3DTypeError(str(colorRamp) + ' does not have a valid node type object')
        self.__colorRamp = colorRamp
    @property # getter - - - - - - - - - -
    def emitter(self):
        """[X3DParticleEmitterNode] The emitter field specifies the type of emitter geometry and properties that the particles are given for their initial positions."""
        return self.__emitter
    @emitter.setter
    def emitter(self, emitter):
        if  emitter is None:
            emitter = None # default
        assertValidSFNode(emitter)
        if not isinstance(emitter, object):
            # print(flush=True)
            raise X3DTypeError(str(emitter) + ' does not have a valid node type object')
        self.__emitter = emitter
    @property # getter - - - - - - - - - -
    def geometry(self):
        """[X3DGeometryNode] Single contained geometry node provides geometry used for each particle when geometryType=GEOMETRY."""
        return self.__geometry
    @geometry.setter
    def geometry(self, geometry):
        if  geometry is None:
            geometry = None # default
        assertValidSFNode(geometry)
        if not isinstance(geometry, object):
            # print(flush=True)
            raise X3DTypeError(str(geometry) + ' does not have a valid node type object')
        self.__geometry = geometry
    @property # getter - - - - - - - - - -
    def texCoordRamp(self):
        """[TextureCoordinate] texture coordinates of the provided texture(s) in the Appearance node, over time."""
        return self.__texCoordRamp
    @texCoordRamp.setter
    def texCoordRamp(self, texCoordRamp):
        if  texCoordRamp is None:
            texCoordRamp = None # default
        assertValidSFNode(texCoordRamp)
        if not isinstance(texCoordRamp, object):
            # print(flush=True)
            raise X3DTypeError(str(texCoordRamp) + ' does not have a valid node type object')
        self.__texCoordRamp = texCoordRamp
    @property # getter - - - - - - - - - -
    def physics(self):
        """[X3DParticlePhysicsModelNode] After being created, the individual particles are then manipulated according to the physics model(s) specified in the physics field."""
        return self.__physics
    @physics.setter
    def physics(self, physics):
        if  physics is None:
            physics = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(physics)
        self.__physics = physics
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.physics or self.appearance or self.colorRamp or self.emitter or self.geometry or self.IS or self.metadata or self.texCoordRamp
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ParticleSystem.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ParticleSystem'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if not self.castShadow: # default=true
            result += " castShadow='" + SFBool(self.castShadow).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.colorKey != list():
            result += " colorKey='" + MFFloat(self.colorKey).XML() + "'"
        if not self.createParticles: # default=true
            result += " createParticles='" + SFBool(self.createParticles).XML() + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.geometryType != 'QUAD':
            result += " geometryType='" + self.geometryType + "'"
        if self.lifetimeVariation != 0.25:
            result += " lifetimeVariation='" + SFFloat(self.lifetimeVariation).XML() + "'"
        if self.maxParticles != 200:
            result += " maxParticles='" + SFInt32(self.maxParticles).XML() + "'"
        if self.particleLifetime != 5:
            result += " particleLifetime='" + SFFloat(self.particleLifetime).XML() + "'"
        if self.particleSize != (0.02, 0.02):
            result += " particleSize='" + SFVec2f(self.particleSize).XML() + "'"
        if self.texCoordKey != list():
            result += " texCoordKey='" + MFFloat(self.texCoordKey).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ParticleSystem>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.appearance: # output this SFNode
                result += self.appearance.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.colorRamp: # output this SFNode
                result += self.colorRamp.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.emitter: # output this SFNode
                result += self.emitter.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.geometry: # output this SFNode
                result += self.geometry.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.texCoordRamp: # output this SFNode
                result += self.texCoordRamp.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.physics: # walk each child in MFNode list, if any
            ### print('* ParticleSystem found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(physics)=' + str(len(self.physics)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.physics:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ParticleSystem>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ParticleSystem.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ParticleSystem' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ParticleSystem' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if not self.castShadow: # default=true
            result += " castShadow " + SFBool(self.castShadow).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.colorKey != list():
            result += " colorKey " + MFFloat(self.colorKey).VRML() + ""
        if not self.createParticles: # default=true
            result += " createParticles " + SFBool(self.createParticles).VRML() + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.geometryType != 'QUAD':
            result += " geometryType " +  '"' + self.geometryType + '"' + ""
        if self.lifetimeVariation != 0.25:
            result += " lifetimeVariation " + SFFloat(self.lifetimeVariation).VRML() + ""
        if self.maxParticles != 200:
            result += " maxParticles " + SFInt32(self.maxParticles).VRML() + ""
        if self.particleLifetime != 5:
            result += " particleLifetime " + SFFloat(self.particleLifetime).VRML() + ""
        if self.particleSize != (0.02, 0.02):
            result += " particleSize " + SFVec2f(self.particleSize).VRML() + ""
        if self.texCoordKey != list():
            result += " texCoordKey " + MFFloat(self.texCoordKey).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.appearance: # output this SFNode
            result += '\n' + '  ' + indent + 'appearance ' + self.appearance.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.colorRamp: # output this SFNode
            result += '\n' + '  ' + indent + 'colorRamp ' + self.colorRamp.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.emitter: # output this SFNode
            result += '\n' + '  ' + indent + 'emitter ' + self.emitter.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.geometry: # output this SFNode
            result += '\n' + '  ' + indent + 'geometry ' + self.geometry.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texCoordRamp: # output this SFNode
            result += '\n' + '  ' + indent + 'texCoordRamp ' + self.texCoordRamp.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.physics: # walk each child in MFNode list, if any
            for each in self.physics:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PeriodicWave(_X3DSoundNode):
    """
    PeriodicWave defines a periodic waveform that can be used to shape the output of an Oscillator.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PeriodicWave'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#PeriodicWave'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PeriodicWave'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSoundNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundNode'),
            ('optionsImag', list(), FieldType.MFFloat, AccessType.inputOutput, 'PeriodicWave'),
            ('optionsReal', list(), FieldType.MFFloat, AccessType.inputOutput, 'PeriodicWave'),
            ('type', 'square', FieldType.SFString, AccessType.inputOutput, 'PeriodicWave'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 enabled=True,
                 optionsImag=list(),
                 optionsReal=list(),
                 type='square',
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PeriodicWave __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
        self.optionsImag = optionsImag
        self.optionsReal = optionsReal
        self.type = type
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def optionsImag(self):
        """imaginary coefficients for defining a waveform."""
        return self.__optionsImag
    @optionsImag.setter
    def optionsImag(self, optionsImag):
        if  optionsImag is None:
            optionsImag = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(optionsImag)
        self.__optionsImag = optionsImag
    @property # getter - - - - - - - - - -
    def optionsReal(self):
        """real coefficients for defining a waveform."""
        return self.__optionsReal
    @optionsReal.setter
    def optionsReal(self, optionsReal):
        if  optionsReal is None:
            optionsReal = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(optionsReal)
        self.__optionsReal = optionsReal
    @property # getter - - - - - - - - - -
    def type(self):
        """The type field specifies shape of waveform to play, which can be one of several provided values or else 'custom' to indicate that real and imaginary coefficient arrays define a custom waveform."""
        return self.__type
    @type.setter
    def type(self, type):
        if  type is None:
            type = 'square' # default
        assertValidSFString(type)
        assertValidPeriodicWaveType('type', type)
        self.__type = type
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PeriodicWave.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PeriodicWave'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.optionsImag != list():
            result += " optionsImag='" + MFFloat(self.optionsImag).XML() + "'"
        if self.optionsReal != list():
            result += " optionsReal='" + MFFloat(self.optionsReal).XML() + "'"
        if self.type != 'square':
            result += " type='" + self.type + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PeriodicWave>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PeriodicWave>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PeriodicWave.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PeriodicWave' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PeriodicWave' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.optionsImag != list():
            result += " optionsImag " + MFFloat(self.optionsImag).VRML() + ""
        if self.optionsReal != list():
            result += " optionsReal " + MFFloat(self.optionsReal).VRML() + ""
        if self.type != 'square':
            result += " type " +  '"' + self.type + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PhysicalMaterial(_X3DOneSidedMaterialNode):
    """
    PhysicalMaterial specifies surface rendering properties for associated geometry nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PhysicalMaterial'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shape.html#PhysicalMaterial'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PhysicalMaterial'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('baseColor', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'PhysicalMaterial'),
            ('baseTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'PhysicalMaterial'),
            ('emissiveColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
            ('emissiveTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
            ('metallic', 1, FieldType.SFFloat, AccessType.inputOutput, 'PhysicalMaterial'),
            ('metallicRoughnessTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'PhysicalMaterial'),
            ('normalScale', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
            ('normalTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
            ('occlusionStrength', 1, FieldType.SFFloat, AccessType.inputOutput, 'PhysicalMaterial'),
            ('occlusionTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'PhysicalMaterial'),
            ('roughness', 1, FieldType.SFFloat, AccessType.inputOutput, 'PhysicalMaterial'),
            ('transparency', 0, FieldType.SFFloat, AccessType.inputOutput, 'PhysicalMaterial'),
            ('baseTexture', None, FieldType.SFNode, AccessType.inputOutput, 'PhysicalMaterial'),
            ('emissiveTexture', None, FieldType.SFNode, AccessType.inputOutput, 'PhysicalMaterial'),
            ('metallicRoughnessTexture', None, FieldType.SFNode, AccessType.inputOutput, 'PhysicalMaterial'),
            ('normalTexture', None, FieldType.SFNode, AccessType.inputOutput, 'PhysicalMaterial'),
            ('occlusionTexture', None, FieldType.SFNode, AccessType.inputOutput, 'PhysicalMaterial'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 baseColor=(1, 1, 1),
                 baseTextureMapping='',
                 emissiveColor=(0, 0, 0),
                 emissiveTextureMapping='',
                 metallic=1,
                 metallicRoughnessTextureMapping='',
                 normalScale=1,
                 normalTextureMapping='',
                 occlusionStrength=1,
                 occlusionTextureMapping='',
                 roughness=1,
                 transparency=0,
                 baseTexture=None,
                 emissiveTexture=None,
                 metallicRoughnessTexture=None,
                 normalTexture=None,
                 occlusionTexture=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PhysicalMaterial __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.baseColor = baseColor
        self.baseTextureMapping = baseTextureMapping
        self.emissiveColor = emissiveColor
        self.emissiveTextureMapping = emissiveTextureMapping
        self.metallic = metallic
        self.metallicRoughnessTextureMapping = metallicRoughnessTextureMapping
        self.normalScale = normalScale
        self.normalTextureMapping = normalTextureMapping
        self.occlusionStrength = occlusionStrength
        self.occlusionTextureMapping = occlusionTextureMapping
        self.roughness = roughness
        self.transparency = transparency
        self.baseTexture = baseTexture
        self.emissiveTexture = emissiveTexture
        self.metallicRoughnessTexture = metallicRoughnessTexture
        self.normalTexture = normalTexture
        self.occlusionTexture = occlusionTexture
    @property # getter - - - - - - - - - -
    def baseColor(self):
        """[0,1] similar to diffuseColor, TODO define more precisely."""
        return self.__baseColor
    @baseColor.setter
    def baseColor(self, baseColor):
        if  baseColor is None:
            baseColor = (1, 1, 1) # default
        assertValidSFColor(baseColor)
        assertZeroToOne('baseColor', baseColor)
        self.__baseColor = baseColor
    @property # getter - - - - - - - - - -
    def baseTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__baseTextureMapping
    @baseTextureMapping.setter
    def baseTextureMapping(self, baseTextureMapping):
        if  baseTextureMapping is None:
            baseTextureMapping = SFString.DEFAULT_VALUE(self)
        assertValidSFString(baseTextureMapping)
        self.__baseTextureMapping = baseTextureMapping
    @property # getter - - - - - - - - - -
    def emissiveColor(self):
        """[0,1] how much glowing light is emitted from this object."""
        return self.__emissiveColor
    @emissiveColor.setter
    def emissiveColor(self, emissiveColor):
        if  emissiveColor is None:
            emissiveColor = (0, 0, 0) # default
        assertValidSFColor(emissiveColor)
        assertZeroToOne('emissiveColor', emissiveColor)
        self.__emissiveColor = emissiveColor
    @property # getter - - - - - - - - - -
    def emissiveTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__emissiveTextureMapping
    @emissiveTextureMapping.setter
    def emissiveTextureMapping(self, emissiveTextureMapping):
        if  emissiveTextureMapping is None:
            emissiveTextureMapping = SFString.DEFAULT_VALUE(self)
        assertValidSFString(emissiveTextureMapping)
        self.__emissiveTextureMapping = emissiveTextureMapping
    @property # getter - - - - - - - - - -
    def metallic(self):
        """[0,1] metallic is a PBR parameter (TODO elaborate)."""
        return self.__metallic
    @metallic.setter
    def metallic(self, metallic):
        if  metallic is None:
            metallic = 1 # default
        assertValidSFFloat(metallic)
        assertZeroToOne('metallic', metallic)
        self.__metallic = metallic
    @property # getter - - - - - - - - - -
    def metallicRoughnessTextureMapping(self):
        return self.__metallicRoughnessTextureMapping
    @metallicRoughnessTextureMapping.setter
    def metallicRoughnessTextureMapping(self, metallicRoughnessTextureMapping):
        if  metallicRoughnessTextureMapping is None:
            metallicRoughnessTextureMapping = SFString.DEFAULT_VALUE(self)
        assertValidSFString(metallicRoughnessTextureMapping)
        self.__metallicRoughnessTextureMapping = metallicRoughnessTextureMapping
    @property # getter - - - - - - - - - -
    def normalScale(self):
        """[0,infinity] normalScale controls the degree to which normalTexture RGB values apply XYZ-normal bump mapping to pixels in the parent material."""
        return self.__normalScale
    @normalScale.setter
    def normalScale(self, normalScale):
        if  normalScale is None:
            normalScale = 1 # default
        assertValidSFFloat(normalScale)
        assertNonNegative('normalScale', normalScale)
        self.__normalScale = normalScale
    @property # getter - - - - - - - - - -
    def normalTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__normalTextureMapping
    @normalTextureMapping.setter
    def normalTextureMapping(self, normalTextureMapping):
        if  normalTextureMapping is None:
            normalTextureMapping = SFString.DEFAULT_VALUE(self)
        assertValidSFString(normalTextureMapping)
        self.__normalTextureMapping = normalTextureMapping
    @property # getter - - - - - - - - - -
    def occlusionStrength(self):
        """[0,1] occlusionStrength indicates areas of indirect lighting, typically called ambient occlusion."""
        return self.__occlusionStrength
    @occlusionStrength.setter
    def occlusionStrength(self, occlusionStrength):
        if  occlusionStrength is None:
            occlusionStrength = 1 # default
        assertValidSFFloat(occlusionStrength)
        assertZeroToOne('occlusionStrength', occlusionStrength)
        self.__occlusionStrength = occlusionStrength
    @property # getter - - - - - - - - - -
    def occlusionTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__occlusionTextureMapping
    @occlusionTextureMapping.setter
    def occlusionTextureMapping(self, occlusionTextureMapping):
        if  occlusionTextureMapping is None:
            occlusionTextureMapping = SFString.DEFAULT_VALUE(self)
        assertValidSFString(occlusionTextureMapping)
        self.__occlusionTextureMapping = occlusionTextureMapping
    @property # getter - - - - - - - - - -
    def roughness(self):
        """[0,1] roughness is a PBR parameter (TODO elaborate)."""
        return self.__roughness
    @roughness.setter
    def roughness(self, roughness):
        if  roughness is None:
            roughness = 1 # default
        assertValidSFFloat(roughness)
        assertZeroToOne('roughness', roughness)
        self.__roughness = roughness
    @property # getter - - - - - - - - - -
    def transparency(self):
        """[0,1] how "clear" an object is: 1."""
        return self.__transparency
    @transparency.setter
    def transparency(self, transparency):
        if  transparency is None:
            transparency = 0 # default
        assertValidSFFloat(transparency)
        assertZeroToOne('transparency', transparency)
        self.__transparency = transparency
    @property # getter - - - - - - - - - -
    def baseTexture(self):
        """[X3DSingleTextureNode] When applying baseColor for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__baseTexture
    @baseTexture.setter
    def baseTexture(self, baseTexture):
        if  baseTexture is None:
            baseTexture = None # default
        assertValidSFNode(baseTexture)
        if not isinstance(baseTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(baseTexture) + ' does not have a valid node type object')
        self.__baseTexture = baseTexture
    @property # getter - - - - - - - - - -
    def emissiveTexture(self):
        """[X3DSingleTextureNode] When applying emissiveColor for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__emissiveTexture
    @emissiveTexture.setter
    def emissiveTexture(self, emissiveTexture):
        if  emissiveTexture is None:
            emissiveTexture = None # default
        assertValidSFNode(emissiveTexture)
        if not isinstance(emissiveTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(emissiveTexture) + ' does not have a valid node type object')
        self.__emissiveTexture = emissiveTexture
    @property # getter - - - - - - - - - -
    def metallicRoughnessTexture(self):
        return self.__metallicRoughnessTexture
    @metallicRoughnessTexture.setter
    def metallicRoughnessTexture(self, metallicRoughnessTexture):
        if  metallicRoughnessTexture is None:
            metallicRoughnessTexture = None # default
        assertValidSFNode(metallicRoughnessTexture)
        if not isinstance(metallicRoughnessTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(metallicRoughnessTexture) + ' does not have a valid node type object')
        self.__metallicRoughnessTexture = metallicRoughnessTexture
    @property # getter - - - - - - - - - -
    def normalTexture(self):
        """[X3DSingleTextureNode] When applying normalScale for this material node, the contained texture modulates the texture across the surface."""
        return self.__normalTexture
    @normalTexture.setter
    def normalTexture(self, normalTexture):
        if  normalTexture is None:
            normalTexture = None # default
        assertValidSFNode(normalTexture)
        if not isinstance(normalTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(normalTexture) + ' does not have a valid node type object')
        self.__normalTexture = normalTexture
    @property # getter - - - - - - - - - -
    def occlusionTexture(self):
        """[X3DSingleTextureNode] When applying occlusionStrength for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__occlusionTexture
    @occlusionTexture.setter
    def occlusionTexture(self, occlusionTexture):
        if  occlusionTexture is None:
            occlusionTexture = None # default
        assertValidSFNode(occlusionTexture)
        if not isinstance(occlusionTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(occlusionTexture) + ' does not have a valid node type object')
        self.__occlusionTexture = occlusionTexture
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.baseTexture or self.emissiveTexture or self.IS or self.metadata or self.metallicRoughnessTexture or self.normalTexture or self.occlusionTexture
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PhysicalMaterial.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PhysicalMaterial'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.baseColor != (1, 1, 1):
            result += " baseColor='" + SFColor(self.baseColor).XML() + "'"
        if self.baseTextureMapping:
            result += " baseTextureMapping='" + self.baseTextureMapping + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.emissiveColor != (0, 0, 0):
            result += " emissiveColor='" + SFColor(self.emissiveColor).XML() + "'"
        if self.emissiveTextureMapping:
            result += " emissiveTextureMapping='" + self.emissiveTextureMapping + "'"
        if self.metallic != 1:
            result += " metallic='" + SFFloat(self.metallic).XML() + "'"
        if self.metallicRoughnessTextureMapping:
            result += " metallicRoughnessTextureMapping='" + self.metallicRoughnessTextureMapping + "'"
        if self.normalScale != 1:
            result += " normalScale='" + SFFloat(self.normalScale).XML() + "'"
        if self.normalTextureMapping:
            result += " normalTextureMapping='" + self.normalTextureMapping + "'"
        if self.occlusionStrength != 1:
            result += " occlusionStrength='" + SFFloat(self.occlusionStrength).XML() + "'"
        if self.occlusionTextureMapping:
            result += " occlusionTextureMapping='" + self.occlusionTextureMapping + "'"
        if self.roughness != 1:
            result += " roughness='" + SFFloat(self.roughness).XML() + "'"
        if self.transparency != 0:
            result += " transparency='" + SFFloat(self.transparency).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PhysicalMaterial>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.baseTexture: # output this SFNode
                result += self.baseTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.emissiveTexture: # output this SFNode
                result += self.emissiveTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metallicRoughnessTexture: # output this SFNode
                result += self.metallicRoughnessTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.normalTexture: # output this SFNode
                result += self.normalTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.occlusionTexture: # output this SFNode
                result += self.occlusionTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PhysicalMaterial>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PhysicalMaterial.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PhysicalMaterial' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PhysicalMaterial' + ' {'
        if self.baseColor != (1, 1, 1):
            result += " baseColor " + SFColor(self.baseColor).VRML() + ""
        if self.baseTextureMapping:
            result += " baseTextureMapping " +  '"' + self.baseTextureMapping + '"' + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.emissiveColor != (0, 0, 0):
            result += " emissiveColor " + SFColor(self.emissiveColor).VRML() + ""
        if self.emissiveTextureMapping:
            result += " emissiveTextureMapping " +  '"' + self.emissiveTextureMapping + '"' + ""
        if self.metallic != 1:
            result += " metallic " + SFFloat(self.metallic).VRML() + ""
        if self.metallicRoughnessTextureMapping:
            result += " metallicRoughnessTextureMapping " +  '"' + self.metallicRoughnessTextureMapping + '"' + ""
        if self.normalScale != 1:
            result += " normalScale " + SFFloat(self.normalScale).VRML() + ""
        if self.normalTextureMapping:
            result += " normalTextureMapping " +  '"' + self.normalTextureMapping + '"' + ""
        if self.occlusionStrength != 1:
            result += " occlusionStrength " + SFFloat(self.occlusionStrength).VRML() + ""
        if self.occlusionTextureMapping:
            result += " occlusionTextureMapping " +  '"' + self.occlusionTextureMapping + '"' + ""
        if self.roughness != 1:
            result += " roughness " + SFFloat(self.roughness).VRML() + ""
        if self.transparency != 0:
            result += " transparency " + SFFloat(self.transparency).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.baseTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'baseTexture ' + self.baseTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.emissiveTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'emissiveTexture ' + self.emissiveTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metallicRoughnessTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'metallicRoughnessTexture ' + self.metallicRoughnessTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.normalTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'normalTexture ' + self.normalTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.occlusionTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'occlusionTexture ' + self.occlusionTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PickableGroup(_X3DGroupingNode, _X3DPickableObject):
    """
    PickableGroup is a Grouping node that can contain most nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PickableGroup'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/picking.html#PickableGroup'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PickableGroup'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('objectType', ["ALL"], FieldType.MFString, AccessType.inputOutput, 'X3DPickableObject'),
            ('pickable', True, FieldType.SFBool, AccessType.inputOutput, 'X3DPickableObject'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 objectType=["ALL"],
                 pickable=True,
                 visible=True,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PickableGroup __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.objectType = objectType
        self.pickable = pickable
        self.visible = visible
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def objectType(self):
        """The objectType field specifies a set of labels used in the picking process."""
        return self.__objectType
    @objectType.setter
    def objectType(self, objectType):
        if  objectType is None:
            objectType = ["ALL"] # default
        assertValidMFString(objectType)
        self.__objectType = objectType
    @property # getter - - - - - - - - - -
    def pickable(self):
        """The pickable field determines whether pick traversal is performed on this node or its children."""
        return self.__pickable
    @pickable.setter
    def pickable(self, pickable):
        if  pickable is None:
            pickable = True # default
        assertValidSFBool(pickable)
        self.__pickable = pickable
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PickableGroup.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PickableGroup'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.objectType != ["ALL"]:
            result += " objectType='" + MFString(self.objectType).XML() + "'"
        if not self.pickable: # default=true
            result += " pickable='" + SFBool(self.pickable).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PickableGroup>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* PickableGroup found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PickableGroup>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PickableGroup.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PickableGroup' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PickableGroup' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.objectType != ["ALL"]:
            result += " objectType " + MFString(self.objectType).VRML() + ""
        if not self.pickable: # default=true
            result += " pickable " + SFBool(self.pickable).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PixelTexture(_X3DTexture2DNode):
    """
    PixelTexture creates a 2D-image texture map using a numeric array of pixel values.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PixelTexture'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texturing.html#PixelTexture'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PixelTexture'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureNode'),
            ('image', [0, 0, 0], FieldType.SFImage, AccessType.inputOutput, 'PixelTexture'),
            ('repeatS', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture2DNode'),
            ('repeatT', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture2DNode'),
            ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly, 'X3DTexture2DNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 image=[0, 0, 0],
                 repeatS=True,
                 repeatT=True,
                 textureProperties=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PixelTexture __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.image = image
        self.repeatS = repeatS
        self.repeatT = repeatT
        self.textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def image(self):
        """Defines image: width, height, number_of_components per each pixel value, and list of pixel_values."""
        return self.__image
    @image.setter
    def image(self, image):
        if  image is None:
            image = [0, 0, 0] # default
        assertValidSFImage(image)
        self.__image = image
    @property # getter - - - - - - - - - -
    def repeatS(self):
        """Whether to horizontally repeat texture along S axis."""
        return self.__repeatS
    @repeatS.setter
    def repeatS(self, repeatS):
        if  repeatS is None:
            repeatS = True # default
        assertValidSFBool(repeatS)
        self.__repeatS = repeatS
    @property # getter - - - - - - - - - -
    def repeatT(self):
        """Whether to vertically repeat texture along T axis."""
        return self.__repeatT
    @repeatT.setter
    def repeatT(self, repeatT):
        if  repeatT is None:
            repeatT = True # default
        assertValidSFBool(repeatT)
        self.__repeatT = repeatT
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties):
        if  textureProperties is None:
            textureProperties = None # default
        assertValidSFNode(textureProperties)
        if not isinstance(textureProperties, object):
            # print(flush=True)
            raise X3DTypeError(str(textureProperties) + ' does not have a valid node type object')
        self.__textureProperties = textureProperties
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.textureProperties
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PixelTexture.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PixelTexture'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.image != [0, 0, 0]:
            result += " image='" + SFImage(self.image).XML() + "'"
        if not self.repeatS: # default=true
            result += " repeatS='" + SFBool(self.repeatS).XML() + "'"
        if not self.repeatT: # default=true
            result += " repeatT='" + SFBool(self.repeatT).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PixelTexture>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.textureProperties: # output this SFNode
                result += self.textureProperties.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PixelTexture>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PixelTexture.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PixelTexture' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PixelTexture' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.image != [0, 0, 0]:
            result += " image " + SFImage(self.image).VRML() + ""
        if not self.repeatS: # default=true
            result += " repeatS " + SFBool(self.repeatS).VRML() + ""
        if not self.repeatT: # default=true
            result += " repeatT " + SFBool(self.repeatT).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.textureProperties: # output this SFNode
            result += '\n' + '  ' + indent + 'textureProperties ' + self.textureProperties.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PixelTexture3D(_X3DTexture3DNode):
    """
    PixelTexture3D defines a 3D image-based texture map as an explicit array of pixel values (image field).
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PixelTexture3D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texture3D.html#PixelTexture3D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PixelTexture3D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureNode'),
            ('image', [0, 0, 0, 0], FieldType.MFInt32, AccessType.inputOutput, 'PixelTexture3D'),
            ('repeatR', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture3DNode'),
            ('repeatS', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture3DNode'),
            ('repeatT', False, FieldType.SFBool, AccessType.initializeOnly, 'X3DTexture3DNode'),
            ('textureProperties', None, FieldType.SFNode, AccessType.initializeOnly, 'X3DTexture3DNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 image=[0, 0, 0, 0],
                 repeatR=False,
                 repeatS=False,
                 repeatT=False,
                 textureProperties=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PixelTexture3D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.image = image
        self.repeatR = repeatR
        self.repeatS = repeatS
        self.repeatT = repeatT
        self.textureProperties = textureProperties
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def image(self):
        """image describes raw data for this 3D texture: number of components to the image [0,4], width, height and depth of the texture, followed by (width x height x depth) pixel values."""
        return self.__image
    @image.setter
    def image(self, image):
        if  image is None:
            image = [0, 0, 0, 0] # default
        assertValidMFInt32(image)
        self.__image = image
    @property # getter - - - - - - - - - -
    def repeatR(self):
        """Whether to vertically repeat texture along R axis."""
        return self.__repeatR
    @repeatR.setter
    def repeatR(self, repeatR):
        if  repeatR is None:
            repeatR = False # default
        assertValidSFBool(repeatR)
        self.__repeatR = repeatR
    @property # getter - - - - - - - - - -
    def repeatS(self):
        """Whether to horizontally repeat texture along S axis."""
        return self.__repeatS
    @repeatS.setter
    def repeatS(self, repeatS):
        if  repeatS is None:
            repeatS = False # default
        assertValidSFBool(repeatS)
        self.__repeatS = repeatS
    @property # getter - - - - - - - - - -
    def repeatT(self):
        """Whether to vertically repeat texture along T axis."""
        return self.__repeatT
    @repeatT.setter
    def repeatT(self, repeatT):
        if  repeatT is None:
            repeatT = False # default
        assertValidSFBool(repeatT)
        self.__repeatT = repeatT
    @property # getter - - - - - - - - - -
    def textureProperties(self):
        return self.__textureProperties
    @textureProperties.setter
    def textureProperties(self, textureProperties):
        if  textureProperties is None:
            textureProperties = None # default
        assertValidSFNode(textureProperties)
        if not isinstance(textureProperties, object):
            # print(flush=True)
            raise X3DTypeError(str(textureProperties) + ' does not have a valid node type object')
        self.__textureProperties = textureProperties
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.textureProperties
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PixelTexture3D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PixelTexture3D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.image != [0, 0, 0, 0]:
            result += " image='" + MFInt32(self.image).XML() + "'"
        if self.repeatR: # default=false
            result += " repeatR='" + SFBool(self.repeatR).XML() + "'"
        if self.repeatS: # default=false
            result += " repeatS='" + SFBool(self.repeatS).XML() + "'"
        if self.repeatT: # default=false
            result += " repeatT='" + SFBool(self.repeatT).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PixelTexture3D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.textureProperties: # output this SFNode
                result += self.textureProperties.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PixelTexture3D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PixelTexture3D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PixelTexture3D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PixelTexture3D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.image != [0, 0, 0, 0]:
            result += " image " + MFInt32(self.image).VRML() + ""
        if self.repeatR: # default=false
            result += " repeatR " + SFBool(self.repeatR).VRML() + ""
        if self.repeatS: # default=false
            result += " repeatS " + SFBool(self.repeatS).VRML() + ""
        if self.repeatT: # default=false
            result += " repeatT " + SFBool(self.repeatT).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.textureProperties: # output this SFNode
            result += '\n' + '  ' + indent + 'textureProperties ' + self.textureProperties.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PlaneSensor(_X3DDragSensorNode):
    """
    PlaneSensor converts pointing device motion into 2D translation parallel to the local Z=0 plane.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PlaneSensor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/pointingDeviceSensor.html#PlaneSensor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PlaneSensor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('autoOffset', True, FieldType.SFBool, AccessType.inputOutput, 'X3DDragSensorNode'),
            ('axisRotation', (0, 1, 0, 0), FieldType.SFRotation, AccessType.inputOutput, 'PlaneSensor'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DPointingDeviceSensorNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('maxPosition', (-1, -1), FieldType.SFVec2f, AccessType.inputOutput, 'PlaneSensor'),
            ('minPosition', (0, 0), FieldType.SFVec2f, AccessType.inputOutput, 'PlaneSensor'),
            ('offset', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'PlaneSensor'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 autoOffset=True,
                 axisRotation=(0, 1, 0, 0),
                 description='',
                 enabled=True,
                 maxPosition=(-1, -1),
                 minPosition=(0, 0),
                 offset=(0, 0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PlaneSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.autoOffset = autoOffset
        self.axisRotation = axisRotation
        self.description = description
        self.enabled = enabled
        self.maxPosition = maxPosition
        self.minPosition = minPosition
        self.offset = offset
    @property # getter - - - - - - - - - -
    def autoOffset(self):
        """Determines whether previous offset values are remembered/accumulated."""
        return self.__autoOffset
    @autoOffset.setter
    def autoOffset(self, autoOffset):
        if  autoOffset is None:
            autoOffset = True # default
        assertValidSFBool(autoOffset)
        self.__autoOffset = autoOffset
    @property # getter - - - - - - - - - -
    def axisRotation(self):
        """axisRotation determines local sensor coordinate system by rotating the local coordinate system."""
        return self.__axisRotation
    @axisRotation.setter
    def axisRotation(self, axisRotation):
        if  axisRotation is None:
            axisRotation = (0, 1, 0, 0) # default
        assertValidSFRotation(axisRotation)
        self.__axisRotation = axisRotation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def maxPosition(self):
        """minPosition and maxPosition clamp translations to a range of values measured from origin of Z=0 plane default maxPosition < minPosition means no clamping."""
        return self.__maxPosition
    @maxPosition.setter
    def maxPosition(self, maxPosition):
        if  maxPosition is None:
            maxPosition = (-1, -1) # default
        assertValidSFVec2f(maxPosition)
        self.__maxPosition = maxPosition
    @property # getter - - - - - - - - - -
    def minPosition(self):
        """minPosition and maxPosition clamp translations to a range of values measured from origin of Z=0 plane default maxPosition < minPosition means no clamping."""
        return self.__minPosition
    @minPosition.setter
    def minPosition(self, minPosition):
        if  minPosition is None:
            minPosition = (0, 0) # default
        assertValidSFVec2f(minPosition)
        self.__minPosition = minPosition
    @property # getter - - - - - - - - - -
    def offset(self):
        """Sends event and remembers last value sensed."""
        return self.__offset
    @offset.setter
    def offset(self, offset):
        if  offset is None:
            offset = (0, 0, 0) # default
        assertValidSFVec3f(offset)
        self.__offset = offset
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PlaneSensor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PlaneSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.autoOffset: # default=true
            result += " autoOffset='" + SFBool(self.autoOffset).XML() + "'"
        if self.axisRotation != (0, 1, 0, 0):
            result += " axisRotation='" + SFRotation(self.axisRotation).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.maxPosition != (-1, -1):
            result += " maxPosition='" + SFVec2f(self.maxPosition).XML() + "'"
        if self.minPosition != (0, 0):
            result += " minPosition='" + SFVec2f(self.minPosition).XML() + "'"
        if self.offset != (0, 0, 0):
            result += " offset='" + SFVec3f(self.offset).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PlaneSensor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PlaneSensor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PlaneSensor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PlaneSensor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PlaneSensor' + ' {'
        if not self.autoOffset: # default=true
            result += " autoOffset " + SFBool(self.autoOffset).VRML() + ""
        if self.axisRotation != (0, 1, 0, 0):
            result += " axisRotation " + SFRotation(self.axisRotation).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.maxPosition != (-1, -1):
            result += " maxPosition " + SFVec2f(self.maxPosition).VRML() + ""
        if self.minPosition != (0, 0):
            result += " minPosition " + SFVec2f(self.minPosition).VRML() + ""
        if self.offset != (0, 0, 0):
            result += " offset " + SFVec3f(self.offset).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PointEmitter(_X3DParticleEmitterNode):
    """
    PointEmitter generates particles from a specific point in space using the specified direction and speed.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PointEmitter'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/particleSystems.html#PointEmitter'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PointEmitter'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('direction', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'PointEmitter'),
            ('mass', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('position', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'PointEmitter'),
            ('speed', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('surfaceArea', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('variation', 0.25, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 direction=(0, 1, 0),
                 mass=0,
                 position=(0, 0, 0),
                 speed=0,
                 surfaceArea=0,
                 variation=0.25,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PointEmitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.direction = direction
        self.mass = mass
        self.position = position
        self.speed = speed
        self.surfaceArea = surfaceArea
        self.variation = variation
    @property # getter - - - - - - - - - -
    def direction(self):
        """Initial direction from which particles emanate."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 1, 0) # default
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def mass(self):
        """[0,+infinity) Basic mass of each particle, defined in mass base units (default is kilograms)."""
        return self.__mass
    @mass.setter
    def mass(self, mass):
        if  mass is None:
            mass = 0 # default
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def position(self):
        """Point from which particles emanate."""
        return self.__position
    @position.setter
    def position(self, position):
        if  position is None:
            position = (0, 0, 0) # default
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def speed(self):
        """[0,+infinity) Initial linear speed (default is m/s) imparted to all particles along their direction of movement."""
        return self.__speed
    @speed.setter
    def speed(self, speed):
        if  speed is None:
            speed = 0 # default
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def surfaceArea(self):
        """[0,+infinity) Particle surface area in area base units (default is meters squared)."""
        return self.__surfaceArea
    @surfaceArea.setter
    def surfaceArea(self, surfaceArea):
        if  surfaceArea is None:
            surfaceArea = 0 # default
        assertValidSFFloat(surfaceArea)
        assertNonNegative('surfaceArea', surfaceArea)
        self.__surfaceArea = surfaceArea
    @property # getter - - - - - - - - - -
    def variation(self):
        """[0,+infinity) Multiplier for the randomness used to control the range of possible output values."""
        return self.__variation
    @variation.setter
    def variation(self, variation):
        if  variation is None:
            variation = 0.25 # default
        assertValidSFFloat(variation)
        assertNonNegative('variation', variation)
        self.__variation = variation
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PointEmitter.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PointEmitter'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.direction != (0, 1, 0):
            result += " direction='" + SFVec3f(self.direction).XML() + "'"
        if self.mass != 0:
            result += " mass='" + SFFloat(self.mass).XML() + "'"
        if self.position != (0, 0, 0):
            result += " position='" + SFVec3f(self.position).XML() + "'"
        if self.speed != 0:
            result += " speed='" + SFFloat(self.speed).XML() + "'"
        if self.surfaceArea != 0:
            result += " surfaceArea='" + SFFloat(self.surfaceArea).XML() + "'"
        if self.variation != 0.25:
            result += " variation='" + SFFloat(self.variation).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PointEmitter>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PointEmitter>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PointEmitter.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PointEmitter' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PointEmitter' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.direction != (0, 1, 0):
            result += " direction " + SFVec3f(self.direction).VRML() + ""
        if self.mass != 0:
            result += " mass " + SFFloat(self.mass).VRML() + ""
        if self.position != (0, 0, 0):
            result += " position " + SFVec3f(self.position).VRML() + ""
        if self.speed != 0:
            result += " speed " + SFFloat(self.speed).VRML() + ""
        if self.surfaceArea != 0:
            result += " surfaceArea " + SFFloat(self.surfaceArea).VRML() + ""
        if self.variation != 0.25:
            result += " variation " + SFFloat(self.variation).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PointLight(_X3DLightNode):
    """
    Linear attenuation may occur at level 2, full support at level 3.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PointLight'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/lighting.html#PointLight'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PointLight'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ambientIntensity', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
            ('attenuation', (1, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'PointLight'),
            ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'X3DLightNode'),
            ('global_', True, FieldType.SFBool, AccessType.inputOutput, 'PointLight'),
            ('intensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
            ('location', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'PointLight'),
            ('on', True, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
            ('radius', 100, FieldType.SFFloat, AccessType.initializeOnly, 'PointLight'),
            ('shadowIntensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
            ('shadows', False, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ambientIntensity=0,
                 attenuation=(1, 0, 0),
                 color=(1, 1, 1),
                 global_=True,
                 intensity=1,
                 location=(0, 0, 0),
                 on=True,
                 radius=100,
                 shadowIntensity=1,
                 shadows=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PointLight __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.attenuation = attenuation
        self.color = color
        self.global_ = global_
        self.intensity = intensity
        self.location = location
        self.on = on
        self.radius = radius
        self.shadowIntensity = shadowIntensity
        self.shadows = shadows
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        """[0,1] Brightness of ambient (nondirectional background) emission from the light."""
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity):
        if  ambientIntensity is None:
            ambientIntensity = 0 # default
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def attenuation(self):
        """Constant, linear-distance and squared-distance dropoff factors as radial distance increases from the source."""
        return self.__attenuation
    @attenuation.setter
    def attenuation(self, attenuation):
        if  attenuation is None:
            attenuation = (1, 0, 0) # default
        assertValidSFVec3f(attenuation)
        assertNonNegative('attenuation', attenuation)
        self.__attenuation = attenuation
    @property # getter - - - - - - - - - -
    def color(self):
        """[0,1] color of light, applied to colors of objects."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = (1, 1, 1) # default
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def global_(self): # Appended underscore to field name to avoid naming collision with Python reserved word
        return self.__global_
    @global_.setter
    def global_(self, global_):
        if  global_ is None:
            global_ = True # default
        assertValidSFBool(global_)
        self.__global_ = global_
    @property # getter - - - - - - - - - -
    def intensity(self):
        """[0,1] Brightness of direct emission from the light."""
        return self.__intensity
    @intensity.setter
    def intensity(self, intensity):
        if  intensity is None:
            intensity = 1 # default
        assertValidSFFloat(intensity)
        assertZeroToOne('intensity', intensity)
        self.__intensity = intensity
    @property # getter - - - - - - - - - -
    def location(self):
        """Position of light relative to local coordinate system."""
        return self.__location
    @location.setter
    def location(self, location):
        if  location is None:
            location = (0, 0, 0) # default
        assertValidSFVec3f(location)
        self.__location = location
    @property # getter - - - - - - - - - -
    def on(self):
        """Enables/disables this light source."""
        return self.__on
    @on.setter
    def on(self, on):
        if  on is None:
            on = True # default
        assertValidSFBool(on)
        self.__on = on
    @property # getter - - - - - - - - - -
    def radius(self):
        """Maximum effective distance of light relative to local light position, affected by ancestor scaling."""
        return self.__radius
    @radius.setter
    def radius(self, radius):
        if  radius is None:
            radius = 100 # default
        assertValidSFFloat(radius)
        assertNonNegative('radius', radius)
        self.__radius = radius
    @property # getter - - - - - - - - - -
    def shadowIntensity(self):
        """[0,1] shadowIntensity field defines how much light is obscured by shapes that cast shadows, ranging from 0 (light not obscured, no visible shadows) to 1 (light completely obscured, full-intensity shadows)."""
        return self.__shadowIntensity
    @shadowIntensity.setter
    def shadowIntensity(self, shadowIntensity):
        if  shadowIntensity is None:
            shadowIntensity = 1 # default
        assertValidSFFloat(shadowIntensity)
        assertZeroToOne('shadowIntensity', shadowIntensity)
        self.__shadowIntensity = shadowIntensity
    @property # getter - - - - - - - - - -
    def shadows(self):
        """shadows field indicates whether or not this light casts a shadow behind illuminated X3DShapeNode geometry."""
        return self.__shadows
    @shadows.setter
    def shadows(self, shadows):
        if  shadows is None:
            shadows = False # default
        assertValidSFBool(shadows)
        self.__shadows = shadows
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PointLight.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PointLight'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ambientIntensity != 0:
            result += " ambientIntensity='" + SFFloat(self.ambientIntensity).XML() + "'"
        if self.attenuation != (1, 0, 0):
            result += " attenuation='" + SFVec3f(self.attenuation).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.color != (1, 1, 1):
            result += " color='" + SFColor(self.color).XML() + "'"
        if not self.global_: # default=true
            result += " global_='" + SFBool(self.global_).XML() + "'"
        if self.intensity != 1:
            result += " intensity='" + SFFloat(self.intensity).XML() + "'"
        if self.location != (0, 0, 0):
            result += " location='" + SFVec3f(self.location).XML() + "'"
        if not self.on: # default=true
            result += " on='" + SFBool(self.on).XML() + "'"
        if self.radius != 100:
            result += " radius='" + SFFloat(self.radius).XML() + "'"
        if self.shadowIntensity != 1:
            result += " shadowIntensity='" + SFFloat(self.shadowIntensity).XML() + "'"
        if self.shadows: # default=false
            result += " shadows='" + SFBool(self.shadows).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PointLight>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PointLight>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PointLight.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PointLight' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PointLight' + ' {'
        if self.ambientIntensity != 0:
            result += " ambientIntensity " + SFFloat(self.ambientIntensity).VRML() + ""
        if self.attenuation != (1, 0, 0):
            result += " attenuation " + SFVec3f(self.attenuation).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.color != (1, 1, 1):
            result += " color " + SFColor(self.color).VRML() + ""
        if not self.global_: # default=true
            result += " global_ " + SFBool(self.global_).VRML() + ""
        if self.intensity != 1:
            result += " intensity " + SFFloat(self.intensity).VRML() + ""
        if self.location != (0, 0, 0):
            result += " location " + SFVec3f(self.location).VRML() + ""
        if not self.on: # default=true
            result += " on " + SFBool(self.on).VRML() + ""
        if self.radius != 100:
            result += " radius " + SFFloat(self.radius).VRML() + ""
        if self.shadowIntensity != 1:
            result += " shadowIntensity " + SFFloat(self.shadowIntensity).VRML() + ""
        if self.shadows: # default=false
            result += " shadows " + SFBool(self.shadows).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PointPickSensor(_X3DPickSensorNode):
    """
    PointPickSensor tests one or more pickingGeometry points in space as lying inside the provided pickTarget geometry.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PointPickSensor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/picking.html#PointPickSensor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PointPickSensor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('intersectionType', 'BOUNDS', FieldType.SFString, AccessType.initializeOnly, 'X3DPickSensorNode'),
            ('matchCriterion', 'MATCH_ANY', FieldType.SFString, AccessType.inputOutput, 'X3DPickSensorNode'),
            ('objectType', ["ALL"], FieldType.MFString, AccessType.inputOutput, 'X3DPickSensorNode'),
            ('sortOrder', 'CLOSEST', FieldType.SFString, AccessType.initializeOnly, 'X3DPickSensorNode'),
            ('pickingGeometry', None, FieldType.SFNode, AccessType.inputOutput, 'X3DPickSensorNode'),
            ('pickTarget', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DPickSensorNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 enabled=True,
                 intersectionType='BOUNDS',
                 matchCriterion='MATCH_ANY',
                 objectType=["ALL"],
                 sortOrder='CLOSEST',
                 pickingGeometry=None,
                 pickTarget=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PointPickSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.intersectionType = intersectionType
        self.matchCriterion = matchCriterion
        self.objectType = objectType
        self.sortOrder = sortOrder
        self.pickingGeometry = pickingGeometry
        self.pickTarget = pickTarget
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def intersectionType(self):
        """intersectionType specifies precision of the collision computation."""
        return self.__intersectionType
    @intersectionType.setter
    def intersectionType(self, intersectionType):
        if  intersectionType is None:
            intersectionType = 'BOUNDS' # default
        assertValidSFString(intersectionType)
        self.__intersectionType = intersectionType
    @property # getter - - - - - - - - - -
    def matchCriterion(self):
        """defines whether the intersection test (i."""
        return self.__matchCriterion
    @matchCriterion.setter
    def matchCriterion(self, matchCriterion):
        if  matchCriterion is None:
            matchCriterion = 'MATCH_ANY' # default
        assertValidSFString(matchCriterion)
        assertValidPickSensorMatchCriterion('matchCriterion', matchCriterion)
        self.__matchCriterion = matchCriterion
    @property # getter - - - - - - - - - -
    def objectType(self):
        """The objectType field specifies a set of labels used in the picking process."""
        return self.__objectType
    @objectType.setter
    def objectType(self, objectType):
        if  objectType is None:
            objectType = ["ALL"] # default
        assertValidMFString(objectType)
        self.__objectType = objectType
    @property # getter - - - - - - - - - -
    def sortOrder(self):
        """The sortOrder field determines the order provided for picked output events."""
        return self.__sortOrder
    @sortOrder.setter
    def sortOrder(self, sortOrder):
        if  sortOrder is None:
            sortOrder = 'CLOSEST' # default
        assertValidSFString(sortOrder)
        self.__sortOrder = sortOrder
    @property # getter - - - - - - - - - -
    def pickingGeometry(self):
        """[PointSet] pickingGeometry specifies the exact geometry coordinates that are used to perform the intersection testing of the picking operation."""
        return self.__pickingGeometry
    @pickingGeometry.setter
    def pickingGeometry(self, pickingGeometry):
        if  pickingGeometry is None:
            pickingGeometry = None # default
        assertValidSFNode(pickingGeometry)
        if not isinstance(pickingGeometry, object):
            # print(flush=True)
            raise X3DTypeError(str(pickingGeometry) + ' does not have a valid node type object')
        self.__pickingGeometry = pickingGeometry
    @property # getter - - - - - - - - - -
    def pickTarget(self):
        """[X3DGroupingNode|X3DShapeNode|Inline] pickTarget specifies the list of nodes against which picking operations are performed."""
        return self.__pickTarget
    @pickTarget.setter
    def pickTarget(self, pickTarget):
        if  pickTarget is None:
            pickTarget = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(pickTarget)
        self.__pickTarget = pickTarget
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.pickTarget or self.IS or self.metadata or self.pickingGeometry
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PointPickSensor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PointPickSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.intersectionType != 'BOUNDS':
            result += " intersectionType='" + self.intersectionType + "'"
        if self.matchCriterion != 'MATCH_ANY':
            result += " matchCriterion='" + self.matchCriterion + "'"
        if self.objectType != ["ALL"]:
            result += " objectType='" + MFString(self.objectType).XML() + "'"
        if self.sortOrder != 'CLOSEST':
            result += " sortOrder='" + self.sortOrder + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PointPickSensor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.pickingGeometry: # output this SFNode
                result += self.pickingGeometry.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.pickTarget: # walk each child in MFNode list, if any
            ### print('* PointPickSensor found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(pickTarget)=' + str(len(self.pickTarget)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.pickTarget:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PointPickSensor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PointPickSensor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PointPickSensor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PointPickSensor' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.intersectionType != 'BOUNDS':
            result += " intersectionType " +  '"' + self.intersectionType + '"' + ""
        if self.matchCriterion != 'MATCH_ANY':
            result += " matchCriterion " +  '"' + self.matchCriterion + '"' + ""
        if self.objectType != ["ALL"]:
            result += " objectType " + MFString(self.objectType).VRML() + ""
        if self.sortOrder != 'CLOSEST':
            result += " sortOrder " +  '"' + self.sortOrder + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.pickingGeometry: # output this SFNode
            result += '\n' + '  ' + indent + 'pickingGeometry ' + self.pickingGeometry.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.pickTarget: # walk each child in MFNode list, if any
            for each in self.pickTarget:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PointProperties(_X3DAppearanceChildNode):
    """
    PointProperties allows precise fine-grained control over the rendering style of PointSet node points inside the same Shape.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PointProperties'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://github.com/Web3DConsortium/X3D/blob/master/ISO-IEC19775/ISO-IEC19775-1/ISO-IEC19775-1v4.0/ISO-IEC19775-1v4-WD1/Part01/components/shape.html'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PointProperties'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('attenuation', (1, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'PointProperties'),
            ('pointSizeMaxValue', 1, FieldType.SFFloat, AccessType.inputOutput, 'PointProperties'),
            ('pointSizeMinValue', 1, FieldType.SFFloat, AccessType.inputOutput, 'PointProperties'),
            ('pointSizeScaleFactor', 1, FieldType.SFFloat, AccessType.inputOutput, 'PointProperties'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 attenuation=(1, 0, 0),
                 pointSizeMaxValue=1,
                 pointSizeMinValue=1,
                 pointSizeScaleFactor=1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PointProperties __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.attenuation = attenuation
        self.pointSizeMaxValue = pointSizeMaxValue
        self.pointSizeMinValue = pointSizeMinValue
        self.pointSizeScaleFactor = pointSizeScaleFactor
    @property # getter - - - - - - - - - -
    def attenuation(self):
        return self.__attenuation
    @attenuation.setter
    def attenuation(self, attenuation):
        if  attenuation is None:
            attenuation = (1, 0, 0) # default
        assertValidSFVec3f(attenuation)
        self.__attenuation = attenuation
    @property # getter - - - - - - - - - -
    def pointSizeMaxValue(self):
        """[0,+infinity) pointSizeMaxValue is maximum allowed scaling factor on nominal browser point scaling."""
        return self.__pointSizeMaxValue
    @pointSizeMaxValue.setter
    def pointSizeMaxValue(self, pointSizeMaxValue):
        if  pointSizeMaxValue is None:
            pointSizeMaxValue = 1 # default
        assertValidSFFloat(pointSizeMaxValue)
        assertNonNegative('pointSizeMaxValue', pointSizeMaxValue)
        self.__pointSizeMaxValue = pointSizeMaxValue
    @property # getter - - - - - - - - - -
    def pointSizeMinValue(self):
        """[0,+infinity) pointSizeMinValue is minimum allowed scaling factor on nominal browser point scaling."""
        return self.__pointSizeMinValue
    @pointSizeMinValue.setter
    def pointSizeMinValue(self, pointSizeMinValue):
        if  pointSizeMinValue is None:
            pointSizeMinValue = 1 # default
        assertValidSFFloat(pointSizeMinValue)
        assertNonNegative('pointSizeMinValue', pointSizeMinValue)
        self.__pointSizeMinValue = pointSizeMinValue
    @property # getter - - - - - - - - - -
    def pointSizeScaleFactor(self):
        """[1,+infinity) Nominal rendered point size is a browser-dependent minimum renderable point size, which is then multiplied by an additional pointSizeScaleFactor (which is greater than or equal to 1)."""
        return self.__pointSizeScaleFactor
    @pointSizeScaleFactor.setter
    def pointSizeScaleFactor(self, pointSizeScaleFactor):
        if  pointSizeScaleFactor is None:
            pointSizeScaleFactor = 1 # default
        assertValidSFFloat(pointSizeScaleFactor)
        assertGreaterThanEquals('pointSizeScaleFactor', pointSizeScaleFactor, 1)
        self.__pointSizeScaleFactor = pointSizeScaleFactor
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PointProperties.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PointProperties'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.attenuation != (1, 0, 0):
            result += " attenuation='" + SFVec3f(self.attenuation).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.pointSizeMaxValue != 1:
            result += " pointSizeMaxValue='" + SFFloat(self.pointSizeMaxValue).XML() + "'"
        if self.pointSizeMinValue != 1:
            result += " pointSizeMinValue='" + SFFloat(self.pointSizeMinValue).XML() + "'"
        if self.pointSizeScaleFactor != 1:
            result += " pointSizeScaleFactor='" + SFFloat(self.pointSizeScaleFactor).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PointProperties>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PointProperties>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PointProperties.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PointProperties' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PointProperties' + ' {'
        if self.attenuation != (1, 0, 0):
            result += " attenuation " + SFVec3f(self.attenuation).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.pointSizeMaxValue != 1:
            result += " pointSizeMaxValue " + SFFloat(self.pointSizeMaxValue).VRML() + ""
        if self.pointSizeMinValue != 1:
            result += " pointSizeMinValue " + SFFloat(self.pointSizeMinValue).VRML() + ""
        if self.pointSizeScaleFactor != 1:
            result += " pointSizeScaleFactor " + SFFloat(self.pointSizeScaleFactor).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PointSet(_X3DGeometryNode):
    """
    PointSet is a node that contains a set of colored 3D points, represented by contained Color|ColorRGBA and Coordinate|CoordinateDouble nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PointSet'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#PointSet'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PointSet'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('color', None, FieldType.SFNode, AccessType.inputOutput, 'PointSet'),
            ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'PointSet'),
            ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'PointSet'),
            ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'PointSet'),
            ('attrib', list(), FieldType.MFNode, AccessType.inputOutput, 'PointSet'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 attrib=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PointSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that specifies color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None # default
        assertValidSFNode(color)
        if not isinstance(color, object):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that specifies a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None # default
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that specifies depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None # default
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None # default
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that specifies list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.attrib or self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PointSet.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PointSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PointSet>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.color: # output this SFNode
                result += self.color.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.coord: # output this SFNode
                result += self.coord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.fogCoord: # output this SFNode
                result += self.fogCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.normal: # output this SFNode
                result += self.normal.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.attrib: # walk each child in MFNode list, if any
            ### print('* PointSet found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(attrib)=' + str(len(self.attrib)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.attrib:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PointSet>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PointSet.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PointSet' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PointSet' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.color: # output this SFNode
            result += '\n' + '  ' + indent + 'color ' + self.color.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.coord: # output this SFNode
            result += '\n' + '  ' + indent + 'coord ' + self.coord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.fogCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'fogCoord ' + self.fogCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.normal: # output this SFNode
            result += '\n' + '  ' + indent + 'normal ' + self.normal.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.attrib: # walk each child in MFNode list, if any
            for each in self.attrib:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Polyline2D(_X3DGeometryNode):
    """
    Polyline2D is a geometry node that defines a connected set of vertices in a contiguous set of line segments in X-Y plane.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Polyline2D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geometry2D.html#Polyline2D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Polyline2D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('lineSegments', list(), FieldType.MFVec2f, AccessType.initializeOnly, 'Polyline2D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 lineSegments=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Polyline2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.lineSegments = lineSegments
    @property # getter - - - - - - - - - -
    def lineSegments(self):
        """Coordinates of vertices connected into contiguous Polyline2D."""
        return self.__lineSegments
    @lineSegments.setter
    def lineSegments(self, lineSegments):
        if  lineSegments is None:
            lineSegments = MFVec2f.DEFAULT_VALUE(self)
        assertValidMFVec2f(lineSegments)
        self.__lineSegments = lineSegments
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Polyline2D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Polyline2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.lineSegments != list():
            result += " lineSegments='" + MFVec2f(self.lineSegments).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Polyline2D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Polyline2D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Polyline2D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Polyline2D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Polyline2D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.lineSegments != list():
            result += " lineSegments " + MFVec2f(self.lineSegments).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PolylineEmitter(_X3DParticleEmitterNode):
    """
    PolylineEmitter emits particles along a single polyline.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PolylineEmitter'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/particleSystems.html#PolylineEmitter'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PolylineEmitter'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('coordIndex', [-1], FieldType.MFInt32, AccessType.initializeOnly, 'PolylineEmitter'),
            ('direction', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'PolylineEmitter'),
            ('mass', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('speed', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('surfaceArea', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('variation', 0.25, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'PolylineEmitter'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 coordIndex=[-1],
                 direction=(0, 1, 0),
                 mass=0,
                 speed=0,
                 surfaceArea=0,
                 variation=0.25,
                 coord=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PolylineEmitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.coordIndex = coordIndex
        self.direction = direction
        self.mass = mass
        self.speed = speed
        self.surfaceArea = surfaceArea
        self.variation = variation
        self.coord = coord
    @property # getter - - - - - - - - - -
    def coordIndex(self):
        """[-1,+infinity) coordIndex indices are applied to contained Coordinate values in order to define randomly generated initial geometry of the particles."""
        return self.__coordIndex
    @coordIndex.setter
    def coordIndex(self, coordIndex):
        if  coordIndex is None:
            coordIndex = [-1] # default
        assertValidMFInt32(coordIndex)
        assertGreaterThanEquals('coordIndex', coordIndex, -1)
        self.__coordIndex = coordIndex
    @property # getter - - - - - - - - - -
    def direction(self):
        """Initial direction from which particles emanate."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 1, 0) # default
        assertValidSFVec3f(direction)
        assertGreaterThanEquals('direction', direction, -1)
        assertLessThanEquals('direction', direction, 1)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def mass(self):
        """[0,+infinity) Basic mass of each particle, defined in mass base units (default is kilograms)."""
        return self.__mass
    @mass.setter
    def mass(self, mass):
        if  mass is None:
            mass = 0 # default
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def speed(self):
        """[0,+infinity) Initial linear speed (default is m/s) imparted to all particles along their direction of movement."""
        return self.__speed
    @speed.setter
    def speed(self, speed):
        if  speed is None:
            speed = 0 # default
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def surfaceArea(self):
        """[0,+infinity) Particle surface area in area base units (default is meters squared)."""
        return self.__surfaceArea
    @surfaceArea.setter
    def surfaceArea(self, surfaceArea):
        if  surfaceArea is None:
            surfaceArea = 0 # default
        assertValidSFFloat(surfaceArea)
        assertNonNegative('surfaceArea', surfaceArea)
        self.__surfaceArea = surfaceArea
    @property # getter - - - - - - - - - -
    def variation(self):
        """[0,+infinity) Multiplier for the randomness used to control the range of possible output values."""
        return self.__variation
    @variation.setter
    def variation(self, variation):
        if  variation is None:
            variation = 0.25 # default
        assertValidSFFloat(variation)
        assertNonNegative('variation', variation)
        self.__variation = variation
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Coordinates for the line along which particles are randomly generated."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None # default
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.coord or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PolylineEmitter.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PolylineEmitter'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.coordIndex != [-1]:
            result += " coordIndex='" + MFInt32(self.coordIndex).XML() + "'"
        if self.direction != (0, 1, 0):
            result += " direction='" + SFVec3f(self.direction).XML() + "'"
        if self.mass != 0:
            result += " mass='" + SFFloat(self.mass).XML() + "'"
        if self.speed != 0:
            result += " speed='" + SFFloat(self.speed).XML() + "'"
        if self.surfaceArea != 0:
            result += " surfaceArea='" + SFFloat(self.surfaceArea).XML() + "'"
        if self.variation != 0.25:
            result += " variation='" + SFFloat(self.variation).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PolylineEmitter>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.coord: # output this SFNode
                result += self.coord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PolylineEmitter>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PolylineEmitter.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PolylineEmitter' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PolylineEmitter' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.coordIndex != [-1]:
            result += " coordIndex " + MFInt32(self.coordIndex).VRML() + ""
        if self.direction != (0, 1, 0):
            result += " direction " + SFVec3f(self.direction).VRML() + ""
        if self.mass != 0:
            result += " mass " + SFFloat(self.mass).VRML() + ""
        if self.speed != 0:
            result += " speed " + SFFloat(self.speed).VRML() + ""
        if self.surfaceArea != 0:
            result += " surfaceArea " + SFFloat(self.surfaceArea).VRML() + ""
        if self.variation != 0.25:
            result += " variation " + SFFloat(self.variation).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.coord: # output this SFNode
            result += '\n' + '  ' + indent + 'coord ' + self.coord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Polypoint2D(_X3DGeometryNode):
    """
    Polypoint2D is a geometry node that defines a set of 2D points in X-Y plane.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Polypoint2D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geometry2D.html#Polypoint2D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Polypoint2D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('point', list(), FieldType.MFVec2f, AccessType.inputOutput, 'Polypoint2D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 point=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Polypoint2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.point = point
    @property # getter - - - - - - - - - -
    def point(self):
        """2D coordinates of vertices."""
        return self.__point
    @point.setter
    def point(self, point):
        if  point is None:
            point = MFVec2f.DEFAULT_VALUE(self)
        assertValidMFVec2f(point)
        self.__point = point
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Polypoint2D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Polypoint2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.point != list():
            result += " point='" + MFVec2f(self.point).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Polypoint2D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Polypoint2D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Polypoint2D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Polypoint2D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Polypoint2D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.point != list():
            result += " point " + MFVec2f(self.point).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PositionChaser(_X3DChaserNode):
    """
    PositionChaser generates a series of position values that progressively change from initial value to destination value.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PositionChaser'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/followers.html#PositionChaser'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PositionChaser'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('duration', 1, FieldType.SFTime, AccessType.initializeOnly, 'X3DChaserNode'),
            ('initialDestination', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'PositionChaser'),
            ('initialValue', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'PositionChaser'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 duration=1,
                 initialDestination=(0, 0, 0),
                 initialValue=(0, 0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PositionChaser __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
    @property # getter - - - - - - - - - -
    def duration(self):
        """[0,+infinity) duration is the time interval for filter response in seconds."""
        return self.__duration
    @duration.setter
    def duration(self, duration):
        if  duration is None:
            duration = 1 # default
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = (0, 0, 0) # default
        assertValidSFVec3f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = (0, 0, 0) # default
        assertValidSFVec3f(initialValue)
        self.__initialValue = initialValue
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PositionChaser.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PositionChaser'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.duration != 1:
            result += " duration='" + SFTime(self.duration).XML() + "'"
        if self.initialDestination != (0, 0, 0):
            result += " initialDestination='" + SFVec3f(self.initialDestination).XML() + "'"
        if self.initialValue != (0, 0, 0):
            result += " initialValue='" + SFVec3f(self.initialValue).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PositionChaser>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PositionChaser>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PositionChaser.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PositionChaser' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PositionChaser' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.duration != 1:
            result += " duration " + SFTime(self.duration).VRML() + ""
        if self.initialDestination != (0, 0, 0):
            result += " initialDestination " + SFVec3f(self.initialDestination).VRML() + ""
        if self.initialValue != (0, 0, 0):
            result += " initialValue " + SFVec3f(self.initialValue).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PositionChaser2D(_X3DChaserNode):
    """
    PositionChaser2D generates a series of 2D position values that progressively change from initial value to destination value.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PositionChaser2D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/followers.html#PositionChaser2D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PositionChaser2D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('duration', 1, FieldType.SFTime, AccessType.initializeOnly, 'X3DChaserNode'),
            ('initialDestination', (0, 0), FieldType.SFVec2f, AccessType.initializeOnly, 'PositionChaser2D'),
            ('initialValue', (0, 0), FieldType.SFVec2f, AccessType.initializeOnly, 'PositionChaser2D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 duration=1,
                 initialDestination=(0, 0),
                 initialValue=(0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PositionChaser2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
    @property # getter - - - - - - - - - -
    def duration(self):
        """[0,+infinity) duration is the time interval for filter response in seconds."""
        return self.__duration
    @duration.setter
    def duration(self, duration):
        if  duration is None:
            duration = 1 # default
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = (0, 0) # default
        assertValidSFVec2f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = (0, 0) # default
        assertValidSFVec2f(initialValue)
        self.__initialValue = initialValue
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PositionChaser2D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PositionChaser2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.duration != 1:
            result += " duration='" + SFTime(self.duration).XML() + "'"
        if self.initialDestination != (0, 0):
            result += " initialDestination='" + SFVec2f(self.initialDestination).XML() + "'"
        if self.initialValue != (0, 0):
            result += " initialValue='" + SFVec2f(self.initialValue).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PositionChaser2D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PositionChaser2D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PositionChaser2D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PositionChaser2D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PositionChaser2D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.duration != 1:
            result += " duration " + SFTime(self.duration).VRML() + ""
        if self.initialDestination != (0, 0):
            result += " initialDestination " + SFVec2f(self.initialDestination).VRML() + ""
        if self.initialValue != (0, 0):
            result += " initialValue " + SFVec2f(self.initialValue).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PositionDamper(_X3DDamperNode):
    """
    PositionDamper generates a series of position values that progressively change from initial value to destination value.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PositionDamper'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/followers.html#PositionDamper'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PositionDamper'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('initialDestination', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'PositionDamper'),
            ('initialValue', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'PositionDamper'),
            ('order', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DDamperNode'),
            ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput, 'X3DDamperNode'),
            ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DDamperNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 initialDestination=(0, 0, 0),
                 initialValue=(0, 0, 0),
                 order=3,
                 tau=0.3,
                 tolerance=-1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PositionDamper __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = (0, 0, 0) # default
        assertValidSFVec3f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = (0, 0, 0) # default
        assertValidSFVec3f(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        """[0,5] order defines the number of internal filters (larger means smoother response, longer delay)."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3 # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        """[0,+infinity) tau is the exponential-decay time constant for filter response in seconds."""
        return self.__tau
    @tau.setter
    def tau(self, tau):
        if  tau is None:
            tau = 0.3 # default
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        """[0,+infinity) or -1."""
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance):
        if  tolerance is None:
            tolerance = -1 # default
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PositionDamper.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PositionDamper'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.initialDestination != (0, 0, 0):
            result += " initialDestination='" + SFVec3f(self.initialDestination).XML() + "'"
        if self.initialValue != (0, 0, 0):
            result += " initialValue='" + SFVec3f(self.initialValue).XML() + "'"
        if self.order != 3:
            result += " order='" + SFInt32(self.order).XML() + "'"
        if self.tau != 0.3:
            result += " tau='" + SFTime(self.tau).XML() + "'"
        if self.tolerance != -1:
            result += " tolerance='" + SFFloat(self.tolerance).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PositionDamper>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PositionDamper>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PositionDamper.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PositionDamper' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PositionDamper' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.initialDestination != (0, 0, 0):
            result += " initialDestination " + SFVec3f(self.initialDestination).VRML() + ""
        if self.initialValue != (0, 0, 0):
            result += " initialValue " + SFVec3f(self.initialValue).VRML() + ""
        if self.order != 3:
            result += " order " + SFInt32(self.order).VRML() + ""
        if self.tau != 0.3:
            result += " tau " + SFTime(self.tau).VRML() + ""
        if self.tolerance != -1:
            result += " tolerance " + SFFloat(self.tolerance).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PositionDamper2D(_X3DDamperNode):
    """
    PositionDamper2D generates a series of 2D floating-point values that progressively change from initial value to destination value.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PositionDamper2D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/followers.html#PositionDamper2D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PositionDamper2D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('initialDestination', (0, 0), FieldType.SFVec2f, AccessType.initializeOnly, 'PositionDamper2D'),
            ('initialValue', (0, 0), FieldType.SFVec2f, AccessType.initializeOnly, 'PositionDamper2D'),
            ('order', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DDamperNode'),
            ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput, 'X3DDamperNode'),
            ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DDamperNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 initialDestination=(0, 0),
                 initialValue=(0, 0),
                 order=3,
                 tau=0.3,
                 tolerance=-1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PositionDamper2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = (0, 0) # default
        assertValidSFVec2f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = (0, 0) # default
        assertValidSFVec2f(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        """[0,5] order defines the number of internal filters (larger means smoother response, longer delay)."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3 # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        """[0,+infinity) tau is the exponential-decay time constant for filter response in seconds."""
        return self.__tau
    @tau.setter
    def tau(self, tau):
        if  tau is None:
            tau = 0.3 # default
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        """[0,+infinity) or -1."""
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance):
        if  tolerance is None:
            tolerance = -1 # default
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PositionDamper2D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PositionDamper2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.initialDestination != (0, 0):
            result += " initialDestination='" + SFVec2f(self.initialDestination).XML() + "'"
        if self.initialValue != (0, 0):
            result += " initialValue='" + SFVec2f(self.initialValue).XML() + "'"
        if self.order != 3:
            result += " order='" + SFInt32(self.order).XML() + "'"
        if self.tau != 0.3:
            result += " tau='" + SFTime(self.tau).XML() + "'"
        if self.tolerance != -1:
            result += " tolerance='" + SFFloat(self.tolerance).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PositionDamper2D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PositionDamper2D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PositionDamper2D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PositionDamper2D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PositionDamper2D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.initialDestination != (0, 0):
            result += " initialDestination " + SFVec2f(self.initialDestination).VRML() + ""
        if self.initialValue != (0, 0):
            result += " initialValue " + SFVec2f(self.initialValue).VRML() + ""
        if self.order != 3:
            result += " order " + SFInt32(self.order).VRML() + ""
        if self.tau != 0.3:
            result += " tau " + SFTime(self.tau).VRML() + ""
        if self.tolerance != -1:
            result += " tolerance " + SFFloat(self.tolerance).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PositionInterpolator(_X3DInterpolatorNode):
    """
    PositionInterpolator generates a series of 3-tuple SFVec3f values.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PositionInterpolator'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/interpolators.html#PositionInterpolator'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PositionInterpolator'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('key', list(), FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
            ('keyValue', list(), FieldType.MFVec3f, AccessType.inputOutput, 'PositionInterpolator'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PositionInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFVec3f.DEFAULT_VALUE(self)
        assertValidMFVec3f(keyValue)
        self.__keyValue = keyValue
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PositionInterpolator.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PositionInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + MFFloat(self.key).XML() + "'"
        if self.keyValue != list():
            result += " keyValue='" + MFVec3f(self.keyValue).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PositionInterpolator>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PositionInterpolator>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PositionInterpolator.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PositionInterpolator' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PositionInterpolator' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.key != list():
            result += " key " + MFFloat(self.key).VRML() + ""
        if self.keyValue != list():
            result += " keyValue " + MFVec3f(self.keyValue).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PositionInterpolator2D(_X3DInterpolatorNode):
    """
    PositionInterpolator2D generates a series of SFVec2f values.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PositionInterpolator2D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/interpolators.html#PositionInterpolator2D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PositionInterpolator2D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('key', list(), FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
            ('keyValue', list(), FieldType.MFVec2f, AccessType.inputOutput, 'PositionInterpolator2D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PositionInterpolator2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFVec2f.DEFAULT_VALUE(self)
        assertValidMFVec2f(keyValue)
        self.__keyValue = keyValue
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PositionInterpolator2D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PositionInterpolator2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + MFFloat(self.key).XML() + "'"
        if self.keyValue != list():
            result += " keyValue='" + MFVec2f(self.keyValue).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PositionInterpolator2D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PositionInterpolator2D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PositionInterpolator2D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PositionInterpolator2D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PositionInterpolator2D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.key != list():
            result += " key " + MFFloat(self.key).VRML() + ""
        if self.keyValue != list():
            result += " keyValue " + MFVec2f(self.keyValue).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class PrimitivePickSensor(_X3DPickSensorNode):
    """
    If a non-uniform scale is applied to the pick sensor, correct results may require level 3 support.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'PrimitivePickSensor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/picking.html#PrimitivePickSensor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#PrimitivePickSensor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('intersectionType', 'BOUNDS', FieldType.SFString, AccessType.initializeOnly, 'X3DPickSensorNode'),
            ('matchCriterion', 'MATCH_ANY', FieldType.SFString, AccessType.inputOutput, 'X3DPickSensorNode'),
            ('objectType', ["ALL"], FieldType.MFString, AccessType.inputOutput, 'X3DPickSensorNode'),
            ('sortOrder', 'CLOSEST', FieldType.SFString, AccessType.initializeOnly, 'X3DPickSensorNode'),
            ('pickingGeometry', None, FieldType.SFNode, AccessType.inputOutput, 'X3DPickSensorNode'),
            ('pickTarget', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DPickSensorNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 enabled=True,
                 intersectionType='BOUNDS',
                 matchCriterion='MATCH_ANY',
                 objectType=["ALL"],
                 sortOrder='CLOSEST',
                 pickingGeometry=None,
                 pickTarget=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode PrimitivePickSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.intersectionType = intersectionType
        self.matchCriterion = matchCriterion
        self.objectType = objectType
        self.sortOrder = sortOrder
        self.pickingGeometry = pickingGeometry
        self.pickTarget = pickTarget
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def intersectionType(self):
        """intersectionType specifies precision of the collision computation."""
        return self.__intersectionType
    @intersectionType.setter
    def intersectionType(self, intersectionType):
        if  intersectionType is None:
            intersectionType = 'BOUNDS' # default
        assertValidSFString(intersectionType)
        self.__intersectionType = intersectionType
    @property # getter - - - - - - - - - -
    def matchCriterion(self):
        """defines whether the intersection test (i."""
        return self.__matchCriterion
    @matchCriterion.setter
    def matchCriterion(self, matchCriterion):
        if  matchCriterion is None:
            matchCriterion = 'MATCH_ANY' # default
        assertValidSFString(matchCriterion)
        assertValidPickSensorMatchCriterion('matchCriterion', matchCriterion)
        self.__matchCriterion = matchCriterion
    @property # getter - - - - - - - - - -
    def objectType(self):
        """The objectType field specifies a set of labels used in the picking process."""
        return self.__objectType
    @objectType.setter
    def objectType(self, objectType):
        if  objectType is None:
            objectType = ["ALL"] # default
        assertValidMFString(objectType)
        self.__objectType = objectType
    @property # getter - - - - - - - - - -
    def sortOrder(self):
        """The sortOrder field determines the order provided for picked output events."""
        return self.__sortOrder
    @sortOrder.setter
    def sortOrder(self, sortOrder):
        if  sortOrder is None:
            sortOrder = 'CLOSEST' # default
        assertValidSFString(sortOrder)
        self.__sortOrder = sortOrder
    @property # getter - - - - - - - - - -
    def pickingGeometry(self):
        """[Cone|Cylinder|Sphere|Box] pickingGeometry specifies the exact geometry coordinates that are used to perform the intersection testing of the picking operation."""
        return self.__pickingGeometry
    @pickingGeometry.setter
    def pickingGeometry(self, pickingGeometry):
        if  pickingGeometry is None:
            pickingGeometry = None # default
        assertValidSFNode(pickingGeometry)
        if not isinstance(pickingGeometry, object):
            # print(flush=True)
            raise X3DTypeError(str(pickingGeometry) + ' does not have a valid node type object')
        self.__pickingGeometry = pickingGeometry
    @property # getter - - - - - - - - - -
    def pickTarget(self):
        """[X3DGroupingNode|X3DShapeNode|Inline] pickTarget specifies the list of nodes against which picking operations are performed."""
        return self.__pickTarget
    @pickTarget.setter
    def pickTarget(self, pickTarget):
        if  pickTarget is None:
            pickTarget = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(pickTarget)
        self.__pickTarget = pickTarget
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.pickTarget or self.IS or self.metadata or self.pickingGeometry
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function PrimitivePickSensor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<PrimitivePickSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.intersectionType != 'BOUNDS':
            result += " intersectionType='" + self.intersectionType + "'"
        if self.matchCriterion != 'MATCH_ANY':
            result += " matchCriterion='" + self.matchCriterion + "'"
        if self.objectType != ["ALL"]:
            result += " objectType='" + MFString(self.objectType).XML() + "'"
        if self.sortOrder != 'CLOSEST':
            result += " sortOrder='" + self.sortOrder + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></PrimitivePickSensor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.pickingGeometry: # output this SFNode
                result += self.pickingGeometry.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.pickTarget: # walk each child in MFNode list, if any
            ### print('* PrimitivePickSensor found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(pickTarget)=' + str(len(self.pickTarget)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.pickTarget:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</PrimitivePickSensor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function PrimitivePickSensor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'PrimitivePickSensor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'PrimitivePickSensor' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.intersectionType != 'BOUNDS':
            result += " intersectionType " +  '"' + self.intersectionType + '"' + ""
        if self.matchCriterion != 'MATCH_ANY':
            result += " matchCriterion " +  '"' + self.matchCriterion + '"' + ""
        if self.objectType != ["ALL"]:
            result += " objectType " + MFString(self.objectType).VRML() + ""
        if self.sortOrder != 'CLOSEST':
            result += " sortOrder " +  '"' + self.sortOrder + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.pickingGeometry: # output this SFNode
            result += '\n' + '  ' + indent + 'pickingGeometry ' + self.pickingGeometry.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.pickTarget: # walk each child in MFNode list, if any
            for each in self.pickTarget:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ProgramShader(_X3DShaderNode): #  # TODO fix additional inheritance method resolution order (MRO)
    """
    ProgramShader contains no field declarations and no plain-text source code.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ProgramShader'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shaders.html#ProgramShader'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProgramShader'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('language', '', FieldType.SFString, AccessType.initializeOnly, 'X3DShaderNode'),
            ('programs', list(), FieldType.MFNode, AccessType.inputOutput, 'ProgramShader'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 language='',
                 programs=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ProgramShader __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.language = language
        self.programs = programs
    @property # getter - - - - - - - - - -
    def language(self):
        """The language field indicates to the X3D player which shading language is used."""
        return self.__language
    @language.setter
    def language(self, language):
        if  language is None:
            language = SFString.DEFAULT_VALUE(self)
        assertValidSFString(language)
        self.__language = language
    @property # getter - - - - - - - - - -
    def programs(self):
        """[ShaderProgram] ProgramShader contains zero or more ShaderProgram node instances."""
        return self.__programs
    @programs.setter
    def programs(self, programs):
        if  programs is None:
            programs = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(programs)
        self.__programs = programs
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.programs or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ProgramShader.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ProgramShader'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.language:
            result += " language='" + self.language + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ProgramShader>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.programs: # walk each child in MFNode list, if any
            ### print('* ProgramShader found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(programs)=' + str(len(self.programs)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.programs:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ProgramShader>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ProgramShader.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ProgramShader' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ProgramShader' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.language:
            result += " language " +  '"' + self.language + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.programs: # walk each child in MFNode list, if any
            for each in self.programs:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ProjectionVolumeStyle(_X3DVolumeRenderStyleNode):
    """
    ProjectionVolumeStyle uses voxel data to directly generate output color.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ProjectionVolumeStyle'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/volume.html#ProjectionVolumeStyle'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProjectionVolumeStyle'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
            ('intensityThreshold', 0, FieldType.SFFloat, AccessType.inputOutput, 'ProjectionVolumeStyle'),
            ('type', 'MAX', FieldType.SFString, AccessType.inputOutput, 'ProjectionVolumeStyle'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 enabled=True,
                 intensityThreshold=0,
                 type='MAX',
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ProjectionVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.intensityThreshold = intensityThreshold
        self.type = type
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def intensityThreshold(self):
        """[0,1] Threshold value used when type=MIN (LMIP) or type=MAX (MIP)."""
        return self.__intensityThreshold
    @intensityThreshold.setter
    def intensityThreshold(self, intensityThreshold):
        if  intensityThreshold is None:
            intensityThreshold = 0 # default
        assertValidSFFloat(intensityThreshold)
        assertZeroToOne('intensityThreshold', intensityThreshold)
        self.__intensityThreshold = intensityThreshold
    @property # getter - - - - - - - - - -
    def type(self):
        """If type=MAX then Maximum Intensity Projection (MIP) or Least MIP (LMIP) algorithm is used to generate output color."""
        return self.__type
    @type.setter
    def type(self, type):
        if  type is None:
            type = 'MAX' # default
        assertValidSFString(type)
        assertValidProjectionVolumeStyleType('type', type)
        self.__type = type
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ProjectionVolumeStyle.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ProjectionVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.intensityThreshold != 0:
            result += " intensityThreshold='" + SFFloat(self.intensityThreshold).XML() + "'"
        if self.type != 'MAX':
            result += " type='" + self.type + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ProjectionVolumeStyle>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ProjectionVolumeStyle>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ProjectionVolumeStyle.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ProjectionVolumeStyle' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ProjectionVolumeStyle' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.intensityThreshold != 0:
            result += " intensityThreshold " + SFFloat(self.intensityThreshold).VRML() + ""
        if self.type != 'MAX':
            result += " type " +  '"' + self.type + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ProtoInstance(_X3DPrototypeInstance, _X3DChildNode):
    """
    ProtoInstance can override field default values via fieldValue initializations. Non-recursive nested ProtoInstance and ProtoDeclare statements are allowed within a ProtoDeclare.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ProtoInstance'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/documents/specifications/19776-1/V3.3/Part01/concepts.html#ProtoInstanceAndFieldValueStatement'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProtoInstance'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('name', '', FieldType.SFString, AccessType.inputOutput, 'ProtoInstance'),
            ('fieldValue', list(), FieldType.MFNode, AccessType.inputOutput, 'ProtoInstance'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 name='',
                 fieldValue=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ProtoInstance __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.name = name
        self.fieldValue = fieldValue
    @property # getter - - - - - - - - - -
    def name(self):
        """name of the prototype node being instanced."""
        return self.__name
    @name.setter
    def name(self, name):
        if  name is None:
            name = SFString.DEFAULT_VALUE(self)
        assertValidSFString(name)
        self.__name = name
    @property # getter - - - - - - - - - -
    def fieldValue(self):
        """Include fieldValue statements if this ProtoInstance overrides default values in any of the original field declarations."""
        return self.__fieldValue
    @fieldValue.setter
    def fieldValue(self, fieldValue):
        if  fieldValue is None:
            fieldValue = MFNode.DEFAULT_VALUE(self)
        # TODO type-aware checks for fieldValue
        if fieldValue: # walk each child in MFNode list, if any
            for each in fieldValue:
                assertValidFieldInitializationValue(each.name, type(each.value), each.value, parent='fieldValue')
        self.__fieldValue = fieldValue
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.fieldValue or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ProtoInstance.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ProtoInstance'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.name:
            result += " name='" + self.name + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ProtoInstance>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.fieldValue: # walk each child in MFNode list, if any
            ### print('* ProtoInstance found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(fieldValue)=' + str(len(self.fieldValue)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.fieldValue:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ProtoInstance>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ProtoInstance.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ProtoInstance' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ProtoInstance' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.name:
            result += " name " +  '"' + self.name + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.fieldValue: # walk each child in MFNode list, if any
            for each in self.fieldValue:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ProximitySensor(_X3DEnvironmentalSensorNode):
    """
    ProximitySensor generates events when the viewer enters, exits and moves within a region of space (defined by a box).
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ProximitySensor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/environmentalSensor.html#ProximitySensor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ProximitySensor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'ProximitySensor'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('size', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DEnvironmentalSensorNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 center=(0, 0, 0),
                 enabled=True,
                 size=(0, 0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ProximitySensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.enabled = enabled
        self.size = size
    @property # getter - - - - - - - - - -
    def center(self):
        """Position offset from origin of local coordinate system."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0) # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def size(self):
        """[0,+infinity) size of Proximity box."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = (0, 0, 0) # default
        assertValidSFVec3f(size)
        assertNonNegative('size', size)
        self.__size = size
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ProximitySensor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ProximitySensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.center != (0, 0, 0):
            result += " center='" + SFVec3f(self.center).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.size != (0, 0, 0):
            result += " size='" + SFVec3f(self.size).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ProximitySensor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ProximitySensor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ProximitySensor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ProximitySensor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ProximitySensor' + ' {'
        if self.center != (0, 0, 0):
            result += " center " + SFVec3f(self.center).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.size != (0, 0, 0):
            result += " size " + SFVec3f(self.size).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class QuadSet(_X3DComposedGeometryNode):
    """
    QuadSet is a geometry node that defines quadrilaterals.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'QuadSet'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/CADGeometry.html#QuadSet'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#QuadSet'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('color', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('attrib', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 normalPerVertex=True,
                 solid=True,
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode QuadSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color|ColorRGBA values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that specifies color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None # default
        assertValidSFNode(color)
        if not isinstance(color, object):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that specifies a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None # default
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that specifies depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None # default
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that specifies perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None # default
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that specifies coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None # default
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that specifies list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.attrib or self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function QuadSet.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<QuadSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.ccw: # default=true
            result += " ccw='" + SFBool(self.ccw).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex='" + SFBool(self.colorPerVertex).XML() + "'"
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex='" + SFBool(self.normalPerVertex).XML() + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></QuadSet>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.color: # output this SFNode
                result += self.color.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.coord: # output this SFNode
                result += self.coord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.fogCoord: # output this SFNode
                result += self.fogCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.normal: # output this SFNode
                result += self.normal.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.texCoord: # output this SFNode
                result += self.texCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.attrib: # walk each child in MFNode list, if any
            ### print('* QuadSet found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(attrib)=' + str(len(self.attrib)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.attrib:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</QuadSet>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function QuadSet.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'QuadSet' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'QuadSet' + ' {'
        if not self.ccw: # default=true
            result += " ccw " + SFBool(self.ccw).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex " + SFBool(self.colorPerVertex).VRML() + ""
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex " + SFBool(self.normalPerVertex).VRML() + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.color: # output this SFNode
            result += '\n' + '  ' + indent + 'color ' + self.color.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.coord: # output this SFNode
            result += '\n' + '  ' + indent + 'coord ' + self.coord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.fogCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'fogCoord ' + self.fogCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.normal: # output this SFNode
            result += '\n' + '  ' + indent + 'normal ' + self.normal.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'texCoord ' + self.texCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.attrib: # walk each child in MFNode list, if any
            for each in self.attrib:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ReceiverPdu(_X3DNetworkSensorNode, _X3DBoundedObject):
    """
    ReceiverPdu is a networked Protocol Data Unit (PDU) information node that transmits the state of radio frequency (RF) receivers modeled in a simulation.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ReceiverPdu'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/dis.html#ReceiverPdu'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ReceiverPdu'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('address', 'localhost', FieldType.SFString, AccessType.inputOutput, 'ReceiverPdu'),
            ('applicationID', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('entityID', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
            ('geoCoords', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'ReceiverPdu'),
            ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'ReceiverPdu'),
            ('multicastRelayHost', '', FieldType.SFString, AccessType.inputOutput, 'ReceiverPdu'),
            ('multicastRelayPort', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
            ('networkMode', 'standAlone', FieldType.SFString, AccessType.inputOutput, 'ReceiverPdu'),
            ('port', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
            ('radioID', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
            ('readInterval', 0.1, FieldType.SFTime, AccessType.inputOutput, 'ReceiverPdu'),
            ('receivedPower', 0.0, FieldType.SFFloat, AccessType.inputOutput, 'ReceiverPdu'),
            ('receiverState', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
            ('rtpHeaderExpected', False, FieldType.SFBool, AccessType.initializeOnly, 'ReceiverPdu'),
            ('siteID', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
            ('transmitterApplicationID', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
            ('transmitterEntityID', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
            ('transmitterRadioID', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
            ('transmitterSiteID', 0, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('whichGeometry', 1, FieldType.SFInt32, AccessType.inputOutput, 'ReceiverPdu'),
            ('writeInterval', 1.0, FieldType.SFTime, AccessType.inputOutput, 'ReceiverPdu'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 address='localhost',
                 applicationID=0,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 enabled=True,
                 entityID=0,
                 geoCoords=(0, 0, 0),
                 geoSystem=["GD", "WE"],
                 multicastRelayHost='',
                 multicastRelayPort=0,
                 networkMode='standAlone',
                 port=0,
                 radioID=0,
                 readInterval=0.1,
                 receivedPower=0.0,
                 receiverState=0,
                 rtpHeaderExpected=False,
                 siteID=0,
                 transmitterApplicationID=0,
                 transmitterEntityID=0,
                 transmitterRadioID=0,
                 transmitterSiteID=0,
                 visible=True,
                 whichGeometry=1,
                 writeInterval=1.0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ReceiverPdu __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.address = address
        self.applicationID = applicationID
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.enabled = enabled
        self.entityID = entityID
        self.geoCoords = geoCoords
        self.geoSystem = geoSystem
        self.multicastRelayHost = multicastRelayHost
        self.multicastRelayPort = multicastRelayPort
        self.networkMode = networkMode
        self.port = port
        self.radioID = radioID
        self.readInterval = readInterval
        self.receivedPower = receivedPower
        self.receiverState = receiverState
        self.rtpHeaderExpected = rtpHeaderExpected
        self.siteID = siteID
        self.transmitterApplicationID = transmitterApplicationID
        self.transmitterEntityID = transmitterEntityID
        self.transmitterRadioID = transmitterRadioID
        self.transmitterSiteID = transmitterSiteID
        self.visible = visible
        self.whichGeometry = whichGeometry
        self.writeInterval = writeInterval
    @property # getter - - - - - - - - - -
    def address(self):
        """Multicast network address, or else "localhost" Example: 224."""
        return self.__address
    @address.setter
    def address(self, address):
        if  address is None:
            address = 'localhost' # default
        assertValidSFString(address)
        self.__address = address
    @property # getter - - - - - - - - - -
    def applicationID(self):
        """Each simulation application that can respond to simulation management PDUs needs to have a unique applicationID."""
        return self.__applicationID
    @applicationID.setter
    def applicationID(self, applicationID):
        if  applicationID is None:
            applicationID = 0 # default
        assertValidSFInt32(applicationID)
        self.__applicationID = applicationID
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables the sensor node."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def entityID(self):
        """EntityID unique ID for entity within that application."""
        return self.__entityID
    @entityID.setter
    def entityID(self, entityID):
        if  entityID is None:
            entityID = 0 # default
        assertValidSFInt32(entityID)
        self.__entityID = entityID
    @property # getter - - - - - - - - - -
    def geoCoords(self):
        """Geographic location (specified in current geoSystem coordinates) for children geometry (specified in relative coordinate system, in meters)."""
        return self.__geoCoords
    @geoCoords.setter
    def geoCoords(self, geoCoords):
        if  geoCoords is None:
            geoCoords = (0, 0, 0) # default
        assertValidSFVec3d(geoCoords)
        self.__geoCoords = geoCoords
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"] # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def multicastRelayHost(self):
        """Fallback server address if multicast not available locally."""
        return self.__multicastRelayHost
    @multicastRelayHost.setter
    def multicastRelayHost(self, multicastRelayHost):
        if  multicastRelayHost is None:
            multicastRelayHost = SFString.DEFAULT_VALUE(self)
        assertValidSFString(multicastRelayHost)
        self.__multicastRelayHost = multicastRelayHost
    @property # getter - - - - - - - - - -
    def multicastRelayPort(self):
        """Fallback server port if multicast not available locally."""
        return self.__multicastRelayPort
    @multicastRelayPort.setter
    def multicastRelayPort(self, multicastRelayPort):
        if  multicastRelayPort is None:
            multicastRelayPort = 0 # default
        assertValidSFInt32(multicastRelayPort)
        self.__multicastRelayPort = multicastRelayPort
    @property # getter - - - - - - - - - -
    def networkMode(self):
        """Whether this entity is ignoring the network, sending DIS packets to the network, or receiving DIS packets from the network."""
        return self.__networkMode
    @networkMode.setter
    def networkMode(self, networkMode):
        if  networkMode is None:
            networkMode = 'standAlone' # default
        assertValidSFString(networkMode)
        assertValidNetworkMode('networkMode', networkMode)
        self.__networkMode = networkMode
    @property # getter - - - - - - - - - -
    def port(self):
        """Multicast network port, for example: 3000."""
        return self.__port
    @port.setter
    def port(self, port):
        if  port is None:
            port = 0 # default
        assertValidSFInt32(port)
        self.__port = port
    @property # getter - - - - - - - - - -
    def radioID(self):
        """Identifies a particular radio within a given entity."""
        return self.__radioID
    @radioID.setter
    def radioID(self, radioID):
        if  radioID is None:
            radioID = 0 # default
        assertValidSFInt32(radioID)
        self.__radioID = radioID
    @property # getter - - - - - - - - - -
    def readInterval(self):
        """[0,+infinity) Seconds between read updates, 0 means no reading."""
        return self.__readInterval
    @readInterval.setter
    def readInterval(self, readInterval):
        if  readInterval is None:
            readInterval = 0.1 # default
        assertValidSFTime(readInterval)
        assertNonNegative('readInterval', readInterval)
        self.__readInterval = readInterval
    @property # getter - - - - - - - - - -
    def receivedPower(self):
        """receivedPower indicates radio frequency (RF) power received, in units of decibel-milliwatts (dBm), after applying any propagation loss and antenna gain."""
        return self.__receivedPower
    @receivedPower.setter
    def receivedPower(self, receivedPower):
        if  receivedPower is None:
            receivedPower = 0.0 # default
        assertValidSFFloat(receivedPower)
        self.__receivedPower = receivedPower
    @property # getter - - - - - - - - - -
    def receiverState(self):
        """receiverState indicates if receiver is currently idle or busy via one of these enumerated values: 0 = off, 1 = on but not receiving, or 2 = on and receiving."""
        return self.__receiverState
    @receiverState.setter
    def receiverState(self, receiverState):
        if  receiverState is None:
            receiverState = 0 # default
        assertValidSFInt32(receiverState)
        self.__receiverState = receiverState
    @property # getter - - - - - - - - - -
    def rtpHeaderExpected(self):
        """Whether RTP headers are prepended to DIS PDUs."""
        return self.__rtpHeaderExpected
    @rtpHeaderExpected.setter
    def rtpHeaderExpected(self, rtpHeaderExpected):
        if  rtpHeaderExpected is None:
            rtpHeaderExpected = False # default
        assertValidSFBool(rtpHeaderExpected)
        self.__rtpHeaderExpected = rtpHeaderExpected
    @property # getter - - - - - - - - - -
    def siteID(self):
        """Simulation/exercise siteID of the participating LAN or organization."""
        return self.__siteID
    @siteID.setter
    def siteID(self, siteID):
        if  siteID is None:
            siteID = 0 # default
        assertValidSFInt32(siteID)
        self.__siteID = siteID
    @property # getter - - - - - - - - - -
    def transmitterApplicationID(self):
        """Simulation/exercise transmitterApplicationID is unique for transmitter application at that site."""
        return self.__transmitterApplicationID
    @transmitterApplicationID.setter
    def transmitterApplicationID(self, transmitterApplicationID):
        if  transmitterApplicationID is None:
            transmitterApplicationID = 0 # default
        assertValidSFInt32(transmitterApplicationID)
        self.__transmitterApplicationID = transmitterApplicationID
    @property # getter - - - - - - - - - -
    def transmitterEntityID(self):
        """Simulation/exercise transmitterEntityID is a unique ID for a single entity within that application."""
        return self.__transmitterEntityID
    @transmitterEntityID.setter
    def transmitterEntityID(self, transmitterEntityID):
        if  transmitterEntityID is None:
            transmitterEntityID = 0 # default
        assertValidSFInt32(transmitterEntityID)
        self.__transmitterEntityID = transmitterEntityID
    @property # getter - - - - - - - - - -
    def transmitterRadioID(self):
        """Identifies a particular radio within a given entity."""
        return self.__transmitterRadioID
    @transmitterRadioID.setter
    def transmitterRadioID(self, transmitterRadioID):
        if  transmitterRadioID is None:
            transmitterRadioID = 0 # default
        assertValidSFInt32(transmitterRadioID)
        self.__transmitterRadioID = transmitterRadioID
    @property # getter - - - - - - - - - -
    def transmitterSiteID(self):
        """Simulation/exercise transmitterSiteID of the participating LAN or organization."""
        return self.__transmitterSiteID
    @transmitterSiteID.setter
    def transmitterSiteID(self, transmitterSiteID):
        if  transmitterSiteID is None:
            transmitterSiteID = 0 # default
        assertValidSFInt32(transmitterSiteID)
        self.__transmitterSiteID = transmitterSiteID
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def whichGeometry(self):
        """Select geometry to render: -1 for no geometry, 0 for text trace, 1 for default geometry, (optional) higher values to render different states."""
        return self.__whichGeometry
    @whichGeometry.setter
    def whichGeometry(self, whichGeometry):
        if  whichGeometry is None:
            whichGeometry = 1 # default
        assertValidSFInt32(whichGeometry)
        self.__whichGeometry = whichGeometry
    @property # getter - - - - - - - - - -
    def writeInterval(self):
        """[0,+infinity) Seconds between write updates, 0 means no writing (sending)."""
        return self.__writeInterval
    @writeInterval.setter
    def writeInterval(self, writeInterval):
        if  writeInterval is None:
            writeInterval = 1.0 # default
        assertValidSFTime(writeInterval)
        assertNonNegative('writeInterval', writeInterval)
        self.__writeInterval = writeInterval
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ReceiverPdu.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ReceiverPdu'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.address != 'localhost':
            result += " address='" + self.address + "'"
        if self.applicationID != 0:
            result += " applicationID='" + SFInt32(self.applicationID).XML() + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.entityID != 0:
            result += " entityID='" + SFInt32(self.entityID).XML() + "'"
        if self.geoCoords != (0, 0, 0):
            result += " geoCoords='" + SFVec3d(self.geoCoords).XML() + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + MFString(self.geoSystem).XML() + "'"
        if self.multicastRelayHost:
            result += " multicastRelayHost='" + self.multicastRelayHost + "'"
        if self.multicastRelayPort != 0:
            result += " multicastRelayPort='" + SFInt32(self.multicastRelayPort).XML() + "'"
        if self.networkMode != 'standAlone':
            result += " networkMode='" + self.networkMode + "'"
        if self.port != 0:
            result += " port='" + SFInt32(self.port).XML() + "'"
        if self.radioID != 0:
            result += " radioID='" + SFInt32(self.radioID).XML() + "'"
        if self.readInterval != 0.1:
            result += " readInterval='" + SFTime(self.readInterval).XML() + "'"
        if self.receivedPower != 0.0:
            result += " receivedPower='" + SFFloat(self.receivedPower).XML() + "'"
        if self.receiverState != 0:
            result += " receiverState='" + SFInt32(self.receiverState).XML() + "'"
        if self.rtpHeaderExpected: # default=false
            result += " rtpHeaderExpected='" + SFBool(self.rtpHeaderExpected).XML() + "'"
        if self.siteID != 0:
            result += " siteID='" + SFInt32(self.siteID).XML() + "'"
        if self.transmitterApplicationID != 0:
            result += " transmitterApplicationID='" + SFInt32(self.transmitterApplicationID).XML() + "'"
        if self.transmitterEntityID != 0:
            result += " transmitterEntityID='" + SFInt32(self.transmitterEntityID).XML() + "'"
        if self.transmitterRadioID != 0:
            result += " transmitterRadioID='" + SFInt32(self.transmitterRadioID).XML() + "'"
        if self.transmitterSiteID != 0:
            result += " transmitterSiteID='" + SFInt32(self.transmitterSiteID).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if self.whichGeometry != 1:
            result += " whichGeometry='" + SFInt32(self.whichGeometry).XML() + "'"
        if self.writeInterval != 1.0:
            result += " writeInterval='" + SFTime(self.writeInterval).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ReceiverPdu>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ReceiverPdu>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ReceiverPdu.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ReceiverPdu' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ReceiverPdu' + ' {'
        if self.address != 'localhost':
            result += " address " +  '"' + self.address + '"' + ""
        if self.applicationID != 0:
            result += " applicationID " + SFInt32(self.applicationID).VRML() + ""
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.entityID != 0:
            result += " entityID " + SFInt32(self.entityID).VRML() + ""
        if self.geoCoords != (0, 0, 0):
            result += " geoCoords " + SFVec3d(self.geoCoords).VRML() + ""
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem " + MFString(self.geoSystem).VRML() + ""
        if self.multicastRelayHost:
            result += " multicastRelayHost " +  '"' + self.multicastRelayHost + '"' + ""
        if self.multicastRelayPort != 0:
            result += " multicastRelayPort " + SFInt32(self.multicastRelayPort).VRML() + ""
        if self.networkMode != 'standAlone':
            result += " networkMode " +  '"' + self.networkMode + '"' + ""
        if self.port != 0:
            result += " port " + SFInt32(self.port).VRML() + ""
        if self.radioID != 0:
            result += " radioID " + SFInt32(self.radioID).VRML() + ""
        if self.readInterval != 0.1:
            result += " readInterval " + SFTime(self.readInterval).VRML() + ""
        if self.receivedPower != 0.0:
            result += " receivedPower " + SFFloat(self.receivedPower).VRML() + ""
        if self.receiverState != 0:
            result += " receiverState " + SFInt32(self.receiverState).VRML() + ""
        if self.rtpHeaderExpected: # default=false
            result += " rtpHeaderExpected " + SFBool(self.rtpHeaderExpected).VRML() + ""
        if self.siteID != 0:
            result += " siteID " + SFInt32(self.siteID).VRML() + ""
        if self.transmitterApplicationID != 0:
            result += " transmitterApplicationID " + SFInt32(self.transmitterApplicationID).VRML() + ""
        if self.transmitterEntityID != 0:
            result += " transmitterEntityID " + SFInt32(self.transmitterEntityID).VRML() + ""
        if self.transmitterRadioID != 0:
            result += " transmitterRadioID " + SFInt32(self.transmitterRadioID).VRML() + ""
        if self.transmitterSiteID != 0:
            result += " transmitterSiteID " + SFInt32(self.transmitterSiteID).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.whichGeometry != 1:
            result += " whichGeometry " + SFInt32(self.whichGeometry).VRML() + ""
        if self.writeInterval != 1.0:
            result += " writeInterval " + SFTime(self.writeInterval).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Rectangle2D(_X3DGeometryNode):
    """
    Rectangle2D is a geometry node that defines a 2D rectangle in X-Y plane.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Rectangle2D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geometry2D.html#Rectangle2D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Rectangle2D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('size', (2, 2), FieldType.SFVec2f, AccessType.initializeOnly, 'Rectangle2D'),
            ('solid', False, FieldType.SFBool, AccessType.initializeOnly, 'Rectangle2D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 size=(2, 2),
                 solid=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Rectangle2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.size = size
        self.solid = solid
    @property # getter - - - - - - - - - -
    def size(self):
        """2D dimensions of Rectangle2D."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = (2, 2) # default
        assertValidSFVec2f(size)
        assertPositive('size', size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = False # default
        assertValidSFBool(solid)
        self.__solid = solid
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Rectangle2D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Rectangle2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.size != (2, 2):
            result += " size='" + SFVec2f(self.size).XML() + "'"
        if self.solid: # default=false
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Rectangle2D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Rectangle2D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Rectangle2D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Rectangle2D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Rectangle2D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.size != (2, 2):
            result += " size " + SFVec2f(self.size).VRML() + ""
        if self.solid: # default=false
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class RigidBody(_X3DNode):
    """
    RigidBody describes a collection of shapes with a mass distribution that is affected by the physics model.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'RigidBody'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rigidBodyPhysics.html#RigidBody'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#RigidBody'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('angularDampingFactor', 0.001, FieldType.SFFloat, AccessType.inputOutput, 'RigidBody'),
            ('angularVelocity', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'RigidBody'),
            ('autoDamp', False, FieldType.SFBool, AccessType.inputOutput, 'RigidBody'),
            ('autoDisable', False, FieldType.SFBool, AccessType.inputOutput, 'RigidBody'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'RigidBody'),
            ('centerOfMass', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'RigidBody'),
            ('disableAngularSpeed', 0, FieldType.SFFloat, AccessType.inputOutput, 'RigidBody'),
            ('disableLinearSpeed', 0, FieldType.SFFloat, AccessType.inputOutput, 'RigidBody'),
            ('disableTime', 0, FieldType.SFTime, AccessType.inputOutput, 'RigidBody'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'RigidBody'),
            ('finiteRotationAxis', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'RigidBody'),
            ('fixed', False, FieldType.SFBool, AccessType.inputOutput, 'RigidBody'),
            ('forces', list(), FieldType.MFVec3f, AccessType.inputOutput, 'RigidBody'),
            ('inertia', (1, 0, 0, 0, 1, 0, 0, 0, 1), FieldType.SFMatrix3f, AccessType.inputOutput, 'RigidBody'),
            ('linearDampingFactor', 0.001, FieldType.SFFloat, AccessType.inputOutput, 'RigidBody'),
            ('linearVelocity', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'RigidBody'),
            ('mass', 1, FieldType.SFFloat, AccessType.inputOutput, 'RigidBody'),
            ('orientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'RigidBody'),
            ('position', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'RigidBody'),
            ('torques', list(), FieldType.MFVec3f, AccessType.inputOutput, 'RigidBody'),
            ('useFiniteRotation', False, FieldType.SFBool, AccessType.inputOutput, 'RigidBody'),
            ('useGlobalGravity', True, FieldType.SFBool, AccessType.inputOutput, 'RigidBody'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'RigidBody'),
            ('massDensityModel', None, FieldType.SFNode, AccessType.inputOutput, 'RigidBody'),
            ('geometry', list(), FieldType.MFNode, AccessType.inputOutput, 'RigidBody'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 angularDampingFactor=0.001,
                 angularVelocity=(0, 0, 0),
                 autoDamp=False,
                 autoDisable=False,
                 bboxDisplay=False,
                 centerOfMass=(0, 0, 0),
                 disableAngularSpeed=0,
                 disableLinearSpeed=0,
                 disableTime=0,
                 enabled=True,
                 finiteRotationAxis=(0, 1, 0),
                 fixed=False,
                 forces=list(),
                 inertia=(1, 0, 0, 0, 1, 0, 0, 0, 1),
                 linearDampingFactor=0.001,
                 linearVelocity=(0, 0, 0),
                 mass=1,
                 orientation=(0, 0, 1, 0),
                 position=(0, 0, 0),
                 torques=list(),
                 useFiniteRotation=False,
                 useGlobalGravity=True,
                 visible=True,
                 massDensityModel=None,
                 geometry=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode RigidBody __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.angularDampingFactor = angularDampingFactor
        self.angularVelocity = angularVelocity
        self.autoDamp = autoDamp
        self.autoDisable = autoDisable
        self.bboxDisplay = bboxDisplay
        self.centerOfMass = centerOfMass
        self.disableAngularSpeed = disableAngularSpeed
        self.disableLinearSpeed = disableLinearSpeed
        self.disableTime = disableTime
        self.enabled = enabled
        self.finiteRotationAxis = finiteRotationAxis
        self.fixed = fixed
        self.forces = forces
        self.inertia = inertia
        self.linearDampingFactor = linearDampingFactor
        self.linearVelocity = linearVelocity
        self.mass = mass
        self.orientation = orientation
        self.position = position
        self.torques = torques
        self.useFiniteRotation = useFiniteRotation
        self.useGlobalGravity = useGlobalGravity
        self.visible = visible
        self.massDensityModel = massDensityModel
        self.geometry = geometry
    @property # getter - - - - - - - - - -
    def angularDampingFactor(self):
        """[0,1] angularDampingFactor automatically damps a portion of body motion over time."""
        return self.__angularDampingFactor
    @angularDampingFactor.setter
    def angularDampingFactor(self, angularDampingFactor):
        if  angularDampingFactor is None:
            angularDampingFactor = 0.001 # default
        assertValidSFFloat(angularDampingFactor)
        self.__angularDampingFactor = angularDampingFactor
    @property # getter - - - - - - - - - -
    def angularVelocity(self):
        """angularVelocity sets constant velocity value to object every frame, and reports updates by physics model."""
        return self.__angularVelocity
    @angularVelocity.setter
    def angularVelocity(self, angularVelocity):
        if  angularVelocity is None:
            angularVelocity = (0, 0, 0) # default
        assertValidSFVec3f(angularVelocity)
        self.__angularVelocity = angularVelocity
    @property # getter - - - - - - - - - -
    def autoDamp(self):
        """autoDamp enables/disables angularDampingFactor and linearDampingFactor."""
        return self.__autoDamp
    @autoDamp.setter
    def autoDamp(self, autoDamp):
        if  autoDamp is None:
            autoDamp = False # default
        assertValidSFBool(autoDamp)
        self.__autoDamp = autoDamp
    @property # getter - - - - - - - - - -
    def autoDisable(self):
        """autoDisable toggles operation of disableAngularSpeed, disableLinearSpeed, disableTime."""
        return self.__autoDisable
    @autoDisable.setter
    def autoDisable(self, autoDisable):
        if  autoDisable is None:
            autoDisable = False # default
        assertValidSFBool(autoDisable)
        self.__autoDisable = autoDisable
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def centerOfMass(self):
        """centerOfMass defines local center of mass for physics calculations."""
        return self.__centerOfMass
    @centerOfMass.setter
    def centerOfMass(self, centerOfMass):
        if  centerOfMass is None:
            centerOfMass = (0, 0, 0) # default
        assertValidSFVec3f(centerOfMass)
        self.__centerOfMass = centerOfMass
    @property # getter - - - - - - - - - -
    def disableAngularSpeed(self):
        """[0,+infinity) disableAngularSpeed defines lower-limit tolerance value when body is considered at rest and not part of rigid body calculations, reducing numeric instabilities."""
        return self.__disableAngularSpeed
    @disableAngularSpeed.setter
    def disableAngularSpeed(self, disableAngularSpeed):
        if  disableAngularSpeed is None:
            disableAngularSpeed = 0 # default
        assertValidSFFloat(disableAngularSpeed)
        self.__disableAngularSpeed = disableAngularSpeed
    @property # getter - - - - - - - - - -
    def disableLinearSpeed(self):
        """[0,+infinity) disableLinearSpeed defines lower-limit tolerance value when body is considered at rest and not part of rigid body calculation, reducing numeric instabilitiess."""
        return self.__disableLinearSpeed
    @disableLinearSpeed.setter
    def disableLinearSpeed(self, disableLinearSpeed):
        if  disableLinearSpeed is None:
            disableLinearSpeed = 0 # default
        assertValidSFFloat(disableLinearSpeed)
        self.__disableLinearSpeed = disableLinearSpeed
    @property # getter - - - - - - - - - -
    def disableTime(self):
        """[0,+infinity) disableTime defines interval when body becomes at rest and not part of rigid body calculations, reducing numeric instabilities."""
        return self.__disableTime
    @disableTime.setter
    def disableTime(self, disableTime):
        if  disableTime is None:
            disableTime = 0 # default
        assertValidSFTime(disableTime)
        assertNonNegative('disableTime', disableTime)
        self.__disableTime = disableTime
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def finiteRotationAxis(self):
        """finiteRotationAxis specifies vector around which the object rotates."""
        return self.__finiteRotationAxis
    @finiteRotationAxis.setter
    def finiteRotationAxis(self, finiteRotationAxis):
        if  finiteRotationAxis is None:
            finiteRotationAxis = (0, 1, 0) # default
        assertValidSFVec3f(finiteRotationAxis)
        self.__finiteRotationAxis = finiteRotationAxis
    @property # getter - - - - - - - - - -
    def fixed(self):
        """fixed indicates whether body is able to move."""
        return self.__fixed
    @fixed.setter
    def fixed(self, fixed):
        if  fixed is None:
            fixed = False # default
        assertValidSFBool(fixed)
        self.__fixed = fixed
    @property # getter - - - - - - - - - -
    def forces(self):
        """forces defines linear force values applied to the object every frame."""
        return self.__forces
    @forces.setter
    def forces(self, forces):
        if  forces is None:
            forces = MFVec3f.DEFAULT_VALUE(self)
        assertValidMFVec3f(forces)
        self.__forces = forces
    @property # getter - - - - - - - - - -
    def inertia(self):
        """inertia matrix defines a 3x2 inertia tensor matrix."""
        return self.__inertia
    @inertia.setter
    def inertia(self, inertia):
        if  inertia is None:
            inertia = (1, 0, 0, 0, 1, 0, 0, 0, 1) # default
        assertValidSFMatrix3f(inertia)
        self.__inertia = inertia
    @property # getter - - - - - - - - - -
    def linearDampingFactor(self):
        """[0,1] linearDampingFactor automatically damps a portion of body motion over time."""
        return self.__linearDampingFactor
    @linearDampingFactor.setter
    def linearDampingFactor(self, linearDampingFactor):
        if  linearDampingFactor is None:
            linearDampingFactor = 0.001 # default
        assertValidSFFloat(linearDampingFactor)
        self.__linearDampingFactor = linearDampingFactor
    @property # getter - - - - - - - - - -
    def linearVelocity(self):
        """linearVelocity sets constant velocity value to object every frame, and reports updates by physics model."""
        return self.__linearVelocity
    @linearVelocity.setter
    def linearVelocity(self, linearVelocity):
        if  linearVelocity is None:
            linearVelocity = (0, 0, 0) # default
        assertValidSFVec3f(linearVelocity)
        self.__linearVelocity = linearVelocity
    @property # getter - - - - - - - - - -
    def mass(self):
        """(0,1] mass of the body in kilograms."""
        return self.__mass
    @mass.setter
    def mass(self, mass):
        if  mass is None:
            mass = 1 # default
        assertValidSFFloat(mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def orientation(self):
        """orientation sets body direction in world space, then reports physics updates."""
        return self.__orientation
    @orientation.setter
    def orientation(self, orientation):
        if  orientation is None:
            orientation = (0, 0, 1, 0) # default
        assertValidSFRotation(orientation)
        self.__orientation = orientation
    @property # getter - - - - - - - - - -
    def position(self):
        """position sets body location in world space, then reports physics updates."""
        return self.__position
    @position.setter
    def position(self, position):
        if  position is None:
            position = (0, 0, 0) # default
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def torques(self):
        """torques defines rotational force values applied to the object every frame."""
        return self.__torques
    @torques.setter
    def torques(self, torques):
        if  torques is None:
            torques = MFVec3f.DEFAULT_VALUE(self)
        assertValidMFVec3f(torques)
        self.__torques = torques
    @property # getter - - - - - - - - - -
    def useFiniteRotation(self):
        """useFiniteRotation enables/disables higher-resolution, higher-cost computational method for calculating rotations."""
        return self.__useFiniteRotation
    @useFiniteRotation.setter
    def useFiniteRotation(self, useFiniteRotation):
        if  useFiniteRotation is None:
            useFiniteRotation = False # default
        assertValidSFBool(useFiniteRotation)
        self.__useFiniteRotation = useFiniteRotation
    @property # getter - - - - - - - - - -
    def useGlobalGravity(self):
        """useGlobalGravity indicates whether this particular body is influenced by parent RigidBodyCollection's gravity setting."""
        return self.__useGlobalGravity
    @useGlobalGravity.setter
    def useGlobalGravity(self, useGlobalGravity):
        if  useGlobalGravity is None:
            useGlobalGravity = True # default
        assertValidSFBool(useGlobalGravity)
        self.__useGlobalGravity = useGlobalGravity
    @property # getter - - - - - - - - - -
    def visible(self):
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def massDensityModel(self):
        return self.__massDensityModel
    @massDensityModel.setter
    def massDensityModel(self, massDensityModel):
        if  massDensityModel is None:
            massDensityModel = None # default
        assertValidSFNode(massDensityModel)
        if not isinstance(massDensityModel, object):
            # print(flush=True)
            raise X3DTypeError(str(massDensityModel) + ' does not have a valid node type object')
        self.__massDensityModel = massDensityModel
    @property # getter - - - - - - - - - -
    def geometry(self):
        return self.__geometry
    @geometry.setter
    def geometry(self, geometry):
        if  geometry is None:
            geometry = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(geometry)
        self.__geometry = geometry
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.geometry or self.IS or self.massDensityModel or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function RigidBody.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<RigidBody'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.angularDampingFactor != 0.001:
            result += " angularDampingFactor='" + SFFloat(self.angularDampingFactor).XML() + "'"
        if self.angularVelocity != (0, 0, 0):
            result += " angularVelocity='" + SFVec3f(self.angularVelocity).XML() + "'"
        if self.autoDamp: # default=false
            result += " autoDamp='" + SFBool(self.autoDamp).XML() + "'"
        if self.autoDisable: # default=false
            result += " autoDisable='" + SFBool(self.autoDisable).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.centerOfMass != (0, 0, 0):
            result += " centerOfMass='" + SFVec3f(self.centerOfMass).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.disableAngularSpeed != 0:
            result += " disableAngularSpeed='" + SFFloat(self.disableAngularSpeed).XML() + "'"
        if self.disableLinearSpeed != 0:
            result += " disableLinearSpeed='" + SFFloat(self.disableLinearSpeed).XML() + "'"
        if self.disableTime != 0:
            result += " disableTime='" + SFTime(self.disableTime).XML() + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.finiteRotationAxis != (0, 1, 0):
            result += " finiteRotationAxis='" + SFVec3f(self.finiteRotationAxis).XML() + "'"
        if self.fixed: # default=false
            result += " fixed='" + SFBool(self.fixed).XML() + "'"
        if self.forces != list():
            result += " forces='" + MFVec3f(self.forces).XML() + "'"
        if self.inertia != (1, 0, 0, 0, 1, 0, 0, 0, 1):
            result += " inertia='" + SFMatrix3f(self.inertia).XML() + "'"
        if self.linearDampingFactor != 0.001:
            result += " linearDampingFactor='" + SFFloat(self.linearDampingFactor).XML() + "'"
        if self.linearVelocity != (0, 0, 0):
            result += " linearVelocity='" + SFVec3f(self.linearVelocity).XML() + "'"
        if self.mass != 1:
            result += " mass='" + SFFloat(self.mass).XML() + "'"
        if self.orientation != (0, 0, 1, 0):
            result += " orientation='" + SFRotation(self.orientation).XML() + "'"
        if self.position != (0, 0, 0):
            result += " position='" + SFVec3f(self.position).XML() + "'"
        if self.torques != list():
            result += " torques='" + MFVec3f(self.torques).XML() + "'"
        if self.useFiniteRotation: # default=false
            result += " useFiniteRotation='" + SFBool(self.useFiniteRotation).XML() + "'"
        if not self.useGlobalGravity: # default=true
            result += " useGlobalGravity='" + SFBool(self.useGlobalGravity).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></RigidBody>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.massDensityModel: # output this SFNode
                result += self.massDensityModel.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.geometry: # walk each child in MFNode list, if any
            ### print('* RigidBody found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(geometry)=' + str(len(self.geometry)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.geometry:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</RigidBody>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function RigidBody.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'RigidBody' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'RigidBody' + ' {'
        if self.angularDampingFactor != 0.001:
            result += " angularDampingFactor " + SFFloat(self.angularDampingFactor).VRML() + ""
        if self.angularVelocity != (0, 0, 0):
            result += " angularVelocity " + SFVec3f(self.angularVelocity).VRML() + ""
        if self.autoDamp: # default=false
            result += " autoDamp " + SFBool(self.autoDamp).VRML() + ""
        if self.autoDisable: # default=false
            result += " autoDisable " + SFBool(self.autoDisable).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.centerOfMass != (0, 0, 0):
            result += " centerOfMass " + SFVec3f(self.centerOfMass).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.disableAngularSpeed != 0:
            result += " disableAngularSpeed " + SFFloat(self.disableAngularSpeed).VRML() + ""
        if self.disableLinearSpeed != 0:
            result += " disableLinearSpeed " + SFFloat(self.disableLinearSpeed).VRML() + ""
        if self.disableTime != 0:
            result += " disableTime " + SFTime(self.disableTime).VRML() + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.finiteRotationAxis != (0, 1, 0):
            result += " finiteRotationAxis " + SFVec3f(self.finiteRotationAxis).VRML() + ""
        if self.fixed: # default=false
            result += " fixed " + SFBool(self.fixed).VRML() + ""
        if self.forces != list():
            result += " forces " + MFVec3f(self.forces).VRML() + ""
        if self.inertia != (1, 0, 0, 0, 1, 0, 0, 0, 1):
            result += " inertia " + SFMatrix3f(self.inertia).VRML() + ""
        if self.linearDampingFactor != 0.001:
            result += " linearDampingFactor " + SFFloat(self.linearDampingFactor).VRML() + ""
        if self.linearVelocity != (0, 0, 0):
            result += " linearVelocity " + SFVec3f(self.linearVelocity).VRML() + ""
        if self.mass != 1:
            result += " mass " + SFFloat(self.mass).VRML() + ""
        if self.orientation != (0, 0, 1, 0):
            result += " orientation " + SFRotation(self.orientation).VRML() + ""
        if self.position != (0, 0, 0):
            result += " position " + SFVec3f(self.position).VRML() + ""
        if self.torques != list():
            result += " torques " + MFVec3f(self.torques).VRML() + ""
        if self.useFiniteRotation: # default=false
            result += " useFiniteRotation " + SFBool(self.useFiniteRotation).VRML() + ""
        if not self.useGlobalGravity: # default=true
            result += " useGlobalGravity " + SFBool(self.useGlobalGravity).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.massDensityModel: # output this SFNode
            result += '\n' + '  ' + indent + 'massDensityModel ' + self.massDensityModel.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.geometry: # walk each child in MFNode list, if any
            for each in self.geometry:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class RigidBodyCollection(_X3DChildNode):
    """
    RigidBodyCollection represents a system of bodies that interact within a single physics model.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'RigidBodyCollection'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rigidBodyPhysics.html#RigidBodyCollection'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#RigidBodyCollection'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('autoDisable', False, FieldType.SFBool, AccessType.inputOutput, 'RigidBodyCollection'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'RigidBodyCollection'),
            ('constantForceMix', 0.0001, FieldType.SFFloat, AccessType.inputOutput, 'RigidBodyCollection'),
            ('contactSurfaceThickness', 0, FieldType.SFFloat, AccessType.inputOutput, 'RigidBodyCollection'),
            ('disableAngularSpeed', 0, FieldType.SFFloat, AccessType.inputOutput, 'RigidBodyCollection'),
            ('disableLinearSpeed', 0, FieldType.SFFloat, AccessType.inputOutput, 'RigidBodyCollection'),
            ('disableTime', 0, FieldType.SFTime, AccessType.inputOutput, 'RigidBodyCollection'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'RigidBodyCollection'),
            ('errorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'RigidBodyCollection'),
            ('gravity', (0, -9.8, 0), FieldType.SFVec3f, AccessType.inputOutput, 'RigidBodyCollection'),
            ('iterations', 10, FieldType.SFInt32, AccessType.inputOutput, 'RigidBodyCollection'),
            ('maxCorrectionSpeed', -1, FieldType.SFFloat, AccessType.inputOutput, 'RigidBodyCollection'),
            ('preferAccuracy', False, FieldType.SFBool, AccessType.inputOutput, 'RigidBodyCollection'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'RigidBodyCollection'),
            ('collider', None, FieldType.SFNode, AccessType.initializeOnly, 'RigidBodyCollection'),
            ('bodies', list(), FieldType.MFNode, AccessType.inputOutput, 'RigidBodyCollection'),
            ('joints', list(), FieldType.MFNode, AccessType.inputOutput, 'RigidBodyCollection'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 autoDisable=False,
                 bboxDisplay=False,
                 constantForceMix=0.0001,
                 contactSurfaceThickness=0,
                 disableAngularSpeed=0,
                 disableLinearSpeed=0,
                 disableTime=0,
                 enabled=True,
                 errorCorrection=0.8,
                 gravity=(0, -9.8, 0),
                 iterations=10,
                 maxCorrectionSpeed=-1,
                 preferAccuracy=False,
                 visible=True,
                 collider=None,
                 bodies=None,
                 joints=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode RigidBodyCollection __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.autoDisable = autoDisable
        self.bboxDisplay = bboxDisplay
        self.constantForceMix = constantForceMix
        self.contactSurfaceThickness = contactSurfaceThickness
        self.disableAngularSpeed = disableAngularSpeed
        self.disableLinearSpeed = disableLinearSpeed
        self.disableTime = disableTime
        self.enabled = enabled
        self.errorCorrection = errorCorrection
        self.gravity = gravity
        self.iterations = iterations
        self.maxCorrectionSpeed = maxCorrectionSpeed
        self.preferAccuracy = preferAccuracy
        self.visible = visible
        self.collider = collider
        self.bodies = bodies
        self.joints = joints
    @property # getter - - - - - - - - - -
    def autoDisable(self):
        """autoDisable toggles operation of disableAngularSpeed, disableLinearSpeed, disableTime."""
        return self.__autoDisable
    @autoDisable.setter
    def autoDisable(self, autoDisable):
        if  autoDisable is None:
            autoDisable = False # default
        assertValidSFBool(autoDisable)
        self.__autoDisable = autoDisable
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def constantForceMix(self):
        """[0,+infinity) constantForceMix modifies damping calculations by violating normal constraints while applying small, constant forces in those calculations."""
        return self.__constantForceMix
    @constantForceMix.setter
    def constantForceMix(self, constantForceMix):
        if  constantForceMix is None:
            constantForceMix = 0.0001 # default
        assertValidSFFloat(constantForceMix)
        self.__constantForceMix = constantForceMix
    @property # getter - - - - - - - - - -
    def contactSurfaceThickness(self):
        """[0,+infinity) contactSurfaceThickness defines how far bodies may interpenetrate after a collision, allowing simulation of softer bodies that deform somewhat during collision."""
        return self.__contactSurfaceThickness
    @contactSurfaceThickness.setter
    def contactSurfaceThickness(self, contactSurfaceThickness):
        if  contactSurfaceThickness is None:
            contactSurfaceThickness = 0 # default
        assertValidSFFloat(contactSurfaceThickness)
        self.__contactSurfaceThickness = contactSurfaceThickness
    @property # getter - - - - - - - - - -
    def disableAngularSpeed(self):
        """[0,+infinity) disableAngularSpeed defines lower-limit tolerance value when body is considered at rest and not part of rigid body calculations, reducing numeric instabilities."""
        return self.__disableAngularSpeed
    @disableAngularSpeed.setter
    def disableAngularSpeed(self, disableAngularSpeed):
        if  disableAngularSpeed is None:
            disableAngularSpeed = 0 # default
        assertValidSFFloat(disableAngularSpeed)
        self.__disableAngularSpeed = disableAngularSpeed
    @property # getter - - - - - - - - - -
    def disableLinearSpeed(self):
        """[0,+infinity) disableLinearSpeed defines lower-limit tolerance value when body is considered at rest and not part of rigid body calculation, reducing numeric instabilitiess."""
        return self.__disableLinearSpeed
    @disableLinearSpeed.setter
    def disableLinearSpeed(self, disableLinearSpeed):
        if  disableLinearSpeed is None:
            disableLinearSpeed = 0 # default
        assertValidSFFloat(disableLinearSpeed)
        self.__disableLinearSpeed = disableLinearSpeed
    @property # getter - - - - - - - - - -
    def disableTime(self):
        """[0,+infinity) disableTime defines interval when body becomes at rest and not part of rigid body calculations, reducing numeric instabilities."""
        return self.__disableTime
    @disableTime.setter
    def disableTime(self, disableTime):
        if  disableTime is None:
            disableTime = 0 # default
        assertValidSFTime(disableTime)
        assertNonNegative('disableTime', disableTime)
        self.__disableTime = disableTime
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def errorCorrection(self):
        """[0,1] errorCorrection describes how quickly intersection errors due to floating-point inaccuracies are resolved (0=no correction, 1=all corrected in single step)."""
        return self.__errorCorrection
    @errorCorrection.setter
    def errorCorrection(self, errorCorrection):
        if  errorCorrection is None:
            errorCorrection = 0.8 # default
        assertValidSFFloat(errorCorrection)
        self.__errorCorrection = errorCorrection
    @property # getter - - - - - - - - - -
    def gravity(self):
        """gravity indicates direction and strength of local gravity vector for this collection of bodies (units m/sec^2)."""
        return self.__gravity
    @gravity.setter
    def gravity(self, gravity):
        if  gravity is None:
            gravity = (0, -9.8, 0) # default
        assertValidSFVec3f(gravity)
        self.__gravity = gravity
    @property # getter - - - - - - - - - -
    def iterations(self):
        """[0,+infinity) iterations controls number of iterations performed over collectioned joints and bodies during each evaluation."""
        return self.__iterations
    @iterations.setter
    def iterations(self, iterations):
        if  iterations is None:
            iterations = 10 # default
        assertValidSFInt32(iterations)
        self.__iterations = iterations
    @property # getter - - - - - - - - - -
    def maxCorrectionSpeed(self):
        """[0,+infinity) or -1, maxCorrectionSpeed."""
        return self.__maxCorrectionSpeed
    @maxCorrectionSpeed.setter
    def maxCorrectionSpeed(self, maxCorrectionSpeed):
        if  maxCorrectionSpeed is None:
            maxCorrectionSpeed = -1 # default
        assertValidSFFloat(maxCorrectionSpeed)
        self.__maxCorrectionSpeed = maxCorrectionSpeed
    @property # getter - - - - - - - - - -
    def preferAccuracy(self):
        """preferAccuracy provides hint for performance preference: higher accuracy or faster computational speed."""
        return self.__preferAccuracy
    @preferAccuracy.setter
    def preferAccuracy(self, preferAccuracy):
        if  preferAccuracy is None:
            preferAccuracy = False # default
        assertValidSFBool(preferAccuracy)
        self.__preferAccuracy = preferAccuracy
    @property # getter - - - - - - - - - -
    def visible(self):
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def collider(self):
        """[CollisionCollection] The collider field associates a collision collection with this rigid body collection allowing seamless updates and integration without the need to use the X3D event model."""
        return self.__collider
    @collider.setter
    def collider(self, collider):
        if  collider is None:
            collider = None # default
        assertValidSFNode(collider)
        if not isinstance(collider, object):
            # print(flush=True)
            raise X3DTypeError(str(collider) + ' does not have a valid node type object')
        self.__collider = collider
    @property # getter - - - - - - - - - -
    def bodies(self):
        """[RigidBody] Collection of top-level nodes that comprise a set of bodies evaluated as a single set of interactions."""
        return self.__bodies
    @bodies.setter
    def bodies(self, bodies):
        if  bodies is None:
            bodies = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(bodies)
        self.__bodies = bodies
    @property # getter - - - - - - - - - -
    def joints(self):
        """[X3DRigidJointNode] The joints field is used to register all joints between bodies contained in this collection."""
        return self.__joints
    @joints.setter
    def joints(self, joints):
        if  joints is None:
            joints = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(joints)
        self.__joints = joints
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.bodies or self.joints or self.collider or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function RigidBodyCollection.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<RigidBodyCollection'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.autoDisable: # default=false
            result += " autoDisable='" + SFBool(self.autoDisable).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.constantForceMix != 0.0001:
            result += " constantForceMix='" + SFFloat(self.constantForceMix).XML() + "'"
        if self.contactSurfaceThickness != 0:
            result += " contactSurfaceThickness='" + SFFloat(self.contactSurfaceThickness).XML() + "'"
        if self.disableAngularSpeed != 0:
            result += " disableAngularSpeed='" + SFFloat(self.disableAngularSpeed).XML() + "'"
        if self.disableLinearSpeed != 0:
            result += " disableLinearSpeed='" + SFFloat(self.disableLinearSpeed).XML() + "'"
        if self.disableTime != 0:
            result += " disableTime='" + SFTime(self.disableTime).XML() + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.errorCorrection != 0.8:
            result += " errorCorrection='" + SFFloat(self.errorCorrection).XML() + "'"
        if self.gravity != (0, -9.8, 0):
            result += " gravity='" + SFVec3f(self.gravity).XML() + "'"
        if self.iterations != 10:
            result += " iterations='" + SFInt32(self.iterations).XML() + "'"
        if self.maxCorrectionSpeed != -1:
            result += " maxCorrectionSpeed='" + SFFloat(self.maxCorrectionSpeed).XML() + "'"
        if self.preferAccuracy: # default=false
            result += " preferAccuracy='" + SFBool(self.preferAccuracy).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></RigidBodyCollection>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.collider: # output this SFNode
                result += self.collider.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.bodies: # walk each child in MFNode list, if any
            ### print('* RigidBodyCollection found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(bodies)=' + str(len(self.bodies)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.bodies:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.joints: # walk each child in MFNode list, if any
            ### print('* RigidBodyCollection found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(joints)=' + str(len(self.joints)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.joints:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</RigidBodyCollection>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function RigidBodyCollection.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'RigidBodyCollection' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'RigidBodyCollection' + ' {'
        if self.autoDisable: # default=false
            result += " autoDisable " + SFBool(self.autoDisable).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.constantForceMix != 0.0001:
            result += " constantForceMix " + SFFloat(self.constantForceMix).VRML() + ""
        if self.contactSurfaceThickness != 0:
            result += " contactSurfaceThickness " + SFFloat(self.contactSurfaceThickness).VRML() + ""
        if self.disableAngularSpeed != 0:
            result += " disableAngularSpeed " + SFFloat(self.disableAngularSpeed).VRML() + ""
        if self.disableLinearSpeed != 0:
            result += " disableLinearSpeed " + SFFloat(self.disableLinearSpeed).VRML() + ""
        if self.disableTime != 0:
            result += " disableTime " + SFTime(self.disableTime).VRML() + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.errorCorrection != 0.8:
            result += " errorCorrection " + SFFloat(self.errorCorrection).VRML() + ""
        if self.gravity != (0, -9.8, 0):
            result += " gravity " + SFVec3f(self.gravity).VRML() + ""
        if self.iterations != 10:
            result += " iterations " + SFInt32(self.iterations).VRML() + ""
        if self.maxCorrectionSpeed != -1:
            result += " maxCorrectionSpeed " + SFFloat(self.maxCorrectionSpeed).VRML() + ""
        if self.preferAccuracy: # default=false
            result += " preferAccuracy " + SFBool(self.preferAccuracy).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.collider: # output this SFNode
            result += '\n' + '  ' + indent + 'collider ' + self.collider.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.bodies: # walk each child in MFNode list, if any
            for each in self.bodies:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.joints: # walk each child in MFNode list, if any
            for each in self.joints:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ScalarChaser(_X3DChaserNode):
    """
    ScalarChaser generates a series of single floating-point values that progressively change from initial value to destination value.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ScalarChaser'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/followers.html#ScalarChaser'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ScalarChaser'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('duration', 1, FieldType.SFTime, AccessType.initializeOnly, 'X3DChaserNode'),
            ('initialDestination', 0, FieldType.SFFloat, AccessType.initializeOnly, 'ScalarChaser'),
            ('initialValue', 0, FieldType.SFFloat, AccessType.initializeOnly, 'ScalarChaser'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 duration=1,
                 initialDestination=0,
                 initialValue=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ScalarChaser __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
    @property # getter - - - - - - - - - -
    def duration(self):
        """[0,+infinity) duration is the time interval for filter response in seconds."""
        return self.__duration
    @duration.setter
    def duration(self, duration):
        if  duration is None:
            duration = 1 # default
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = 0 # default
        assertValidSFFloat(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = 0 # default
        assertValidSFFloat(initialValue)
        self.__initialValue = initialValue
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ScalarChaser.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ScalarChaser'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.duration != 1:
            result += " duration='" + SFTime(self.duration).XML() + "'"
        if self.initialDestination != 0:
            result += " initialDestination='" + SFFloat(self.initialDestination).XML() + "'"
        if self.initialValue != 0:
            result += " initialValue='" + SFFloat(self.initialValue).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ScalarChaser>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ScalarChaser>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ScalarChaser.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ScalarChaser' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ScalarChaser' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.duration != 1:
            result += " duration " + SFTime(self.duration).VRML() + ""
        if self.initialDestination != 0:
            result += " initialDestination " + SFFloat(self.initialDestination).VRML() + ""
        if self.initialValue != 0:
            result += " initialValue " + SFFloat(self.initialValue).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ScalarDamper(_X3DDamperNode):
    """
    ScalarDamper generates a series of floating-point values that progressively change from initial value to destination value.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ScalarDamper'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/followers.html#ScalarDamper'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ScalarDamper'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('initialDestination', 0, FieldType.SFFloat, AccessType.initializeOnly, 'ScalarDamper'),
            ('initialValue', 0, FieldType.SFFloat, AccessType.initializeOnly, 'ScalarDamper'),
            ('order', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DDamperNode'),
            ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput, 'X3DDamperNode'),
            ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DDamperNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 initialDestination=0,
                 initialValue=0,
                 order=3,
                 tau=0.3,
                 tolerance=-1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ScalarDamper __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = 0 # default
        assertValidSFFloat(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = 0 # default
        assertValidSFFloat(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        """[0,5] order defines the number of internal filters (larger means smoother response, longer delay)."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3 # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        """[0,+infinity) tau is the exponential-decay time constant for filter response in seconds."""
        return self.__tau
    @tau.setter
    def tau(self, tau):
        if  tau is None:
            tau = 0.3 # default
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        """[0,+infinity) or -1."""
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance):
        if  tolerance is None:
            tolerance = -1 # default
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ScalarDamper.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ScalarDamper'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.initialDestination != 0:
            result += " initialDestination='" + SFFloat(self.initialDestination).XML() + "'"
        if self.initialValue != 0:
            result += " initialValue='" + SFFloat(self.initialValue).XML() + "'"
        if self.order != 3:
            result += " order='" + SFInt32(self.order).XML() + "'"
        if self.tau != 0.3:
            result += " tau='" + SFTime(self.tau).XML() + "'"
        if self.tolerance != -1:
            result += " tolerance='" + SFFloat(self.tolerance).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ScalarDamper>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ScalarDamper>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ScalarDamper.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ScalarDamper' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ScalarDamper' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.initialDestination != 0:
            result += " initialDestination " + SFFloat(self.initialDestination).VRML() + ""
        if self.initialValue != 0:
            result += " initialValue " + SFFloat(self.initialValue).VRML() + ""
        if self.order != 3:
            result += " order " + SFInt32(self.order).VRML() + ""
        if self.tau != 0.3:
            result += " tau " + SFTime(self.tau).VRML() + ""
        if self.tolerance != -1:
            result += " tolerance " + SFFloat(self.tolerance).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ScalarInterpolator(_X3DInterpolatorNode):
    """
    ScalarInterpolator generates piecewise-linear SFFloat values.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ScalarInterpolator'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/interpolators.html#ScalarInterpolator'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ScalarInterpolator'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('key', list(), FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
            ('keyValue', list(), FieldType.MFFloat, AccessType.inputOutput, 'ScalarInterpolator'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ScalarInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition values for linear-interpolation function input intervals, listed in non-decreasing order and corresponding to a value in the keyValue array."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for linear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(keyValue)
        self.__keyValue = keyValue
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ScalarInterpolator.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ScalarInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + MFFloat(self.key).XML() + "'"
        if self.keyValue != list():
            result += " keyValue='" + MFFloat(self.keyValue).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ScalarInterpolator>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ScalarInterpolator>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ScalarInterpolator.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ScalarInterpolator' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ScalarInterpolator' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.key != list():
            result += " key " + MFFloat(self.key).VRML() + ""
        if self.keyValue != list():
            result += " keyValue " + MFFloat(self.keyValue).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ScreenFontStyle(_X3DFontStyleNode):
    """
    ScreenFontStyle is an X3DFontStyleNode defines the size, family, justification, and other styles used within a screen layout.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ScreenFontStyle'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/layout.html#ScreenFontStyle'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ScreenFontStyle'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('family', ["SERIF"], FieldType.MFString, AccessType.initializeOnly, 'ScreenFontStyle'),
            ('horizontal', True, FieldType.SFBool, AccessType.initializeOnly, 'ScreenFontStyle'),
            ('justify', ["BEGIN"], FieldType.MFString, AccessType.initializeOnly, 'ScreenFontStyle'),
            ('language', '', FieldType.SFString, AccessType.initializeOnly, 'ScreenFontStyle'),
            ('leftToRight', True, FieldType.SFBool, AccessType.initializeOnly, 'ScreenFontStyle'),
            ('pointSize', 12.0, FieldType.SFFloat, AccessType.initializeOnly, 'ScreenFontStyle'),
            ('spacing', 1.0, FieldType.SFFloat, AccessType.initializeOnly, 'ScreenFontStyle'),
            ('style', 'PLAIN', FieldType.SFString, AccessType.initializeOnly, 'ScreenFontStyle'),
            ('topToBottom', True, FieldType.SFBool, AccessType.initializeOnly, 'ScreenFontStyle'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 family=["SERIF"],
                 horizontal=True,
                 justify=["BEGIN"],
                 language='',
                 leftToRight=True,
                 pointSize=12.0,
                 spacing=1.0,
                 style='PLAIN',
                 topToBottom=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ScreenFontStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.family = family
        self.horizontal = horizontal
        self.justify = justify
        self.language = language
        self.leftToRight = leftToRight
        self.pointSize = pointSize
        self.spacing = spacing
        self.style = style
        self.topToBottom = topToBottom
    @property # getter - - - - - - - - - -
    def family(self):
        """Array of quoted font family names in preference order, browsers use the first supported family."""
        return self.__family
    @family.setter
    def family(self, family):
        if  family is None:
            family = ["SERIF"] # default
        assertValidMFString(family)
        self.__family = family
    @property # getter - - - - - - - - - -
    def horizontal(self):
        """Whether text direction is horizontal (true) or vertical (false)."""
        return self.__horizontal
    @horizontal.setter
    def horizontal(self, horizontal):
        if  horizontal is None:
            horizontal = True # default
        assertValidSFBool(horizontal)
        self.__horizontal = horizontal
    @property # getter - - - - - - - - - -
    def justify(self):
        """The justify field determines alignment of the above text layout relative to the origin of the object coordinate system."""
        return self.__justify
    @justify.setter
    def justify(self, justify):
        if  justify is None:
            justify = ["BEGIN"] # default
        assertValidMFString(justify)
        assertValidJustify('justify', justify)
        self.__justify = justify
    @property # getter - - - - - - - - - -
    def language(self):
        """Language codes consist of a primary code and a (possibly empty) series of subcodes."""
        return self.__language
    @language.setter
    def language(self, language):
        if  language is None:
            language = SFString.DEFAULT_VALUE(self)
        assertValidSFString(language)
        self.__language = language
    @property # getter - - - - - - - - - -
    def leftToRight(self):
        return self.__leftToRight
    @leftToRight.setter
    def leftToRight(self, leftToRight):
        if  leftToRight is None:
            leftToRight = True # default
        assertValidSFBool(leftToRight)
        self.__leftToRight = leftToRight
    @property # getter - - - - - - - - - -
    def pointSize(self):
        """(0,+infinity) pointSize field specifies the size of text in points."""
        return self.__pointSize
    @pointSize.setter
    def pointSize(self, pointSize):
        if  pointSize is None:
            pointSize = 12.0 # default
        assertValidSFFloat(pointSize)
        assertPositive('pointSize', pointSize)
        self.__pointSize = pointSize
    @property # getter - - - - - - - - - -
    def spacing(self):
        """[0,+infinity) Adjustment factor for line spacing between adjacent lines of text."""
        return self.__spacing
    @spacing.setter
    def spacing(self, spacing):
        if  spacing is None:
            spacing = 1.0 # default
        assertValidSFFloat(spacing)
        assertNonNegative('spacing', spacing)
        self.__spacing = spacing
    @property # getter - - - - - - - - - -
    def style(self):
        """Pick one of four values for text style."""
        return self.__style
    @style.setter
    def style(self, style):
        if  style is None:
            style = 'PLAIN' # default
        assertValidSFString(style)
        assertValidFontStyle('style', style)
        self.__style = style
    @property # getter - - - - - - - - - -
    def topToBottom(self):
        """Whether text direction is top-to-bottom (true) or bottom-to-top (false)."""
        return self.__topToBottom
    @topToBottom.setter
    def topToBottom(self, topToBottom):
        if  topToBottom is None:
            topToBottom = True # default
        assertValidSFBool(topToBottom)
        self.__topToBottom = topToBottom
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ScreenFontStyle.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ScreenFontStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.family != ["SERIF"]:
            result += " family='" + MFString(self.family).XML() + "'"
        if not self.horizontal: # default=true
            result += " horizontal='" + SFBool(self.horizontal).XML() + "'"
        if self.justify != ["BEGIN"]:
            result += " justify='" + MFString(self.justify).XML() + "'"
        if self.language:
            result += " language='" + self.language + "'"
        if not self.leftToRight: # default=true
            result += " leftToRight='" + SFBool(self.leftToRight).XML() + "'"
        if self.pointSize != 12.0:
            result += " pointSize='" + SFFloat(self.pointSize).XML() + "'"
        if self.spacing != 1.0:
            result += " spacing='" + SFFloat(self.spacing).XML() + "'"
        if self.style != 'PLAIN':
            result += " style='" + self.style + "'"
        if not self.topToBottom: # default=true
            result += " topToBottom='" + SFBool(self.topToBottom).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ScreenFontStyle>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ScreenFontStyle>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ScreenFontStyle.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ScreenFontStyle' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ScreenFontStyle' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.family != ["SERIF"]:
            result += " family " + MFString(self.family).VRML() + ""
        if not self.horizontal: # default=true
            result += " horizontal " + SFBool(self.horizontal).VRML() + ""
        if self.justify != ["BEGIN"]:
            result += " justify " + MFString(self.justify).VRML() + ""
        if self.language:
            result += " language " +  '"' + self.language + '"' + ""
        if not self.leftToRight: # default=true
            result += " leftToRight " + SFBool(self.leftToRight).VRML() + ""
        if self.pointSize != 12.0:
            result += " pointSize " + SFFloat(self.pointSize).VRML() + ""
        if self.spacing != 1.0:
            result += " spacing " + SFFloat(self.spacing).VRML() + ""
        if self.style != 'PLAIN':
            result += " style " +  '"' + self.style + '"' + ""
        if not self.topToBottom: # default=true
            result += " topToBottom " + SFBool(self.topToBottom).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ScreenGroup(_X3DGroupingNode):
    """
    ScreenGroup is a Grouping node that can contain most nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ScreenGroup'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/layout.html#ScreenGroup'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ScreenGroup'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 visible=True,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ScreenGroup __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.visible = visible
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ScreenGroup.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ScreenGroup'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ScreenGroup>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* ScreenGroup found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ScreenGroup>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ScreenGroup.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ScreenGroup' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ScreenGroup' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Script(_X3DScriptNode):
    """
    Script contains author-programmed event behaviors for a scene.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Script'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/scripting.html#Script'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Script'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DScriptNode'),
            ('directOutput', False, FieldType.SFBool, AccessType.initializeOnly, 'Script'),
            ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DScriptNode'),
            ('mustEvaluate', False, FieldType.SFBool, AccessType.initializeOnly, 'Script'),
            ('refresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DScriptNode'),
            ('url', list(), FieldType.MFString, AccessType.inputOutput, 'X3DScriptNode'),
            ('field', list(), FieldType.MFNode, AccessType.inputOutput, 'Script'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 directOutput=False,
                 load=True,
                 mustEvaluate=False,
                 refresh=0,
                 url=list(),
                 field=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Script __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.directOutput = directOutput
        self.load = load
        self.mustEvaluate = mustEvaluate
        self.refresh = refresh
        self.url = url
        self.field = field
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def directOutput(self):
        """Set directOutput true if Script has field reference(s) of type SFNode/MFNode, and also uses direct access to modify attributes of a referenced node in the Scene."""
        return self.__directOutput
    @directOutput.setter
    def directOutput(self, directOutput):
        if  directOutput is None:
            directOutput = False # default
        assertValidSFBool(directOutput)
        self.__directOutput = directOutput
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def mustEvaluate(self):
        """If mustEvaluate false, then the X3D player may delay sending input events to Script until output events are needed."""
        return self.__mustEvaluate
    @mustEvaluate.setter
    def mustEvaluate(self, mustEvaluate):
        if  mustEvaluate is None:
            mustEvaluate = False # default
        assertValidSFBool(mustEvaluate)
        self.__mustEvaluate = mustEvaluate
    @property # getter - - - - - - - - - -
    def refresh(self):
        """refresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__refresh
    @refresh.setter
    def refresh(self, refresh):
        if  refresh is None:
            refresh = 0 # default
        assertValidSFTime(refresh)
        assertNonNegative('refresh', refresh)
        self.__refresh = refresh
    @property # getter - - - - - - - - - -
    def url(self):
        """List of address links for runnable script files."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE(self)
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def field(self):
        """Include a field statement for each field declaration in this Script node."""
        return self.__field
    @field.setter
    def field(self, field):
        if  field is None:
            field = MFNode.DEFAULT_VALUE(self)
        # TODO type-aware checks for field
        if field: # walk each child in MFNode list, if any
            for each in field:
                assertValidFieldInitializationValue(each.name, each.type, each.value, parent='Script')
        self.__field = field
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.field or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Script.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Script'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.directOutput: # default=false
            result += " directOutput='" + SFBool(self.directOutput).XML() + "'"
        if not self.load: # default=true
            result += " load='" + SFBool(self.load).XML() + "'"
        if self.mustEvaluate: # default=false
            result += " mustEvaluate='" + SFBool(self.mustEvaluate).XML() + "'"
        if self.refresh != 0:
            result += " refresh='" + SFTime(self.refresh).XML() + "'"
        if self.url != list():
            result += " url='" + MFString(self.url).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Script>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.field: # walk each child in MFNode list, if any
            ### print('* Script found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(field)=' + str(len(self.field)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.field:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Script>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Script.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Script' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Script' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.directOutput: # default=false
            result += " directOutput " + SFBool(self.directOutput).VRML() + ""
        if not self.load: # default=true
            result += " load " + SFBool(self.load).VRML() + ""
        if self.mustEvaluate: # default=false
            result += " mustEvaluate " + SFBool(self.mustEvaluate).VRML() + ""
        if self.refresh != 0:
            result += " refresh " + SFTime(self.refresh).VRML() + ""
        if self.url != list():
            result += " url " + MFString(self.url).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.field: # walk each child in MFNode list, if any
            for each in self.field:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class SegmentedVolumeData(_X3DVolumeDataNode):
    """
    SegmentedVolumeData displays a segmented voxel dataset with different RenderStyle nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'SegmentedVolumeData'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/volume.html#SegmentedVolumeData'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SegmentedVolumeData'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DVolumeDataNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeDataNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DVolumeDataNode'),
            ('dimensions', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'X3DVolumeDataNode'),
            ('segmentEnabled', list(), FieldType.MFBool, AccessType.inputOutput, 'SegmentedVolumeData'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeDataNode'),
            ('segmentIdentifiers', None, FieldType.SFNode, AccessType.inputOutput, 'SegmentedVolumeData'),
            ('voxels', None, FieldType.SFNode, AccessType.inputOutput, 'SegmentedVolumeData'),
            ('renderStyle', list(), FieldType.MFNode, AccessType.inputOutput, 'SegmentedVolumeData'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 dimensions=(1, 1, 1),
                 segmentEnabled=list(),
                 visible=True,
                 segmentIdentifiers=None,
                 voxels=None,
                 renderStyle=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SegmentedVolumeData __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.dimensions = dimensions
        self.segmentEnabled = segmentEnabled
        self.visible = visible
        self.segmentIdentifiers = segmentIdentifiers
        self.voxels = voxels
        self.renderStyle = renderStyle
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def dimensions(self):
        """Actual-size X-Y-Z dimensions of volume data in local coordinate system."""
        return self.__dimensions
    @dimensions.setter
    def dimensions(self, dimensions):
        if  dimensions is None:
            dimensions = (1, 1, 1) # default
        assertValidSFVec3f(dimensions)
        assertPositive('dimensions', dimensions)
        self.__dimensions = dimensions
    @property # getter - - - - - - - - - -
    def segmentEnabled(self):
        return self.__segmentEnabled
    @segmentEnabled.setter
    def segmentEnabled(self, segmentEnabled):
        if  segmentEnabled is None:
            segmentEnabled = MFBool.DEFAULT_VALUE(self)
        assertValidMFBool(segmentEnabled)
        self.__segmentEnabled = segmentEnabled
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def segmentIdentifiers(self):
        """[X3DTexture3DNode] Single contained X3DTexture3DNode (ComposedTexture3D, ImageTexture3D, PixelTexture3D) holds component texture that provides corresponding segment identifier."""
        return self.__segmentIdentifiers
    @segmentIdentifiers.setter
    def segmentIdentifiers(self, segmentIdentifiers):
        if  segmentIdentifiers is None:
            segmentIdentifiers = None # default
        assertValidSFNode(segmentIdentifiers)
        if not isinstance(segmentIdentifiers, object):
            # print(flush=True)
            raise X3DTypeError(str(segmentIdentifiers) + ' does not have a valid node type object')
        self.__segmentIdentifiers = segmentIdentifiers
    @property # getter - - - - - - - - - -
    def voxels(self):
        """[X3DTexture3DNode] Single contained X3DTexture3DNode (ComposedTexture3D, ImageTexture3D, PixelTexture3D) that provides raw voxel information utilized by corresponding rendering styles."""
        return self.__voxels
    @voxels.setter
    def voxels(self, voxels):
        if  voxels is None:
            voxels = None # default
        assertValidSFNode(voxels)
        if not isinstance(voxels, object):
            # print(flush=True)
            raise X3DTypeError(str(voxels) + ' does not have a valid node type object')
        self.__voxels = voxels
    @property # getter - - - - - - - - - -
    def renderStyle(self):
        """[X3DVolumeRenderStyleNode] Multiple contained X3DVolumeRenderStyleNode nodes corresponding to each isosurface that define specific rendering technique for this volumetric object."""
        return self.__renderStyle
    @renderStyle.setter
    def renderStyle(self, renderStyle):
        if  renderStyle is None:
            renderStyle = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(renderStyle)
        self.__renderStyle = renderStyle
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.renderStyle or self.IS or self.metadata or self.segmentIdentifiers or self.voxels
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function SegmentedVolumeData.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<SegmentedVolumeData'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.dimensions != (1, 1, 1):
            result += " dimensions='" + SFVec3f(self.dimensions).XML() + "'"
        if self.segmentEnabled != list():
            result += " segmentEnabled='" + MFBool(self.segmentEnabled).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></SegmentedVolumeData>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.segmentIdentifiers: # output this SFNode
                result += self.segmentIdentifiers.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.voxels: # output this SFNode
                result += self.voxels.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.renderStyle: # walk each child in MFNode list, if any
            ### print('* SegmentedVolumeData found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(renderStyle)=' + str(len(self.renderStyle)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.renderStyle:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</SegmentedVolumeData>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function SegmentedVolumeData.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'SegmentedVolumeData' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'SegmentedVolumeData' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.dimensions != (1, 1, 1):
            result += " dimensions " + SFVec3f(self.dimensions).VRML() + ""
        if self.segmentEnabled != list():
            result += " segmentEnabled " + MFBool(self.segmentEnabled).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.segmentIdentifiers: # output this SFNode
            result += '\n' + '  ' + indent + 'segmentIdentifiers ' + self.segmentIdentifiers.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.voxels: # output this SFNode
            result += '\n' + '  ' + indent + 'voxels ' + self.voxels.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.renderStyle: # walk each child in MFNode list, if any
            for each in self.renderStyle:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ShadedVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    All fields fully supported except shadows supported with at least Phong shading at level 3. All fields fully supported with at least Phong shading and Henyey-Greenstein phase function, shadows fully supported at level 4.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ShadedVolumeStyle'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/volume.html#ShadedVolumeStyle'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ShadedVolumeStyle'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
            ('lighting', False, FieldType.SFBool, AccessType.inputOutput, 'ShadedVolumeStyle'),
            ('phaseFunction', 'Henyey-Greenstein', FieldType.SFString, AccessType.initializeOnly, 'ShadedVolumeStyle'),
            ('shadows', False, FieldType.SFBool, AccessType.inputOutput, 'ShadedVolumeStyle'),
            ('material', None, FieldType.SFNode, AccessType.inputOutput, 'ShadedVolumeStyle'),
            ('surfaceNormals', None, FieldType.SFNode, AccessType.inputOutput, 'ShadedVolumeStyle'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 enabled=True,
                 lighting=False,
                 phaseFunction='Henyey-Greenstein',
                 shadows=False,
                 material=None,
                 surfaceNormals=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ShadedVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.lighting = lighting
        self.phaseFunction = phaseFunction
        self.shadows = shadows
        self.material = material
        self.surfaceNormals = surfaceNormals
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def lighting(self):
        """Whether rendering calculates and applies shading effects to visual output."""
        return self.__lighting
    @lighting.setter
    def lighting(self, lighting):
        if  lighting is None:
            lighting = False # default
        assertValidSFBool(lighting)
        self.__lighting = lighting
    @property # getter - - - - - - - - - -
    def phaseFunction(self):
        """define scattering model for implementations using global illumination (NONE or Henyey-Greenstein phase function)."""
        return self.__phaseFunction
    @phaseFunction.setter
    def phaseFunction(self, phaseFunction):
        if  phaseFunction is None:
            phaseFunction = 'Henyey-Greenstein' # default
        assertValidSFString(phaseFunction)
        self.__phaseFunction = phaseFunction
    @property # getter - - - - - - - - - -
    def shadows(self):
        """Whether rendering calculates and applies shadows to visual output (using global illumination model)."""
        return self.__shadows
    @shadows.setter
    def shadows(self, shadows):
        if  shadows is None:
            shadows = False # default
        assertValidSFBool(shadows)
        self.__shadows = shadows
    @property # getter - - - - - - - - - -
    def material(self):
        return self.__material
    @material.setter
    def material(self, material):
        if  material is None:
            material = None # default
        assertValidSFNode(material)
        if not isinstance(material, object):
            # print(flush=True)
            raise X3DTypeError(str(material) + ' does not have a valid node type object')
        self.__material = material
    @property # getter - - - - - - - - - -
    def surfaceNormals(self):
        return self.__surfaceNormals
    @surfaceNormals.setter
    def surfaceNormals(self, surfaceNormals):
        if  surfaceNormals is None:
            surfaceNormals = None # default
        assertValidSFNode(surfaceNormals)
        if not isinstance(surfaceNormals, object):
            # print(flush=True)
            raise X3DTypeError(str(surfaceNormals) + ' does not have a valid node type object')
        self.__surfaceNormals = surfaceNormals
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.material or self.metadata or self.surfaceNormals
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ShadedVolumeStyle.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ShadedVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.lighting: # default=false
            result += " lighting='" + SFBool(self.lighting).XML() + "'"
        if self.phaseFunction != 'Henyey-Greenstein':
            result += " phaseFunction='" + self.phaseFunction + "'"
        if self.shadows: # default=false
            result += " shadows='" + SFBool(self.shadows).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ShadedVolumeStyle>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.material: # output this SFNode
                result += self.material.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.surfaceNormals: # output this SFNode
                result += self.surfaceNormals.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ShadedVolumeStyle>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ShadedVolumeStyle.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ShadedVolumeStyle' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ShadedVolumeStyle' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.lighting: # default=false
            result += " lighting " + SFBool(self.lighting).VRML() + ""
        if self.phaseFunction != 'Henyey-Greenstein':
            result += " phaseFunction " +  '"' + self.phaseFunction + '"' + ""
        if self.shadows: # default=false
            result += " shadows " + SFBool(self.shadows).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.material: # output this SFNode
            result += '\n' + '  ' + indent + 'material ' + self.material.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.surfaceNormals: # output this SFNode
            result += '\n' + '  ' + indent + 'surfaceNormals ' + self.surfaceNormals.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ShaderPart(_X3DNode): # , _X3DUrlObject # TODO fix additional inheritance method resolution order (MRO)
    """
    ShaderPart can contain a CDATA section of plain-text source code.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ShaderPart'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shaders.html#ShaderPart'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ShaderPart'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DUrlObject'),
            ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
            ('refresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
            ('type', 'VERTEX', FieldType.SFString, AccessType.initializeOnly, 'ShaderPart'),
            ('url', list(), FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 load=True,
                 refresh=0,
                 type='VERTEX',
                 url=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ShaderPart __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.load = load
        self.refresh = refresh
        self.type = type
        self.url = url
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def refresh(self):
        """refresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__refresh
    @refresh.setter
    def refresh(self, refresh):
        if  refresh is None:
            refresh = 0 # default
        assertValidSFTime(refresh)
        assertNonNegative('refresh', refresh)
        self.__refresh = refresh
    @property # getter - - - - - - - - - -
    def type(self):
        """type indicates whether this ShaderProgram is a vertex or fragment (pixel) shader."""
        return self.__type
    @type.setter
    def type(self, type):
        if  type is None:
            type = 'VERTEX' # default
        assertValidSFString(type)
        self.__type = type
    @property # getter - - - - - - - - - -
    def url(self):
        """Location and filename of shader."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE(self)
        assertValidMFString(url)
        self.__url = url
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ShaderPart.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ShaderPart'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.load: # default=true
            result += " load='" + SFBool(self.load).XML() + "'"
        if self.refresh != 0:
            result += " refresh='" + SFTime(self.refresh).XML() + "'"
        if self.type != 'VERTEX':
            result += " type='" + self.type + "'"
        if self.url != list():
            result += " url='" + MFString(self.url).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ShaderPart>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ShaderPart>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ShaderPart.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ShaderPart' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ShaderPart' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.load: # default=true
            result += " load " + SFBool(self.load).VRML() + ""
        if self.refresh != 0:
            result += " refresh " + SFTime(self.refresh).VRML() + ""
        if self.type != 'VERTEX':
            result += " type " +  '"' + self.type + '"' + ""
        if self.url != list():
            result += " url " + MFString(self.url).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ShaderProgram(_X3DNode): # , _X3DUrlObject, _X3DProgrammableShaderObject # TODO fix additional inheritance method resolution order (MRO)
    """
    ShaderProgram can contain field declarations and a CDATA section of plain-text source code.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ShaderProgram'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shaders.html#ShaderProgram'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ShaderProgram'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DUrlObject'),
            ('load', True, FieldType.SFBool, AccessType.inputOutput, 'X3DUrlObject'),
            ('refresh', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DUrlObject'),
            ('type', 'VERTEX', FieldType.SFString, AccessType.initializeOnly, 'ShaderProgram'),
            ('url', list(), FieldType.MFString, AccessType.inputOutput, 'X3DUrlObject'),
            ('field', list(), FieldType.MFNode, AccessType.inputOutput, 'ShaderProgram'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 load=True,
                 refresh=0,
                 type='VERTEX',
                 url=list(),
                 field=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ShaderProgram __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.load = load
        self.refresh = refresh
        self.type = type
        self.url = url
        self.field = field
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def load(self):
        """load=true means load immediately, load=false means defer loading or else unload a previously loaded scene."""
        return self.__load
    @load.setter
    def load(self, load):
        if  load is None:
            load = True # default
        assertValidSFBool(load)
        self.__load = load
    @property # getter - - - - - - - - - -
    def refresh(self):
        """refresh defines interval in seconds before automatic reload of current url asset is performed."""
        return self.__refresh
    @refresh.setter
    def refresh(self, refresh):
        if  refresh is None:
            refresh = 0 # default
        assertValidSFTime(refresh)
        assertNonNegative('refresh', refresh)
        self.__refresh = refresh
    @property # getter - - - - - - - - - -
    def type(self):
        """type indicates whether this ShaderProgram is a vertex or fragment (pixel) shader."""
        return self.__type
    @type.setter
    def type(self, type):
        if  type is None:
            type = 'VERTEX' # default
        assertValidSFString(type)
        self.__type = type
    @property # getter - - - - - - - - - -
    def url(self):
        """Location and filename of shader."""
        return self.__url
    @url.setter
    def url(self, url):
        if  url is None:
            url = MFString.DEFAULT_VALUE(self)
        assertValidMFString(url)
        self.__url = url
    @property # getter - - - - - - - - - -
    def field(self):
        """Include a field statement for each field declaration in the ShaderProgram node."""
        return self.__field
    @field.setter
    def field(self, field):
        if  field is None:
            field = MFNode.DEFAULT_VALUE(self)
        # TODO type-aware checks for field
        if field: # walk each child in MFNode list, if any
            for each in field:
                assertValidFieldInitializationValue(each.name, each.type, each.value, parent='ShaderProgram')
        self.__field = field
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.field or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ShaderProgram.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ShaderProgram'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.load: # default=true
            result += " load='" + SFBool(self.load).XML() + "'"
        if self.refresh != 0:
            result += " refresh='" + SFTime(self.refresh).XML() + "'"
        if self.type != 'VERTEX':
            result += " type='" + self.type + "'"
        if self.url != list():
            result += " url='" + MFString(self.url).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ShaderProgram>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.field: # walk each child in MFNode list, if any
            ### print('* ShaderProgram found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(field)=' + str(len(self.field)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.field:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ShaderProgram>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ShaderProgram.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ShaderProgram' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ShaderProgram' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.load: # default=true
            result += " load " + SFBool(self.load).VRML() + ""
        if self.refresh != 0:
            result += " refresh " + SFTime(self.refresh).VRML() + ""
        if self.type != 'VERTEX':
            result += " type " +  '"' + self.type + '"' + ""
        if self.url != list():
            result += " url " + MFString(self.url).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.field: # walk each child in MFNode list, if any
            for each in self.field:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Shape(_X3DShapeNode):
    """
    Shape can appear under any grouping node.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Shape'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shape.html#Shape'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Shape'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DShapeNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DShapeNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DShapeNode'),
            ('castShadow', True, FieldType.SFBool, AccessType.inputOutput, 'X3DShapeNode'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DShapeNode'),
            ('appearance', None, FieldType.SFNode, AccessType.inputOutput, 'X3DShapeNode'),
            ('geometry', None, FieldType.SFNode, AccessType.inputOutput, 'X3DShapeNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 castShadow=True,
                 visible=True,
                 appearance=None,
                 geometry=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Shape __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.castShadow = castShadow
        self.visible = visible
        self.appearance = appearance
        self.geometry = geometry
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def castShadow(self):
        return self.__castShadow
    @castShadow.setter
    def castShadow(self, castShadow):
        if  castShadow is None:
            castShadow = True # default
        assertValidSFBool(castShadow)
        self.__castShadow = castShadow
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def appearance(self):
        """[X3DAppearanceNode] Single contained Appearance node that specifies visual attributes (such as material, texture, fillProperties and lineProperties) applied to corresponding geometry."""
        return self.__appearance
    @appearance.setter
    def appearance(self, appearance):
        if  appearance is None:
            appearance = None # default
        assertValidSFNode(appearance)
        if not isinstance(appearance, object):
            # print(flush=True)
            raise X3DTypeError(str(appearance) + ' does not have a valid node type object')
        self.__appearance = appearance
    @property # getter - - - - - - - - - -
    def geometry(self):
        """[X3DGeometryNode] Single contained geometry node that is rendered according to corresponding appearance."""
        return self.__geometry
    @geometry.setter
    def geometry(self, geometry):
        if  geometry is None:
            geometry = None # default
        assertValidSFNode(geometry)
        if not isinstance(geometry, object):
            # print(flush=True)
            raise X3DTypeError(str(geometry) + ' does not have a valid node type object')
        self.__geometry = geometry
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.appearance or self.geometry or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Shape.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Shape'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if not self.castShadow: # default=true
            result += " castShadow='" + SFBool(self.castShadow).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Shape>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.appearance: # output this SFNode
                result += self.appearance.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.geometry: # output this SFNode
                result += self.geometry.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Shape>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Shape.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Shape' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Shape' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if not self.castShadow: # default=true
            result += " castShadow " + SFBool(self.castShadow).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.appearance: # output this SFNode
            result += '\n' + '  ' + indent + 'appearance ' + self.appearance.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.geometry: # output this SFNode
            result += '\n' + '  ' + indent + 'geometry ' + self.geometry.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class SignalPdu(_X3DNetworkSensorNode, _X3DBoundedObject):
    """
    SignalPdu is a networked Protocol Data Unit (PDU) information node that communicates the transmission of voice, audio or other data modeled in a simulation.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'SignalPdu'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/dis.html#SignalPdu'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SignalPdu'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('address', 'localhost', FieldType.SFString, AccessType.inputOutput, 'SignalPdu'),
            ('applicationID', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('data', list(), FieldType.MFInt32, AccessType.inputOutput, 'SignalPdu'),
            ('dataLength', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('encodingScheme', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
            ('entityID', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
            ('geoCoords', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'SignalPdu'),
            ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'SignalPdu'),
            ('multicastRelayHost', '', FieldType.SFString, AccessType.inputOutput, 'SignalPdu'),
            ('multicastRelayPort', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
            ('networkMode', 'standAlone', FieldType.SFString, AccessType.inputOutput, 'SignalPdu'),
            ('port', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
            ('radioID', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
            ('readInterval', 0.1, FieldType.SFTime, AccessType.inputOutput, 'SignalPdu'),
            ('rtpHeaderExpected', False, FieldType.SFBool, AccessType.initializeOnly, 'SignalPdu'),
            ('sampleRate', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
            ('samples', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
            ('siteID', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
            ('tdlType', 0, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('whichGeometry', 1, FieldType.SFInt32, AccessType.inputOutput, 'SignalPdu'),
            ('writeInterval', 1.0, FieldType.SFTime, AccessType.inputOutput, 'SignalPdu'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 address='localhost',
                 applicationID=0,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 data=list(),
                 dataLength=0,
                 enabled=True,
                 encodingScheme=0,
                 entityID=0,
                 geoCoords=(0, 0, 0),
                 geoSystem=["GD", "WE"],
                 multicastRelayHost='',
                 multicastRelayPort=0,
                 networkMode='standAlone',
                 port=0,
                 radioID=0,
                 readInterval=0.1,
                 rtpHeaderExpected=False,
                 sampleRate=0,
                 samples=0,
                 siteID=0,
                 tdlType=0,
                 visible=True,
                 whichGeometry=1,
                 writeInterval=1.0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SignalPdu __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.address = address
        self.applicationID = applicationID
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.data = data
        self.dataLength = dataLength
        self.enabled = enabled
        self.encodingScheme = encodingScheme
        self.entityID = entityID
        self.geoCoords = geoCoords
        self.geoSystem = geoSystem
        self.multicastRelayHost = multicastRelayHost
        self.multicastRelayPort = multicastRelayPort
        self.networkMode = networkMode
        self.port = port
        self.radioID = radioID
        self.readInterval = readInterval
        self.rtpHeaderExpected = rtpHeaderExpected
        self.sampleRate = sampleRate
        self.samples = samples
        self.siteID = siteID
        self.tdlType = tdlType
        self.visible = visible
        self.whichGeometry = whichGeometry
        self.writeInterval = writeInterval
    @property # getter - - - - - - - - - -
    def address(self):
        """Multicast network address, or else "localhost" example: 224."""
        return self.__address
    @address.setter
    def address(self, address):
        if  address is None:
            address = 'localhost' # default
        assertValidSFString(address)
        self.__address = address
    @property # getter - - - - - - - - - -
    def applicationID(self):
        """Each simulation application that can respond to simulation management PDUs needs to have a unique applicationID."""
        return self.__applicationID
    @applicationID.setter
    def applicationID(self, applicationID):
        if  applicationID is None:
            applicationID = 0 # default
        assertValidSFInt32(applicationID)
        self.__applicationID = applicationID
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def data(self):
        """Holds audio or digital data conveyed by the radio transmission."""
        return self.__data
    @data.setter
    def data(self, data):
        if  data is None:
            data = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(data)
        self.__data = data
    @property # getter - - - - - - - - - -
    def dataLength(self):
        """number of bits of digital voice audio or digital data being sent in the Signal PDU."""
        return self.__dataLength
    @dataLength.setter
    def dataLength(self, dataLength):
        if  dataLength is None:
            dataLength = 0 # default
        assertValidSFInt32(dataLength)
        self.__dataLength = dataLength
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables the sensor node."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def encodingScheme(self):
        """designates both Encoding Class and Encoding Type."""
        return self.__encodingScheme
    @encodingScheme.setter
    def encodingScheme(self, encodingScheme):
        if  encodingScheme is None:
            encodingScheme = 0 # default
        assertValidSFInt32(encodingScheme)
        self.__encodingScheme = encodingScheme
    @property # getter - - - - - - - - - -
    def entityID(self):
        """EntityID unique ID for entity within that application."""
        return self.__entityID
    @entityID.setter
    def entityID(self, entityID):
        if  entityID is None:
            entityID = 0 # default
        assertValidSFInt32(entityID)
        self.__entityID = entityID
    @property # getter - - - - - - - - - -
    def geoCoords(self):
        """Geographic location (specified in current geoSystem coordinates) for children geometry (specified in relative coordinate system, in meters)."""
        return self.__geoCoords
    @geoCoords.setter
    def geoCoords(self, geoCoords):
        if  geoCoords is None:
            geoCoords = (0, 0, 0) # default
        assertValidSFVec3d(geoCoords)
        self.__geoCoords = geoCoords
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"] # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def multicastRelayHost(self):
        """Fallback server address if multicast not available locally."""
        return self.__multicastRelayHost
    @multicastRelayHost.setter
    def multicastRelayHost(self, multicastRelayHost):
        if  multicastRelayHost is None:
            multicastRelayHost = SFString.DEFAULT_VALUE(self)
        assertValidSFString(multicastRelayHost)
        self.__multicastRelayHost = multicastRelayHost
    @property # getter - - - - - - - - - -
    def multicastRelayPort(self):
        """Fallback server port if multicast not available locally."""
        return self.__multicastRelayPort
    @multicastRelayPort.setter
    def multicastRelayPort(self, multicastRelayPort):
        if  multicastRelayPort is None:
            multicastRelayPort = 0 # default
        assertValidSFInt32(multicastRelayPort)
        self.__multicastRelayPort = multicastRelayPort
    @property # getter - - - - - - - - - -
    def networkMode(self):
        """Whether this entity is ignoring the network, sending DIS packets to the network, or receiving DIS packets from the network."""
        return self.__networkMode
    @networkMode.setter
    def networkMode(self, networkMode):
        if  networkMode is None:
            networkMode = 'standAlone' # default
        assertValidSFString(networkMode)
        assertValidNetworkMode('networkMode', networkMode)
        self.__networkMode = networkMode
    @property # getter - - - - - - - - - -
    def port(self):
        """Multicast network port, for example: 3000."""
        return self.__port
    @port.setter
    def port(self, port):
        if  port is None:
            port = 0 # default
        assertValidSFInt32(port)
        self.__port = port
    @property # getter - - - - - - - - - -
    def radioID(self):
        """Identifies a particular radio within a given entity."""
        return self.__radioID
    @radioID.setter
    def radioID(self, radioID):
        if  radioID is None:
            radioID = 0 # default
        assertValidSFInt32(radioID)
        self.__radioID = radioID
    @property # getter - - - - - - - - - -
    def readInterval(self):
        """[0,+infinity) Seconds between read updates, 0 means no reading."""
        return self.__readInterval
    @readInterval.setter
    def readInterval(self, readInterval):
        if  readInterval is None:
            readInterval = 0.1 # default
        assertValidSFTime(readInterval)
        assertNonNegative('readInterval', readInterval)
        self.__readInterval = readInterval
    @property # getter - - - - - - - - - -
    def rtpHeaderExpected(self):
        """Whether RTP headers are prepended to DIS PDUs."""
        return self.__rtpHeaderExpected
    @rtpHeaderExpected.setter
    def rtpHeaderExpected(self, rtpHeaderExpected):
        if  rtpHeaderExpected is None:
            rtpHeaderExpected = False # default
        assertValidSFBool(rtpHeaderExpected)
        self.__rtpHeaderExpected = rtpHeaderExpected
    @property # getter - - - - - - - - - -
    def sampleRate(self):
        """sampleRate gives either (1) sample rate in samples per second if Encoding Class is encoded audio, or (2) data rate in bits per second for data transmissions."""
        return self.__sampleRate
    @sampleRate.setter
    def sampleRate(self, sampleRate):
        if  sampleRate is None:
            sampleRate = 0 # default
        assertValidSFInt32(sampleRate)
        self.__sampleRate = sampleRate
    @property # getter - - - - - - - - - -
    def samples(self):
        """Number of samples in the PDU if the Encoding Class is encoded voice, otherwise the field is set to zero."""
        return self.__samples
    @samples.setter
    def samples(self, samples):
        if  samples is None:
            samples = 0 # default
        assertValidSFInt32(samples)
        self.__samples = samples
    @property # getter - - - - - - - - - -
    def siteID(self):
        """Simulation/exercise siteID of the participating LAN or organization."""
        return self.__siteID
    @siteID.setter
    def siteID(self, siteID):
        if  siteID is None:
            siteID = 0 # default
        assertValidSFInt32(siteID)
        self.__siteID = siteID
    @property # getter - - - - - - - - - -
    def tdlType(self):
        """Tactical Data Link (TDL) type as an enumerated value when the Encoding Class is voice, raw binary, application-specific, or database index representation of a TDL message."""
        return self.__tdlType
    @tdlType.setter
    def tdlType(self, tdlType):
        if  tdlType is None:
            tdlType = 0 # default
        assertValidSFInt32(tdlType)
        self.__tdlType = tdlType
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def whichGeometry(self):
        """Select geometry to render: -1 for no geometry, 0 for text trace, 1 for default geometry, (optional) higher values to render different states."""
        return self.__whichGeometry
    @whichGeometry.setter
    def whichGeometry(self, whichGeometry):
        if  whichGeometry is None:
            whichGeometry = 1 # default
        assertValidSFInt32(whichGeometry)
        self.__whichGeometry = whichGeometry
    @property # getter - - - - - - - - - -
    def writeInterval(self):
        """[0,+infinity) Seconds between write updates, 0 means no writing (sending)."""
        return self.__writeInterval
    @writeInterval.setter
    def writeInterval(self, writeInterval):
        if  writeInterval is None:
            writeInterval = 1.0 # default
        assertValidSFTime(writeInterval)
        assertNonNegative('writeInterval', writeInterval)
        self.__writeInterval = writeInterval
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function SignalPdu.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<SignalPdu'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.address != 'localhost':
            result += " address='" + self.address + "'"
        if self.applicationID != 0:
            result += " applicationID='" + SFInt32(self.applicationID).XML() + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.data != list():
            result += " data='" + MFInt32(self.data).XML() + "'"
        if self.dataLength != 0:
            result += " dataLength='" + SFInt32(self.dataLength).XML() + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.encodingScheme != 0:
            result += " encodingScheme='" + SFInt32(self.encodingScheme).XML() + "'"
        if self.entityID != 0:
            result += " entityID='" + SFInt32(self.entityID).XML() + "'"
        if self.geoCoords != (0, 0, 0):
            result += " geoCoords='" + SFVec3d(self.geoCoords).XML() + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + MFString(self.geoSystem).XML() + "'"
        if self.multicastRelayHost:
            result += " multicastRelayHost='" + self.multicastRelayHost + "'"
        if self.multicastRelayPort != 0:
            result += " multicastRelayPort='" + SFInt32(self.multicastRelayPort).XML() + "'"
        if self.networkMode != 'standAlone':
            result += " networkMode='" + self.networkMode + "'"
        if self.port != 0:
            result += " port='" + SFInt32(self.port).XML() + "'"
        if self.radioID != 0:
            result += " radioID='" + SFInt32(self.radioID).XML() + "'"
        if self.readInterval != 0.1:
            result += " readInterval='" + SFTime(self.readInterval).XML() + "'"
        if self.rtpHeaderExpected: # default=false
            result += " rtpHeaderExpected='" + SFBool(self.rtpHeaderExpected).XML() + "'"
        if self.sampleRate != 0:
            result += " sampleRate='" + SFInt32(self.sampleRate).XML() + "'"
        if self.samples != 0:
            result += " samples='" + SFInt32(self.samples).XML() + "'"
        if self.siteID != 0:
            result += " siteID='" + SFInt32(self.siteID).XML() + "'"
        if self.tdlType != 0:
            result += " tdlType='" + SFInt32(self.tdlType).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if self.whichGeometry != 1:
            result += " whichGeometry='" + SFInt32(self.whichGeometry).XML() + "'"
        if self.writeInterval != 1.0:
            result += " writeInterval='" + SFTime(self.writeInterval).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></SignalPdu>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</SignalPdu>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function SignalPdu.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'SignalPdu' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'SignalPdu' + ' {'
        if self.address != 'localhost':
            result += " address " +  '"' + self.address + '"' + ""
        if self.applicationID != 0:
            result += " applicationID " + SFInt32(self.applicationID).VRML() + ""
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.data != list():
            result += " data " + MFInt32(self.data).VRML() + ""
        if self.dataLength != 0:
            result += " dataLength " + SFInt32(self.dataLength).VRML() + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.encodingScheme != 0:
            result += " encodingScheme " + SFInt32(self.encodingScheme).VRML() + ""
        if self.entityID != 0:
            result += " entityID " + SFInt32(self.entityID).VRML() + ""
        if self.geoCoords != (0, 0, 0):
            result += " geoCoords " + SFVec3d(self.geoCoords).VRML() + ""
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem " + MFString(self.geoSystem).VRML() + ""
        if self.multicastRelayHost:
            result += " multicastRelayHost " +  '"' + self.multicastRelayHost + '"' + ""
        if self.multicastRelayPort != 0:
            result += " multicastRelayPort " + SFInt32(self.multicastRelayPort).VRML() + ""
        if self.networkMode != 'standAlone':
            result += " networkMode " +  '"' + self.networkMode + '"' + ""
        if self.port != 0:
            result += " port " + SFInt32(self.port).VRML() + ""
        if self.radioID != 0:
            result += " radioID " + SFInt32(self.radioID).VRML() + ""
        if self.readInterval != 0.1:
            result += " readInterval " + SFTime(self.readInterval).VRML() + ""
        if self.rtpHeaderExpected: # default=false
            result += " rtpHeaderExpected " + SFBool(self.rtpHeaderExpected).VRML() + ""
        if self.sampleRate != 0:
            result += " sampleRate " + SFInt32(self.sampleRate).VRML() + ""
        if self.samples != 0:
            result += " samples " + SFInt32(self.samples).VRML() + ""
        if self.siteID != 0:
            result += " siteID " + SFInt32(self.siteID).VRML() + ""
        if self.tdlType != 0:
            result += " tdlType " + SFInt32(self.tdlType).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.whichGeometry != 1:
            result += " whichGeometry " + SFInt32(self.whichGeometry).VRML() + ""
        if self.writeInterval != 1.0:
            result += " writeInterval " + SFTime(self.writeInterval).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class SilhouetteEnhancementVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    SilhouetteEnhancementVolumeStyle specifies that volumetric data is rendered with silhouette enhancement.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'SilhouetteEnhancementVolumeStyle'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/volume.html#SilhouetteEnhancementVolumeStyle'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SilhouetteEnhancementVolumeStyle'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
            ('silhouetteBoundaryOpacity', 0, FieldType.SFFloat, AccessType.inputOutput, 'SilhouetteEnhancementVolumeStyle'),
            ('silhouetteRetainedOpacity', 1, FieldType.SFFloat, AccessType.inputOutput, 'SilhouetteEnhancementVolumeStyle'),
            ('silhouetteSharpness', 0.5, FieldType.SFFloat, AccessType.inputOutput, 'SilhouetteEnhancementVolumeStyle'),
            ('surfaceNormals', None, FieldType.SFNode, AccessType.inputOutput, 'SilhouetteEnhancementVolumeStyle'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 enabled=True,
                 silhouetteBoundaryOpacity=0,
                 silhouetteRetainedOpacity=1,
                 silhouetteSharpness=0.5,
                 surfaceNormals=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SilhouetteEnhancementVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.silhouetteBoundaryOpacity = silhouetteBoundaryOpacity
        self.silhouetteRetainedOpacity = silhouetteRetainedOpacity
        self.silhouetteSharpness = silhouetteSharpness
        self.surfaceNormals = surfaceNormals
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def silhouetteBoundaryOpacity(self):
        """[0,1] amount of the silhouette enhancement to use."""
        return self.__silhouetteBoundaryOpacity
    @silhouetteBoundaryOpacity.setter
    def silhouetteBoundaryOpacity(self, silhouetteBoundaryOpacity):
        if  silhouetteBoundaryOpacity is None:
            silhouetteBoundaryOpacity = 0 # default
        assertValidSFFloat(silhouetteBoundaryOpacity)
        assertZeroToOne('silhouetteBoundaryOpacity', silhouetteBoundaryOpacity)
        self.__silhouetteBoundaryOpacity = silhouetteBoundaryOpacity
    @property # getter - - - - - - - - - -
    def silhouetteRetainedOpacity(self):
        """[0,1] scaling of non-silhouette regions."""
        return self.__silhouetteRetainedOpacity
    @silhouetteRetainedOpacity.setter
    def silhouetteRetainedOpacity(self, silhouetteRetainedOpacity):
        if  silhouetteRetainedOpacity is None:
            silhouetteRetainedOpacity = 1 # default
        assertValidSFFloat(silhouetteRetainedOpacity)
        assertZeroToOne('silhouetteRetainedOpacity', silhouetteRetainedOpacity)
        self.__silhouetteRetainedOpacity = silhouetteRetainedOpacity
    @property # getter - - - - - - - - - -
    def silhouetteSharpness(self):
        """[0,+infinity) power function to control sharpness of the silhouette."""
        return self.__silhouetteSharpness
    @silhouetteSharpness.setter
    def silhouetteSharpness(self, silhouetteSharpness):
        if  silhouetteSharpness is None:
            silhouetteSharpness = 0.5 # default
        assertValidSFFloat(silhouetteSharpness)
        assertNonNegative('silhouetteSharpness', silhouetteSharpness)
        self.__silhouetteSharpness = silhouetteSharpness
    @property # getter - - - - - - - - - -
    def surfaceNormals(self):
        return self.__surfaceNormals
    @surfaceNormals.setter
    def surfaceNormals(self, surfaceNormals):
        if  surfaceNormals is None:
            surfaceNormals = None # default
        assertValidSFNode(surfaceNormals)
        if not isinstance(surfaceNormals, object):
            # print(flush=True)
            raise X3DTypeError(str(surfaceNormals) + ' does not have a valid node type object')
        self.__surfaceNormals = surfaceNormals
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.surfaceNormals
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function SilhouetteEnhancementVolumeStyle.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<SilhouetteEnhancementVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.silhouetteBoundaryOpacity != 0:
            result += " silhouetteBoundaryOpacity='" + SFFloat(self.silhouetteBoundaryOpacity).XML() + "'"
        if self.silhouetteRetainedOpacity != 1:
            result += " silhouetteRetainedOpacity='" + SFFloat(self.silhouetteRetainedOpacity).XML() + "'"
        if self.silhouetteSharpness != 0.5:
            result += " silhouetteSharpness='" + SFFloat(self.silhouetteSharpness).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></SilhouetteEnhancementVolumeStyle>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.surfaceNormals: # output this SFNode
                result += self.surfaceNormals.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</SilhouetteEnhancementVolumeStyle>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function SilhouetteEnhancementVolumeStyle.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'SilhouetteEnhancementVolumeStyle' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'SilhouetteEnhancementVolumeStyle' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.silhouetteBoundaryOpacity != 0:
            result += " silhouetteBoundaryOpacity " + SFFloat(self.silhouetteBoundaryOpacity).VRML() + ""
        if self.silhouetteRetainedOpacity != 1:
            result += " silhouetteRetainedOpacity " + SFFloat(self.silhouetteRetainedOpacity).VRML() + ""
        if self.silhouetteSharpness != 0.5:
            result += " silhouetteSharpness " + SFFloat(self.silhouetteSharpness).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.surfaceNormals: # output this SFNode
            result += '\n' + '  ' + indent + 'surfaceNormals ' + self.surfaceNormals.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class SingleAxisHingeJoint(_X3DRigidJointNode):
    """
    SingleAxisHingeJoint has single axis about which to rotate, similar to a traditional door hinge. Contains two RigidBody nodes (containerField values body1, body2).
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'SingleAxisHingeJoint'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rigidBodyPhysics.html#SingleAxisHingeJoint'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SingleAxisHingeJoint'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('anchorPoint', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'SingleAxisHingeJoint'),
            ('axis', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'SingleAxisHingeJoint'),
            ('forceOutput', ["NONE"], FieldType.MFString, AccessType.inputOutput, 'X3DRigidJointNode'),
            ('maxAngle', 3.141592653, FieldType.SFFloat, AccessType.inputOutput, 'SingleAxisHingeJoint'),
            ('minAngle', -3.141592653, FieldType.SFFloat, AccessType.inputOutput, 'SingleAxisHingeJoint'),
            ('stopBounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'SingleAxisHingeJoint'),
            ('stopErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'SingleAxisHingeJoint'),
            ('body1', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
            ('body2', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 anchorPoint=(0, 0, 0),
                 axis=(0, 0, 0),
                 forceOutput=["NONE"],
                 maxAngle=3.141592653,
                 minAngle=-3.141592653,
                 stopBounce=0,
                 stopErrorCorrection=0.8,
                 body1=None,
                 body2=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SingleAxisHingeJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.anchorPoint = anchorPoint
        self.axis = axis
        self.forceOutput = forceOutput
        self.maxAngle = maxAngle
        self.minAngle = minAngle
        self.stopBounce = stopBounce
        self.stopErrorCorrection = stopErrorCorrection
        self.body1 = body1
        self.body2 = body2
    @property # getter - - - - - - - - - -
    def anchorPoint(self):
        """anchorPoint is joint center, specified in world coordinates."""
        return self.__anchorPoint
    @anchorPoint.setter
    def anchorPoint(self, anchorPoint):
        if  anchorPoint is None:
            anchorPoint = (0, 0, 0) # default
        assertValidSFVec3f(anchorPoint)
        self.__anchorPoint = anchorPoint
    @property # getter - - - - - - - - - -
    def axis(self):
        """axis defines vector of joint connection between body1 and body2."""
        return self.__axis
    @axis.setter
    def axis(self, axis):
        if  axis is None:
            axis = (0, 0, 0) # default
        assertValidSFVec3f(axis)
        self.__axis = axis
    @property # getter - - - - - - - - - -
    def forceOutput(self):
        """forceOutput controls which output fields are generated for the next frame."""
        return self.__forceOutput
    @forceOutput.setter
    def forceOutput(self, forceOutput):
        if  forceOutput is None:
            forceOutput = ["NONE"] # default
        assertValidMFString(forceOutput)
        self.__forceOutput = forceOutput
    @property # getter - - - - - - - - - -
    def maxAngle(self):
        """[-pi,pi] maxAngle is maximum rotation angle for hinge."""
        return self.__maxAngle
    @maxAngle.setter
    def maxAngle(self, maxAngle):
        if  maxAngle is None:
            maxAngle = 3.141592653 # default
        assertValidSFFloat(maxAngle)
        self.__maxAngle = maxAngle
    @property # getter - - - - - - - - - -
    def minAngle(self):
        """[-pi,pi] minAngle is minimum rotation angle for hinge."""
        return self.__minAngle
    @minAngle.setter
    def minAngle(self, minAngle):
        if  minAngle is None:
            minAngle = -3.141592653 # default
        assertValidSFFloat(minAngle)
        self.__minAngle = minAngle
    @property # getter - - - - - - - - - -
    def stopBounce(self):
        """[0,1] stopBounce is velocity factor for bounce back once stop point is reached."""
        return self.__stopBounce
    @stopBounce.setter
    def stopBounce(self, stopBounce):
        if  stopBounce is None:
            stopBounce = 0 # default
        assertValidSFFloat(stopBounce)
        self.__stopBounce = stopBounce
    @property # getter - - - - - - - - - -
    def stopErrorCorrection(self):
        """[0,1] stopErrorCorrection is fraction of error correction performed during time step once stop point is reached."""
        return self.__stopErrorCorrection
    @stopErrorCorrection.setter
    def stopErrorCorrection(self, stopErrorCorrection):
        if  stopErrorCorrection is None:
            stopErrorCorrection = 0.8 # default
        assertValidSFFloat(stopErrorCorrection)
        self.__stopErrorCorrection = stopErrorCorrection
    @property # getter - - - - - - - - - -
    def body1(self):
        return self.__body1
    @body1.setter
    def body1(self, body1):
        if  body1 is None:
            body1 = None # default
        assertValidSFNode(body1)
        if not isinstance(body1, object):
            # print(flush=True)
            raise X3DTypeError(str(body1) + ' does not have a valid node type object')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        return self.__body2
    @body2.setter
    def body2(self, body2):
        if  body2 is None:
            body2 = None # default
        assertValidSFNode(body2)
        if not isinstance(body2, object):
            # print(flush=True)
            raise X3DTypeError(str(body2) + ' does not have a valid node type object')
        self.__body2 = body2
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.body1 or self.body2 or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function SingleAxisHingeJoint.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<SingleAxisHingeJoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.anchorPoint != (0, 0, 0):
            result += " anchorPoint='" + SFVec3f(self.anchorPoint).XML() + "'"
        if self.axis != (0, 0, 0):
            result += " axis='" + SFVec3f(self.axis).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.forceOutput != ["NONE"]:
            result += " forceOutput='" + MFString(self.forceOutput).XML() + "'"
        if self.maxAngle != 3.141592653:
            result += " maxAngle='" + SFFloat(self.maxAngle).XML() + "'"
        if self.minAngle != -3.141592653:
            result += " minAngle='" + SFFloat(self.minAngle).XML() + "'"
        if self.stopBounce != 0:
            result += " stopBounce='" + SFFloat(self.stopBounce).XML() + "'"
        if self.stopErrorCorrection != 0.8:
            result += " stopErrorCorrection='" + SFFloat(self.stopErrorCorrection).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></SingleAxisHingeJoint>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.body1: # output this SFNode
                result += self.body1.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.body2: # output this SFNode
                result += self.body2.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</SingleAxisHingeJoint>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function SingleAxisHingeJoint.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'SingleAxisHingeJoint' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'SingleAxisHingeJoint' + ' {'
        if self.anchorPoint != (0, 0, 0):
            result += " anchorPoint " + SFVec3f(self.anchorPoint).VRML() + ""
        if self.axis != (0, 0, 0):
            result += " axis " + SFVec3f(self.axis).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.forceOutput != ["NONE"]:
            result += " forceOutput " + MFString(self.forceOutput).VRML() + ""
        if self.maxAngle != 3.141592653:
            result += " maxAngle " + SFFloat(self.maxAngle).VRML() + ""
        if self.minAngle != -3.141592653:
            result += " minAngle " + SFFloat(self.minAngle).VRML() + ""
        if self.stopBounce != 0:
            result += " stopBounce " + SFFloat(self.stopBounce).VRML() + ""
        if self.stopErrorCorrection != 0.8:
            result += " stopErrorCorrection " + SFFloat(self.stopErrorCorrection).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.body1: # output this SFNode
            result += '\n' + '  ' + indent + 'body1 ' + self.body1.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.body2: # output this SFNode
            result += '\n' + '  ' + indent + 'body2 ' + self.body2.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class SliderJoint(_X3DRigidJointNode):
    """
    SliderJoint constrains all movement between body1 and body2 along a single axis. Contains two RigidBody nodes (containerField values body1, body2).
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'SliderJoint'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rigidBodyPhysics.html#SliderJoint'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SliderJoint'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('axis', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'SliderJoint'),
            ('forceOutput', ["NONE"], FieldType.MFString, AccessType.inputOutput, 'X3DRigidJointNode'),
            ('maxSeparation', 1, FieldType.SFFloat, AccessType.inputOutput, 'SliderJoint'),
            ('minSeparation', 0, FieldType.SFFloat, AccessType.inputOutput, 'SliderJoint'),
            ('sliderForce', 0, FieldType.SFFloat, AccessType.inputOutput, 'SliderJoint'),
            ('stopBounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'SliderJoint'),
            ('stopErrorCorrection', 1, FieldType.SFFloat, AccessType.inputOutput, 'SliderJoint'),
            ('body1', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
            ('body2', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 axis=(0, 1, 0),
                 forceOutput=["NONE"],
                 maxSeparation=1,
                 minSeparation=0,
                 sliderForce=0,
                 stopBounce=0,
                 stopErrorCorrection=1,
                 body1=None,
                 body2=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SliderJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.axis = axis
        self.forceOutput = forceOutput
        self.maxSeparation = maxSeparation
        self.minSeparation = minSeparation
        self.sliderForce = sliderForce
        self.stopBounce = stopBounce
        self.stopErrorCorrection = stopErrorCorrection
        self.body1 = body1
        self.body2 = body2
    @property # getter - - - - - - - - - -
    def axis(self):
        """[0,1] axis is normalized vector specifying direction of motion."""
        return self.__axis
    @axis.setter
    def axis(self, axis):
        if  axis is None:
            axis = (0, 1, 0) # default
        assertValidSFVec3f(axis)
        self.__axis = axis
    @property # getter - - - - - - - - - -
    def forceOutput(self):
        """forceOutput controls which output fields are generated for the next frame."""
        return self.__forceOutput
    @forceOutput.setter
    def forceOutput(self, forceOutput):
        if  forceOutput is None:
            forceOutput = ["NONE"] # default
        assertValidMFString(forceOutput)
        self.__forceOutput = forceOutput
    @property # getter - - - - - - - - - -
    def maxSeparation(self):
        """maxSeparation is maximum separation distance between the two bodies."""
        return self.__maxSeparation
    @maxSeparation.setter
    def maxSeparation(self, maxSeparation):
        if  maxSeparation is None:
            maxSeparation = 1 # default
        assertValidSFFloat(maxSeparation)
        self.__maxSeparation = maxSeparation
    @property # getter - - - - - - - - - -
    def minSeparation(self):
        """minSeparation is minimum separation distance between the two bodies."""
        return self.__minSeparation
    @minSeparation.setter
    def minSeparation(self, minSeparation):
        if  minSeparation is None:
            minSeparation = 0 # default
        assertValidSFFloat(minSeparation)
        self.__minSeparation = minSeparation
    @property # getter - - - - - - - - - -
    def sliderForce(self):
        return self.__sliderForce
    @sliderForce.setter
    def sliderForce(self, sliderForce):
        if  sliderForce is None:
            sliderForce = 0 # default
        assertValidSFFloat(sliderForce)
        self.__sliderForce = sliderForce
    @property # getter - - - - - - - - - -
    def stopBounce(self):
        """[0,1] stopBounce is velocity factor for bounce back once stop point is reached."""
        return self.__stopBounce
    @stopBounce.setter
    def stopBounce(self, stopBounce):
        if  stopBounce is None:
            stopBounce = 0 # default
        assertValidSFFloat(stopBounce)
        self.__stopBounce = stopBounce
    @property # getter - - - - - - - - - -
    def stopErrorCorrection(self):
        """[0,1] stopErrorCorrection is fraction of error correction performed during time step once stop point is reached."""
        return self.__stopErrorCorrection
    @stopErrorCorrection.setter
    def stopErrorCorrection(self, stopErrorCorrection):
        if  stopErrorCorrection is None:
            stopErrorCorrection = 1 # default
        assertValidSFFloat(stopErrorCorrection)
        self.__stopErrorCorrection = stopErrorCorrection
    @property # getter - - - - - - - - - -
    def body1(self):
        return self.__body1
    @body1.setter
    def body1(self, body1):
        if  body1 is None:
            body1 = None # default
        assertValidSFNode(body1)
        if not isinstance(body1, object):
            # print(flush=True)
            raise X3DTypeError(str(body1) + ' does not have a valid node type object')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        return self.__body2
    @body2.setter
    def body2(self, body2):
        if  body2 is None:
            body2 = None # default
        assertValidSFNode(body2)
        if not isinstance(body2, object):
            # print(flush=True)
            raise X3DTypeError(str(body2) + ' does not have a valid node type object')
        self.__body2 = body2
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.body1 or self.body2 or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function SliderJoint.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<SliderJoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.axis != (0, 1, 0):
            result += " axis='" + SFVec3f(self.axis).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.forceOutput != ["NONE"]:
            result += " forceOutput='" + MFString(self.forceOutput).XML() + "'"
        if self.maxSeparation != 1:
            result += " maxSeparation='" + SFFloat(self.maxSeparation).XML() + "'"
        if self.minSeparation != 0:
            result += " minSeparation='" + SFFloat(self.minSeparation).XML() + "'"
        if self.sliderForce != 0:
            result += " sliderForce='" + SFFloat(self.sliderForce).XML() + "'"
        if self.stopBounce != 0:
            result += " stopBounce='" + SFFloat(self.stopBounce).XML() + "'"
        if self.stopErrorCorrection != 1:
            result += " stopErrorCorrection='" + SFFloat(self.stopErrorCorrection).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></SliderJoint>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.body1: # output this SFNode
                result += self.body1.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.body2: # output this SFNode
                result += self.body2.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</SliderJoint>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function SliderJoint.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'SliderJoint' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'SliderJoint' + ' {'
        if self.axis != (0, 1, 0):
            result += " axis " + SFVec3f(self.axis).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.forceOutput != ["NONE"]:
            result += " forceOutput " + MFString(self.forceOutput).VRML() + ""
        if self.maxSeparation != 1:
            result += " maxSeparation " + SFFloat(self.maxSeparation).VRML() + ""
        if self.minSeparation != 0:
            result += " minSeparation " + SFFloat(self.minSeparation).VRML() + ""
        if self.sliderForce != 0:
            result += " sliderForce " + SFFloat(self.sliderForce).VRML() + ""
        if self.stopBounce != 0:
            result += " stopBounce " + SFFloat(self.stopBounce).VRML() + ""
        if self.stopErrorCorrection != 1:
            result += " stopErrorCorrection " + SFFloat(self.stopErrorCorrection).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.body1: # output this SFNode
            result += '\n' + '  ' + indent + 'body1 ' + self.body1.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.body2: # output this SFNode
            result += '\n' + '  ' + indent + 'body2 ' + self.body2.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Sound(_X3DSoundNode):
    """
    The Sound node controls the 3D spatialization of sound playback by a child AudioClip or MovieTexture node.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Sound'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#Sound'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Sound'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSoundNode'),
            ('direction', (0, 0, 1), FieldType.SFVec3f, AccessType.inputOutput, 'Sound'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundNode'),
            ('intensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'Sound'),
            ('location', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'Sound'),
            ('maxBack', 10, FieldType.SFFloat, AccessType.inputOutput, 'Sound'),
            ('maxFront', 10, FieldType.SFFloat, AccessType.inputOutput, 'Sound'),
            ('minBack', 1, FieldType.SFFloat, AccessType.inputOutput, 'Sound'),
            ('minFront', 1, FieldType.SFFloat, AccessType.inputOutput, 'Sound'),
            ('priority', 0, FieldType.SFFloat, AccessType.inputOutput, 'Sound'),
            ('spatialize', True, FieldType.SFBool, AccessType.initializeOnly, 'Sound'),
            ('source', None, FieldType.SFNode, AccessType.inputOutput, 'Sound'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 direction=(0, 0, 1),
                 enabled=True,
                 intensity=1,
                 location=(0, 0, 0),
                 maxBack=10,
                 maxFront=10,
                 minBack=1,
                 minFront=1,
                 priority=0,
                 spatialize=True,
                 source=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Sound __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.direction = direction
        self.enabled = enabled
        self.intensity = intensity
        self.location = location
        self.maxBack = maxBack
        self.maxFront = maxFront
        self.minBack = minBack
        self.minFront = minFront
        self.priority = priority
        self.spatialize = spatialize
        self.source = source
    @property # getter - - - - - - - - - -
    def description(self):
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def direction(self):
        """direction of sound axis, relative to local coordinate system."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 0, 1) # default
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def enabled(self):
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def intensity(self):
        """Factor [0,1] adjusting loudness (decibels) of emitted sound."""
        return self.__intensity
    @intensity.setter
    def intensity(self, intensity):
        if  intensity is None:
            intensity = 1 # default
        assertValidSFFloat(intensity)
        assertZeroToOne('intensity', intensity)
        self.__intensity = intensity
    @property # getter - - - - - - - - - -
    def location(self):
        """Position of sound ellipsoid center, relative to local coordinate system."""
        return self.__location
    @location.setter
    def location(self, location):
        if  location is None:
            location = (0, 0, 0) # default
        assertValidSFVec3f(location)
        self.__location = location
    @property # getter - - - - - - - - - -
    def maxBack(self):
        """Outer (zero loudness)ellipsoid distance along back direction."""
        return self.__maxBack
    @maxBack.setter
    def maxBack(self, maxBack):
        if  maxBack is None:
            maxBack = 10 # default
        assertValidSFFloat(maxBack)
        assertNonNegative('maxBack', maxBack)
        self.__maxBack = maxBack
    @property # getter - - - - - - - - - -
    def maxFront(self):
        """Outer (zero loudness)ellipsoid distance along front direction."""
        return self.__maxFront
    @maxFront.setter
    def maxFront(self, maxFront):
        if  maxFront is None:
            maxFront = 10 # default
        assertValidSFFloat(maxFront)
        assertNonNegative('maxFront', maxFront)
        self.__maxFront = maxFront
    @property # getter - - - - - - - - - -
    def minBack(self):
        """Inner (full loudness) ellipsoid distance along back direction."""
        return self.__minBack
    @minBack.setter
    def minBack(self, minBack):
        if  minBack is None:
            minBack = 1 # default
        assertValidSFFloat(minBack)
        assertNonNegative('minBack', minBack)
        self.__minBack = minBack
    @property # getter - - - - - - - - - -
    def minFront(self):
        """Inner (full loudness) ellipsoid distance along front direction."""
        return self.__minFront
    @minFront.setter
    def minFront(self, minFront):
        if  minFront is None:
            minFront = 1 # default
        assertValidSFFloat(minFront)
        assertNonNegative('minFront', minFront)
        self.__minFront = minFront
    @property # getter - - - - - - - - - -
    def priority(self):
        """Player hint [0,1] if needed to choose which sounds to play."""
        return self.__priority
    @priority.setter
    def priority(self, priority):
        if  priority is None:
            priority = 0 # default
        assertValidSFFloat(priority)
        assertZeroToOne('priority', priority)
        self.__priority = priority
    @property # getter - - - - - - - - - -
    def spatialize(self):
        """Whether to spatialize sound playback relative to viewer."""
        return self.__spatialize
    @spatialize.setter
    def spatialize(self, spatialize):
        if  spatialize is None:
            spatialize = True # default
        assertValidSFBool(spatialize)
        self.__spatialize = spatialize
    @property # getter - - - - - - - - - -
    def source(self):
        """[X3DSoundSourceNode] sound source for the Sound node, either an AudioClip node or a MovieTexture node."""
        return self.__source
    @source.setter
    def source(self, source):
        if  source is None:
            source = None # default
        assertValidSFNode(source)
        if not isinstance(source, object):
            # print(flush=True)
            raise X3DTypeError(str(source) + ' does not have a valid node type object')
        self.__source = source
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.source
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Sound.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Sound'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.direction != (0, 0, 1):
            result += " direction='" + SFVec3f(self.direction).XML() + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.intensity != 1:
            result += " intensity='" + SFFloat(self.intensity).XML() + "'"
        if self.location != (0, 0, 0):
            result += " location='" + SFVec3f(self.location).XML() + "'"
        if self.maxBack != 10:
            result += " maxBack='" + SFFloat(self.maxBack).XML() + "'"
        if self.maxFront != 10:
            result += " maxFront='" + SFFloat(self.maxFront).XML() + "'"
        if self.minBack != 1:
            result += " minBack='" + SFFloat(self.minBack).XML() + "'"
        if self.minFront != 1:
            result += " minFront='" + SFFloat(self.minFront).XML() + "'"
        if self.priority != 0:
            result += " priority='" + SFFloat(self.priority).XML() + "'"
        if not self.spatialize: # default=true
            result += " spatialize='" + SFBool(self.spatialize).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Sound>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.source: # output this SFNode
                result += self.source.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Sound>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Sound.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Sound' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Sound' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.direction != (0, 0, 1):
            result += " direction " + SFVec3f(self.direction).VRML() + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.intensity != 1:
            result += " intensity " + SFFloat(self.intensity).VRML() + ""
        if self.location != (0, 0, 0):
            result += " location " + SFVec3f(self.location).VRML() + ""
        if self.maxBack != 10:
            result += " maxBack " + SFFloat(self.maxBack).VRML() + ""
        if self.maxFront != 10:
            result += " maxFront " + SFFloat(self.maxFront).VRML() + ""
        if self.minBack != 1:
            result += " minBack " + SFFloat(self.minBack).VRML() + ""
        if self.minFront != 1:
            result += " minFront " + SFFloat(self.minFront).VRML() + ""
        if self.priority != 0:
            result += " priority " + SFFloat(self.priority).VRML() + ""
        if not self.spatialize: # default=true
            result += " spatialize " + SFBool(self.spatialize).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.source: # output this SFNode
            result += '\n' + '  ' + indent + 'source ' + self.source.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class SpatialSound(_X3DSoundNode):
    """
    The SpatialSound node controls the 3D spatialization of sound playback by a child AudioClip or MovieTexture node.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'SpatialSound'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#Sound'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SpatialSound'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('coneInnerAngle', 6.2832, FieldType.SFFloat, AccessType.inputOutput, 'SpatialSound'),
            ('coneOuterAngle', 6.2832, FieldType.SFFloat, AccessType.inputOutput, 'SpatialSound'),
            ('coneOuterGain', 0, FieldType.SFFloat, AccessType.inputOutput, 'SpatialSound'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSoundNode'),
            ('direction', (0, 0, 1), FieldType.SFVec3f, AccessType.inputOutput, 'SpatialSound'),
            ('distanceModel', 'inverse', FieldType.SFString, AccessType.inputOutput, 'SpatialSound'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundNode'),
            ('enableHRTF', False, FieldType.SFBool, AccessType.inputOutput, 'SpatialSound'),
            ('intensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'SpatialSound'),
            ('location', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'SpatialSound'),
            ('maxDistance', 10000, FieldType.SFFloat, AccessType.inputOutput, 'SpatialSound'),
            ('priority', 0, FieldType.SFFloat, AccessType.inputOutput, 'SpatialSound'),
            ('referenceDistance', 1, FieldType.SFFloat, AccessType.inputOutput, 'SpatialSound'),
            ('rolloffFactor', 1, FieldType.SFFloat, AccessType.inputOutput, 'SpatialSound'),
            ('spatialize', True, FieldType.SFBool, AccessType.initializeOnly, 'SpatialSound'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 coneInnerAngle=6.2832,
                 coneOuterAngle=6.2832,
                 coneOuterGain=0,
                 description='',
                 direction=(0, 0, 1),
                 distanceModel='inverse',
                 enabled=True,
                 enableHRTF=False,
                 intensity=1,
                 location=(0, 0, 0),
                 maxDistance=10000,
                 priority=0,
                 referenceDistance=1,
                 rolloffFactor=1,
                 spatialize=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SpatialSound __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.coneInnerAngle = coneInnerAngle
        self.coneOuterAngle = coneOuterAngle
        self.coneOuterGain = coneOuterGain
        self.description = description
        self.direction = direction
        self.distanceModel = distanceModel
        self.enabled = enabled
        self.enableHRTF = enableHRTF
        self.intensity = intensity
        self.location = location
        self.maxDistance = maxDistance
        self.priority = priority
        self.referenceDistance = referenceDistance
        self.rolloffFactor = rolloffFactor
        self.spatialize = spatialize
    @property # getter - - - - - - - - - -
    def coneInnerAngle(self):
        """[0,2pi] coneInnerAngle is centered along direction and defines the inner conical volume, inside of which no source gain reduction occurs."""
        return self.__coneInnerAngle
    @coneInnerAngle.setter
    def coneInnerAngle(self, coneInnerAngle):
        if  coneInnerAngle is None:
            coneInnerAngle = 6.2832 # default
        assertValidSFFloat(coneInnerAngle)
        assertGreaterThanEquals('coneInnerAngle', coneInnerAngle, 0)
        assertLessThanEquals('coneInnerAngle', coneInnerAngle, 6.2832)
        self.__coneInnerAngle = coneInnerAngle
    @property # getter - - - - - - - - - -
    def coneOuterAngle(self):
        """[0,2pi] coneOuterAngle is centered along direction and defines an outer conical volume, within which the sound gain decreases linearly from full gain to coneOuterGain."""
        return self.__coneOuterAngle
    @coneOuterAngle.setter
    def coneOuterAngle(self, coneOuterAngle):
        if  coneOuterAngle is None:
            coneOuterAngle = 6.2832 # default
        assertValidSFFloat(coneOuterAngle)
        assertGreaterThanEquals('coneOuterAngle', coneOuterAngle, 0)
        assertLessThanEquals('coneOuterAngle', coneOuterAngle, 6.2832)
        self.__coneOuterAngle = coneOuterAngle
    @property # getter - - - - - - - - - -
    def coneOuterGain(self):
        """(-infinity,+infinity) coneOuterGain is minimum gain value found outside coneOuterAngle."""
        return self.__coneOuterGain
    @coneOuterGain.setter
    def coneOuterGain(self, coneOuterGain):
        if  coneOuterGain is None:
            coneOuterGain = 0 # default
        assertValidSFFloat(coneOuterGain)
        self.__coneOuterGain = coneOuterGain
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def direction(self):
        """direction of sound axis, relative to local coordinate system."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 0, 1) # default
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def distanceModel(self):
        """distanceModel determines how field specifies which algorithm to use for sound attenuation, corresponding to distance between an audio source and a listener, as it moves away from the listener."""
        return self.__distanceModel
    @distanceModel.setter
    def distanceModel(self, distanceModel):
        if  distanceModel is None:
            distanceModel = 'inverse' # default
        assertValidSFString(distanceModel)
        assertValidDistanceModel('distanceModel', distanceModel)
        self.__distanceModel = distanceModel
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def enableHRTF(self):
        """enableHRTF enables/disables Head Related Transfer Function (HRTF) auralization, if available."""
        return self.__enableHRTF
    @enableHRTF.setter
    def enableHRTF(self, enableHRTF):
        if  enableHRTF is None:
            enableHRTF = False # default
        assertValidSFBool(enableHRTF)
        self.__enableHRTF = enableHRTF
    @property # getter - - - - - - - - - -
    def intensity(self):
        """Factor [0,1] adjusting loudness (decibels) of emitted sound."""
        return self.__intensity
    @intensity.setter
    def intensity(self, intensity):
        if  intensity is None:
            intensity = 1 # default
        assertValidSFFloat(intensity)
        assertZeroToOne('intensity', intensity)
        self.__intensity = intensity
    @property # getter - - - - - - - - - -
    def location(self):
        """[0,+infinity) Position of sound ellipsoid center, relative to local coordinate system."""
        return self.__location
    @location.setter
    def location(self, location):
        if  location is None:
            location = (0, 0, 0) # default
        assertValidSFVec3f(location)
        self.__location = location
    @property # getter - - - - - - - - - -
    def maxDistance(self):
        """[0,+infinity) maxDistance is the maximum distance where sound is renderable between source and listener, after which no reduction in sound volume occurs."""
        return self.__maxDistance
    @maxDistance.setter
    def maxDistance(self, maxDistance):
        if  maxDistance is None:
            maxDistance = 10000 # default
        assertValidSFFloat(maxDistance)
        assertNonNegative('maxDistance', maxDistance)
        self.__maxDistance = maxDistance
    @property # getter - - - - - - - - - -
    def priority(self):
        """Player hint [0,1] if needed to choose which sounds to play."""
        return self.__priority
    @priority.setter
    def priority(self, priority):
        if  priority is None:
            priority = 0 # default
        assertValidSFFloat(priority)
        assertZeroToOne('priority', priority)
        self.__priority = priority
    @property # getter - - - - - - - - - -
    def referenceDistance(self):
        """[0,+infinity) referenceDistance for reducing volume as source moves further from the listener."""
        return self.__referenceDistance
    @referenceDistance.setter
    def referenceDistance(self, referenceDistance):
        if  referenceDistance is None:
            referenceDistance = 1 # default
        assertValidSFFloat(referenceDistance)
        assertNonNegative('referenceDistance', referenceDistance)
        self.__referenceDistance = referenceDistance
    @property # getter - - - - - - - - - -
    def rolloffFactor(self):
        """[0,+infinity) rolloffFactor indicates how quickly volume is reduced as source moves further from listener."""
        return self.__rolloffFactor
    @rolloffFactor.setter
    def rolloffFactor(self, rolloffFactor):
        if  rolloffFactor is None:
            rolloffFactor = 1 # default
        assertValidSFFloat(rolloffFactor)
        assertNonNegative('rolloffFactor', rolloffFactor)
        self.__rolloffFactor = rolloffFactor
    @property # getter - - - - - - - - - -
    def spatialize(self):
        """Whether to spatialize sound playback relative to viewer."""
        return self.__spatialize
    @spatialize.setter
    def spatialize(self, spatialize):
        if  spatialize is None:
            spatialize = True # default
        assertValidSFBool(spatialize)
        self.__spatialize = spatialize
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function SpatialSound.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<SpatialSound'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.coneInnerAngle != 6.2832:
            result += " coneInnerAngle='" + SFFloat(self.coneInnerAngle).XML() + "'"
        if self.coneOuterAngle != 6.2832:
            result += " coneOuterAngle='" + SFFloat(self.coneOuterAngle).XML() + "'"
        if self.coneOuterGain != 0:
            result += " coneOuterGain='" + SFFloat(self.coneOuterGain).XML() + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.direction != (0, 0, 1):
            result += " direction='" + SFVec3f(self.direction).XML() + "'"
        if self.distanceModel != 'inverse':
            result += " distanceModel='" + self.distanceModel + "'"
        if self.enableHRTF: # default=false
            result += " enableHRTF='" + SFBool(self.enableHRTF).XML() + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.intensity != 1:
            result += " intensity='" + SFFloat(self.intensity).XML() + "'"
        if self.location != (0, 0, 0):
            result += " location='" + SFVec3f(self.location).XML() + "'"
        if self.maxDistance != 10000:
            result += " maxDistance='" + SFFloat(self.maxDistance).XML() + "'"
        if self.priority != 0:
            result += " priority='" + SFFloat(self.priority).XML() + "'"
        if self.referenceDistance != 1:
            result += " referenceDistance='" + SFFloat(self.referenceDistance).XML() + "'"
        if self.rolloffFactor != 1:
            result += " rolloffFactor='" + SFFloat(self.rolloffFactor).XML() + "'"
        if not self.spatialize: # default=true
            result += " spatialize='" + SFBool(self.spatialize).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></SpatialSound>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</SpatialSound>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function SpatialSound.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'SpatialSound' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'SpatialSound' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.coneInnerAngle != 6.2832:
            result += " coneInnerAngle " + SFFloat(self.coneInnerAngle).VRML() + ""
        if self.coneOuterAngle != 6.2832:
            result += " coneOuterAngle " + SFFloat(self.coneOuterAngle).VRML() + ""
        if self.coneOuterGain != 0:
            result += " coneOuterGain " + SFFloat(self.coneOuterGain).VRML() + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.direction != (0, 0, 1):
            result += " direction " + SFVec3f(self.direction).VRML() + ""
        if self.distanceModel != 'inverse':
            result += " distanceModel " +  '"' + self.distanceModel + '"' + ""
        if self.enableHRTF: # default=false
            result += " enableHRTF " + SFBool(self.enableHRTF).VRML() + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.intensity != 1:
            result += " intensity " + SFFloat(self.intensity).VRML() + ""
        if self.location != (0, 0, 0):
            result += " location " + SFVec3f(self.location).VRML() + ""
        if self.maxDistance != 10000:
            result += " maxDistance " + SFFloat(self.maxDistance).VRML() + ""
        if self.priority != 0:
            result += " priority " + SFFloat(self.priority).VRML() + ""
        if self.referenceDistance != 1:
            result += " referenceDistance " + SFFloat(self.referenceDistance).VRML() + ""
        if self.rolloffFactor != 1:
            result += " rolloffFactor " + SFFloat(self.rolloffFactor).VRML() + ""
        if not self.spatialize: # default=true
            result += " spatialize " + SFBool(self.spatialize).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Sphere(_X3DGeometryNode):
    """
    Sphere is a geometry node, representing a perfectly round geometrical object that is the surface of a completely round ball.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Sphere'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geometry3D.html#Sphere'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Sphere'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('radius', 1, FieldType.SFFloat, AccessType.initializeOnly, 'Sphere'),
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'Sphere'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 radius=1,
                 solid=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Sphere __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.radius = radius
        self.solid = solid
    @property # getter - - - - - - - - - -
    def radius(self):
        """(0,+infinity) Size in meters."""
        return self.__radius
    @radius.setter
    def radius(self, radius):
        if  radius is None:
            radius = 1 # default
        assertValidSFFloat(radius)
        assertPositive('radius', radius)
        self.__radius = radius
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Sphere.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Sphere'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.radius != 1:
            result += " radius='" + SFFloat(self.radius).XML() + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Sphere>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Sphere>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Sphere.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Sphere' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Sphere' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.radius != 1:
            result += " radius " + SFFloat(self.radius).VRML() + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class SphereSensor(_X3DDragSensorNode):
    """
    SphereSensor converts pointing device motion into a spherical rotation about the origin of the local coordinate system.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'SphereSensor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/pointingDeviceSensor.html#SphereSensor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SphereSensor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('autoOffset', True, FieldType.SFBool, AccessType.inputOutput, 'X3DDragSensorNode'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DPointingDeviceSensorNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('offset', (0, 1, 0, 0), FieldType.SFRotation, AccessType.inputOutput, 'SphereSensor'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 autoOffset=True,
                 description='',
                 enabled=True,
                 offset=(0, 1, 0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SphereSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.autoOffset = autoOffset
        self.description = description
        self.enabled = enabled
        self.offset = offset
    @property # getter - - - - - - - - - -
    def autoOffset(self):
        """Determines whether previous offset values are remembered/accumulated."""
        return self.__autoOffset
    @autoOffset.setter
    def autoOffset(self, autoOffset):
        if  autoOffset is None:
            autoOffset = True # default
        assertValidSFBool(autoOffset)
        self.__autoOffset = autoOffset
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def offset(self):
        """Sends event and remembers last value sensed."""
        return self.__offset
    @offset.setter
    def offset(self, offset):
        if  offset is None:
            offset = (0, 1, 0, 0) # default
        assertValidSFRotation(offset)
        self.__offset = offset
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function SphereSensor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<SphereSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.autoOffset: # default=true
            result += " autoOffset='" + SFBool(self.autoOffset).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.offset != (0, 1, 0, 0):
            result += " offset='" + SFRotation(self.offset).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></SphereSensor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</SphereSensor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function SphereSensor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'SphereSensor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'SphereSensor' + ' {'
        if not self.autoOffset: # default=true
            result += " autoOffset " + SFBool(self.autoOffset).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.offset != (0, 1, 0, 0):
            result += " offset " + SFRotation(self.offset).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class SplinePositionInterpolator(_X3DInterpolatorNode):
    """
    SplinePositionInterpolator performs non-linear interpolation among paired lists of 3-tuple values and velocities to produce an SFVec3f value_changed output event.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'SplinePositionInterpolator'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/interpolators.html#SplinePositionInterpolator'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SplinePositionInterpolator'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('closed', False, FieldType.SFBool, AccessType.initializeOnly, 'SplinePositionInterpolator'),
            ('key', list(), FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
            ('keyValue', list(), FieldType.MFVec3f, AccessType.inputOutput, 'SplinePositionInterpolator'),
            ('keyVelocity', list(), FieldType.MFVec3f, AccessType.inputOutput, 'SplinePositionInterpolator'),
            ('normalizeVelocity', False, FieldType.SFBool, AccessType.inputOutput, 'SplinePositionInterpolator'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 closed=False,
                 key=list(),
                 keyValue=list(),
                 keyVelocity=list(),
                 normalizeVelocity=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SplinePositionInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.closed = closed
        self.key = key
        self.keyValue = keyValue
        self.keyVelocity = keyVelocity
        self.normalizeVelocity = normalizeVelocity
    @property # getter - - - - - - - - - -
    def closed(self):
        """Whether or not the curve is closed (i."""
        return self.__closed
    @closed.setter
    def closed(self, closed):
        if  closed is None:
            closed = False # default
        assertValidSFBool(closed)
        self.__closed = closed
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition parameters for nonlinear-interpolation function time intervals, listed in non-decreasing order and corresponding to keyValue, keyVelocity array values."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for nonlinear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFVec3f.DEFAULT_VALUE(self)
        assertValidMFVec3f(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def keyVelocity(self):
        """Output values for nonlinear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyVelocity
    @keyVelocity.setter
    def keyVelocity(self, keyVelocity):
        if  keyVelocity is None:
            keyVelocity = MFVec3f.DEFAULT_VALUE(self)
        assertValidMFVec3f(keyVelocity)
        self.__keyVelocity = keyVelocity
    @property # getter - - - - - - - - - -
    def normalizeVelocity(self):
        """normalizeVelocity field specifies whether the velocity vectors are normalized to produce smooth speed transitions, or transformed into tangency vectors."""
        return self.__normalizeVelocity
    @normalizeVelocity.setter
    def normalizeVelocity(self, normalizeVelocity):
        if  normalizeVelocity is None:
            normalizeVelocity = False # default
        assertValidSFBool(normalizeVelocity)
        self.__normalizeVelocity = normalizeVelocity
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function SplinePositionInterpolator.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<SplinePositionInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.closed: # default=false
            result += " closed='" + SFBool(self.closed).XML() + "'"
        if self.key != list():
            result += " key='" + MFFloat(self.key).XML() + "'"
        if self.keyValue != list():
            result += " keyValue='" + MFVec3f(self.keyValue).XML() + "'"
        if self.keyVelocity != list():
            result += " keyVelocity='" + MFVec3f(self.keyVelocity).XML() + "'"
        if self.normalizeVelocity: # default=false
            result += " normalizeVelocity='" + SFBool(self.normalizeVelocity).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></SplinePositionInterpolator>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</SplinePositionInterpolator>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function SplinePositionInterpolator.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'SplinePositionInterpolator' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'SplinePositionInterpolator' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.closed: # default=false
            result += " closed " + SFBool(self.closed).VRML() + ""
        if self.key != list():
            result += " key " + MFFloat(self.key).VRML() + ""
        if self.keyValue != list():
            result += " keyValue " + MFVec3f(self.keyValue).VRML() + ""
        if self.keyVelocity != list():
            result += " keyVelocity " + MFVec3f(self.keyVelocity).VRML() + ""
        if self.normalizeVelocity: # default=false
            result += " normalizeVelocity " + SFBool(self.normalizeVelocity).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class SplinePositionInterpolator2D(_X3DInterpolatorNode):
    """
    SplinePositionInterpolator2D performs non-linear interpolation among paired lists of 2-tuple values and velocities to produce an SFVec2f value_changed output event.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'SplinePositionInterpolator2D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/interpolators.html#SplinePositionInterpolator2D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SplinePositionInterpolator2D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('closed', False, FieldType.SFBool, AccessType.initializeOnly, 'SplinePositionInterpolator2D'),
            ('key', list(), FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
            ('keyValue', list(), FieldType.MFVec2f, AccessType.inputOutput, 'SplinePositionInterpolator2D'),
            ('keyVelocity', list(), FieldType.MFVec2f, AccessType.inputOutput, 'SplinePositionInterpolator2D'),
            ('normalizeVelocity', False, FieldType.SFBool, AccessType.inputOutput, 'SplinePositionInterpolator2D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 closed=False,
                 key=list(),
                 keyValue=list(),
                 keyVelocity=list(),
                 normalizeVelocity=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SplinePositionInterpolator2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.closed = closed
        self.key = key
        self.keyValue = keyValue
        self.keyVelocity = keyVelocity
        self.normalizeVelocity = normalizeVelocity
    @property # getter - - - - - - - - - -
    def closed(self):
        """Whether or not the curve is closed (i."""
        return self.__closed
    @closed.setter
    def closed(self, closed):
        if  closed is None:
            closed = False # default
        assertValidSFBool(closed)
        self.__closed = closed
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition parameters for nonlinear-interpolation function time intervals, listed in non-decreasing order and corresponding to keyValue, keyVelocity array values."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for nonlinear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFVec2f.DEFAULT_VALUE(self)
        assertValidMFVec2f(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def keyVelocity(self):
        """Output values for nonlinear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyVelocity
    @keyVelocity.setter
    def keyVelocity(self, keyVelocity):
        if  keyVelocity is None:
            keyVelocity = MFVec2f.DEFAULT_VALUE(self)
        assertValidMFVec2f(keyVelocity)
        self.__keyVelocity = keyVelocity
    @property # getter - - - - - - - - - -
    def normalizeVelocity(self):
        """normalizeVelocity field specifies whether the velocity vectors are normalized to produce smooth speed transitions, or transformed into tangency vectors."""
        return self.__normalizeVelocity
    @normalizeVelocity.setter
    def normalizeVelocity(self, normalizeVelocity):
        if  normalizeVelocity is None:
            normalizeVelocity = False # default
        assertValidSFBool(normalizeVelocity)
        self.__normalizeVelocity = normalizeVelocity
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function SplinePositionInterpolator2D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<SplinePositionInterpolator2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.closed: # default=false
            result += " closed='" + SFBool(self.closed).XML() + "'"
        if self.key != list():
            result += " key='" + MFFloat(self.key).XML() + "'"
        if self.keyValue != list():
            result += " keyValue='" + MFVec2f(self.keyValue).XML() + "'"
        if self.keyVelocity != list():
            result += " keyVelocity='" + MFVec2f(self.keyVelocity).XML() + "'"
        if self.normalizeVelocity: # default=false
            result += " normalizeVelocity='" + SFBool(self.normalizeVelocity).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></SplinePositionInterpolator2D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</SplinePositionInterpolator2D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function SplinePositionInterpolator2D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'SplinePositionInterpolator2D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'SplinePositionInterpolator2D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.closed: # default=false
            result += " closed " + SFBool(self.closed).VRML() + ""
        if self.key != list():
            result += " key " + MFFloat(self.key).VRML() + ""
        if self.keyValue != list():
            result += " keyValue " + MFVec2f(self.keyValue).VRML() + ""
        if self.keyVelocity != list():
            result += " keyVelocity " + MFVec2f(self.keyVelocity).VRML() + ""
        if self.normalizeVelocity: # default=false
            result += " normalizeVelocity " + SFBool(self.normalizeVelocity).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class SplineScalarInterpolator(_X3DInterpolatorNode):
    """
    SplineScalarInterpolator performs non-linear interpolation among paired lists of float values and velocities to produce an SFFloat value_changed output event.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'SplineScalarInterpolator'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/interpolators.html#SplineScalarInterpolator'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SplineScalarInterpolator'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('closed', False, FieldType.SFBool, AccessType.initializeOnly, 'SplineScalarInterpolator'),
            ('key', list(), FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
            ('keyValue', list(), FieldType.MFFloat, AccessType.inputOutput, 'SplineScalarInterpolator'),
            ('keyVelocity', list(), FieldType.MFFloat, AccessType.inputOutput, 'SplineScalarInterpolator'),
            ('normalizeVelocity', False, FieldType.SFBool, AccessType.inputOutput, 'SplineScalarInterpolator'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 closed=False,
                 key=list(),
                 keyValue=list(),
                 keyVelocity=list(),
                 normalizeVelocity=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SplineScalarInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.closed = closed
        self.key = key
        self.keyValue = keyValue
        self.keyVelocity = keyVelocity
        self.normalizeVelocity = normalizeVelocity
    @property # getter - - - - - - - - - -
    def closed(self):
        """Whether or not the curve is closed (i."""
        return self.__closed
    @closed.setter
    def closed(self, closed):
        if  closed is None:
            closed = False # default
        assertValidSFBool(closed)
        self.__closed = closed
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition parameters for nonlinear-interpolation function time intervals, listed in non-decreasing order and corresponding to keyValue, keyVelocity array values."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for nonlinear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def keyVelocity(self):
        """Output values for nonlinear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyVelocity
    @keyVelocity.setter
    def keyVelocity(self, keyVelocity):
        if  keyVelocity is None:
            keyVelocity = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(keyVelocity)
        self.__keyVelocity = keyVelocity
    @property # getter - - - - - - - - - -
    def normalizeVelocity(self):
        """normalizeVelocity field specifies whether the velocity vectors are normalized to produce smooth speed transitions, or transformed into tangency vectors."""
        return self.__normalizeVelocity
    @normalizeVelocity.setter
    def normalizeVelocity(self, normalizeVelocity):
        if  normalizeVelocity is None:
            normalizeVelocity = False # default
        assertValidSFBool(normalizeVelocity)
        self.__normalizeVelocity = normalizeVelocity
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function SplineScalarInterpolator.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<SplineScalarInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.closed: # default=false
            result += " closed='" + SFBool(self.closed).XML() + "'"
        if self.key != list():
            result += " key='" + MFFloat(self.key).XML() + "'"
        if self.keyValue != list():
            result += " keyValue='" + MFFloat(self.keyValue).XML() + "'"
        if self.keyVelocity != list():
            result += " keyVelocity='" + MFFloat(self.keyVelocity).XML() + "'"
        if self.normalizeVelocity: # default=false
            result += " normalizeVelocity='" + SFBool(self.normalizeVelocity).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></SplineScalarInterpolator>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</SplineScalarInterpolator>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function SplineScalarInterpolator.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'SplineScalarInterpolator' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'SplineScalarInterpolator' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.closed: # default=false
            result += " closed " + SFBool(self.closed).VRML() + ""
        if self.key != list():
            result += " key " + MFFloat(self.key).VRML() + ""
        if self.keyValue != list():
            result += " keyValue " + MFFloat(self.keyValue).VRML() + ""
        if self.keyVelocity != list():
            result += " keyVelocity " + MFFloat(self.keyVelocity).VRML() + ""
        if self.normalizeVelocity: # default=false
            result += " normalizeVelocity " + SFBool(self.normalizeVelocity).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class SpotLight(_X3DLightNode):
    """
    Linear attenuation may occur at level 2, full support at level 3.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'SpotLight'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/lighting.html#SpotLight'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SpotLight'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ambientIntensity', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
            ('attenuation', (1, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'SpotLight'),
            ('beamWidth', 0.7854, FieldType.SFFloat, AccessType.inputOutput, 'SpotLight'),
            ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'X3DLightNode'),
            ('cutOffAngle', 1.570796, FieldType.SFFloat, AccessType.inputOutput, 'SpotLight'),
            ('direction', (0, 0, -1), FieldType.SFVec3f, AccessType.inputOutput, 'SpotLight'),
            ('global_', True, FieldType.SFBool, AccessType.inputOutput, 'SpotLight'),
            ('intensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
            ('location', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'SpotLight'),
            ('on', True, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
            ('radius', 100, FieldType.SFFloat, AccessType.initializeOnly, 'SpotLight'),
            ('shadowIntensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
            ('shadows', False, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ambientIntensity=0,
                 attenuation=(1, 0, 0),
                 beamWidth=0.7854,
                 color=(1, 1, 1),
                 cutOffAngle=1.570796,
                 direction=(0, 0, -1),
                 global_=True,
                 intensity=1,
                 location=(0, 0, 0),
                 on=True,
                 radius=100,
                 shadowIntensity=1,
                 shadows=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SpotLight __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.attenuation = attenuation
        self.beamWidth = beamWidth
        self.color = color
        self.cutOffAngle = cutOffAngle
        self.direction = direction
        self.global_ = global_
        self.intensity = intensity
        self.location = location
        self.on = on
        self.radius = radius
        self.shadowIntensity = shadowIntensity
        self.shadows = shadows
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        """[0,1] Brightness of ambient (nondirectional background) emission from the light."""
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity):
        if  ambientIntensity is None:
            ambientIntensity = 0 # default
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def attenuation(self):
        """Constant, linear-distance and squared-distance dropoff factors as radial distance increases from the source."""
        return self.__attenuation
    @attenuation.setter
    def attenuation(self, attenuation):
        if  attenuation is None:
            attenuation = (1, 0, 0) # default
        assertValidSFVec3f(attenuation)
        assertNonNegative('attenuation', attenuation)
        self.__attenuation = attenuation
    @property # getter - - - - - - - - - -
    def beamWidth(self):
        """[0,1."""
        return self.__beamWidth
    @beamWidth.setter
    def beamWidth(self, beamWidth):
        if  beamWidth is None:
            beamWidth = 0.7854 # default
        assertValidSFFloat(beamWidth)
        assertGreaterThan('beamWidth', beamWidth, 0)
        assertLessThanEquals('beamWidth', beamWidth, 1.570796)
        self.__beamWidth = beamWidth
    @property # getter - - - - - - - - - -
    def color(self):
        """[0,1] color of light, applied to colors of objects."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = (1, 1, 1) # default
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def cutOffAngle(self):
        """[0,1."""
        return self.__cutOffAngle
    @cutOffAngle.setter
    def cutOffAngle(self, cutOffAngle):
        if  cutOffAngle is None:
            cutOffAngle = 1.570796 # default
        assertValidSFFloat(cutOffAngle)
        assertGreaterThan('cutOffAngle', cutOffAngle, 0)
        assertLessThanEquals('cutOffAngle', cutOffAngle, 1.570796)
        self.__cutOffAngle = cutOffAngle
    @property # getter - - - - - - - - - -
    def direction(self):
        """Orientation vector of light relative to local coordinate system."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 0, -1) # default
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def global_(self): # Appended underscore to field name to avoid naming collision with Python reserved word
        return self.__global_
    @global_.setter
    def global_(self, global_):
        if  global_ is None:
            global_ = True # default
        assertValidSFBool(global_)
        self.__global_ = global_
    @property # getter - - - - - - - - - -
    def intensity(self):
        """[0,1] Brightness of direct emission from the light."""
        return self.__intensity
    @intensity.setter
    def intensity(self, intensity):
        if  intensity is None:
            intensity = 1 # default
        assertValidSFFloat(intensity)
        assertZeroToOne('intensity', intensity)
        self.__intensity = intensity
    @property # getter - - - - - - - - - -
    def location(self):
        """Position of light relative to local coordinate system."""
        return self.__location
    @location.setter
    def location(self, location):
        if  location is None:
            location = (0, 0, 0) # default
        assertValidSFVec3f(location)
        self.__location = location
    @property # getter - - - - - - - - - -
    def on(self):
        """Enables/disables this light source."""
        return self.__on
    @on.setter
    def on(self, on):
        if  on is None:
            on = True # default
        assertValidSFBool(on)
        self.__on = on
    @property # getter - - - - - - - - - -
    def radius(self):
        """Maximum effective distance of light relative to local light position, affected by ancestor scaling."""
        return self.__radius
    @radius.setter
    def radius(self, radius):
        if  radius is None:
            radius = 100 # default
        assertValidSFFloat(radius)
        assertNonNegative('radius', radius)
        self.__radius = radius
    @property # getter - - - - - - - - - -
    def shadowIntensity(self):
        """[0,1] shadowIntensity field defines how much light is obscured by shapes that cast shadows, ranging from 0 (light not obscured, no visible shadows) to 1 (light completely obscured, full-intensity shadows)."""
        return self.__shadowIntensity
    @shadowIntensity.setter
    def shadowIntensity(self, shadowIntensity):
        if  shadowIntensity is None:
            shadowIntensity = 1 # default
        assertValidSFFloat(shadowIntensity)
        assertZeroToOne('shadowIntensity', shadowIntensity)
        self.__shadowIntensity = shadowIntensity
    @property # getter - - - - - - - - - -
    def shadows(self):
        """shadows field indicates whether or not this light casts a shadow behind illuminated X3DShapeNode geometry."""
        return self.__shadows
    @shadows.setter
    def shadows(self, shadows):
        if  shadows is None:
            shadows = False # default
        assertValidSFBool(shadows)
        self.__shadows = shadows
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function SpotLight.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<SpotLight'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ambientIntensity != 0:
            result += " ambientIntensity='" + SFFloat(self.ambientIntensity).XML() + "'"
        if self.attenuation != (1, 0, 0):
            result += " attenuation='" + SFVec3f(self.attenuation).XML() + "'"
        if self.beamWidth != 0.7854:
            result += " beamWidth='" + SFFloat(self.beamWidth).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.color != (1, 1, 1):
            result += " color='" + SFColor(self.color).XML() + "'"
        if self.cutOffAngle != 1.570796:
            result += " cutOffAngle='" + SFFloat(self.cutOffAngle).XML() + "'"
        if self.direction != (0, 0, -1):
            result += " direction='" + SFVec3f(self.direction).XML() + "'"
        if not self.global_: # default=true
            result += " global_='" + SFBool(self.global_).XML() + "'"
        if self.intensity != 1:
            result += " intensity='" + SFFloat(self.intensity).XML() + "'"
        if self.location != (0, 0, 0):
            result += " location='" + SFVec3f(self.location).XML() + "'"
        if not self.on: # default=true
            result += " on='" + SFBool(self.on).XML() + "'"
        if self.radius != 100:
            result += " radius='" + SFFloat(self.radius).XML() + "'"
        if self.shadowIntensity != 1:
            result += " shadowIntensity='" + SFFloat(self.shadowIntensity).XML() + "'"
        if self.shadows: # default=false
            result += " shadows='" + SFBool(self.shadows).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></SpotLight>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</SpotLight>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function SpotLight.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'SpotLight' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'SpotLight' + ' {'
        if self.ambientIntensity != 0:
            result += " ambientIntensity " + SFFloat(self.ambientIntensity).VRML() + ""
        if self.attenuation != (1, 0, 0):
            result += " attenuation " + SFVec3f(self.attenuation).VRML() + ""
        if self.beamWidth != 0.7854:
            result += " beamWidth " + SFFloat(self.beamWidth).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.color != (1, 1, 1):
            result += " color " + SFColor(self.color).VRML() + ""
        if self.cutOffAngle != 1.570796:
            result += " cutOffAngle " + SFFloat(self.cutOffAngle).VRML() + ""
        if self.direction != (0, 0, -1):
            result += " direction " + SFVec3f(self.direction).VRML() + ""
        if not self.global_: # default=true
            result += " global_ " + SFBool(self.global_).VRML() + ""
        if self.intensity != 1:
            result += " intensity " + SFFloat(self.intensity).VRML() + ""
        if self.location != (0, 0, 0):
            result += " location " + SFVec3f(self.location).VRML() + ""
        if not self.on: # default=true
            result += " on " + SFBool(self.on).VRML() + ""
        if self.radius != 100:
            result += " radius " + SFFloat(self.radius).VRML() + ""
        if self.shadowIntensity != 1:
            result += " shadowIntensity " + SFFloat(self.shadowIntensity).VRML() + ""
        if self.shadows: # default=false
            result += " shadows " + SFBool(self.shadows).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class SquadOrientationInterpolator(_X3DInterpolatorNode):
    """
    SquadOrientationInterpolator performs non-linear interpolation among paired lists of rotation values to produce an SFRotation value_changed output event.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'SquadOrientationInterpolator'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/interpolators.html#SquadOrientationInterpolator'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SquadOrientationInterpolator'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('key', list(), FieldType.MFFloat, AccessType.inputOutput, 'X3DInterpolatorNode'),
            ('keyValue', list(), FieldType.MFRotation, AccessType.inputOutput, 'SquadOrientationInterpolator'),
            ('normalizeVelocity', False, FieldType.SFBool, AccessType.inputOutput, 'SquadOrientationInterpolator'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 key=list(),
                 keyValue=list(),
                 normalizeVelocity=False,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SquadOrientationInterpolator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.key = key
        self.keyValue = keyValue
        self.normalizeVelocity = normalizeVelocity
    @property # getter - - - - - - - - - -
    def key(self):
        """Definition parameters for nonlinear-interpolation function time intervals, listed in non-decreasing order and corresponding to keyValue, keyVelocity array values."""
        return self.__key
    @key.setter
    def key(self, key):
        if  key is None:
            key = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(key)
        self.__key = key
    @property # getter - - - - - - - - - -
    def keyValue(self):
        """Output values for nonlinear interpolation, each corresponding to an input-fraction value in the key array."""
        return self.__keyValue
    @keyValue.setter
    def keyValue(self, keyValue):
        if  keyValue is None:
            keyValue = MFRotation.DEFAULT_VALUE(self)
        assertValidMFRotation(keyValue)
        self.__keyValue = keyValue
    @property # getter - - - - - - - - - -
    def normalizeVelocity(self):
        """normalizeVelocity field specifies whether the velocity vectors are normalized to produce smooth speed transitions, or transformed into tangency vectors."""
        return self.__normalizeVelocity
    @normalizeVelocity.setter
    def normalizeVelocity(self, normalizeVelocity):
        if  normalizeVelocity is None:
            normalizeVelocity = False # default
        assertValidSFBool(normalizeVelocity)
        self.__normalizeVelocity = normalizeVelocity
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function SquadOrientationInterpolator.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<SquadOrientationInterpolator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.key != list():
            result += " key='" + MFFloat(self.key).XML() + "'"
        if self.keyValue != list():
            result += " keyValue='" + MFRotation(self.keyValue).XML() + "'"
        if self.normalizeVelocity: # default=false
            result += " normalizeVelocity='" + SFBool(self.normalizeVelocity).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></SquadOrientationInterpolator>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</SquadOrientationInterpolator>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function SquadOrientationInterpolator.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'SquadOrientationInterpolator' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'SquadOrientationInterpolator' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.key != list():
            result += " key " + MFFloat(self.key).VRML() + ""
        if self.keyValue != list():
            result += " keyValue " + MFRotation(self.keyValue).VRML() + ""
        if self.normalizeVelocity: # default=false
            result += " normalizeVelocity " + SFBool(self.normalizeVelocity).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class StaticGroup(_X3DChildNode, _X3DBoundedObject):
    """
    StaticGroup is similar to Group node but does not allow access to children after creation time.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'StaticGroup'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/grouping.html#StaticGroup'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#StaticGroup'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('children', list(), FieldType.MFNode, AccessType.initializeOnly, 'StaticGroup'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 visible=True,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode StaticGroup __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.visible = visible
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function StaticGroup.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<StaticGroup'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></StaticGroup>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* StaticGroup found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</StaticGroup>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function StaticGroup.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'StaticGroup' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'StaticGroup' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class StreamAudioDestination(_X3DSoundDestinationNode):
    """
    StreamAudioDestination node represents the final audio destination via a media stream.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'StreamAudioDestination'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#StreamAudioDestination'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#StreamAudioDestination'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('channelCountMode', 'max', FieldType.SFString, AccessType.inputOutput, 'X3DSoundDestinationNode'),
            ('channelInterpretation', 'speakers', FieldType.SFString, AccessType.inputOutput, 'X3DSoundDestinationNode'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DSoundNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundNode'),
            ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundDestinationNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 channelCountMode='max',
                 channelInterpretation='speakers',
                 description='',
                 enabled=True,
                 gain=1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode StreamAudioDestination __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.gain = gain
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'max' # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'speakers' # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1 # default
        assertValidSFFloat(gain)
        self.__gain = gain
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function StreamAudioDestination.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<StreamAudioDestination'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.channelCountMode != 'max':
            result += " channelCountMode='" + self.channelCountMode + "'"
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation='" + self.channelInterpretation + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.gain != 1:
            result += " gain='" + SFFloat(self.gain).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></StreamAudioDestination>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</StreamAudioDestination>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function StreamAudioDestination.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'StreamAudioDestination' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'StreamAudioDestination' + ' {'
        if self.channelCountMode != 'max':
            result += " channelCountMode " +  '"' + self.channelCountMode + '"' + ""
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation " +  '"' + self.channelInterpretation + '"' + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.gain != 1:
            result += " gain " + SFFloat(self.gain).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class StreamAudioSource(_X3DSoundSourceNode):
    """
    StreamAudioSource operates as an audio source whose media is received from a MediaStream obtained using the WebRTC or Media Capture and Streams APIs.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'StreamAudioSource'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#StreamAudioSource'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#StreamAudioSource'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('channelCountMode', 'max', FieldType.SFString, AccessType.inputOutput, 'StreamAudioSource'),
            ('channelInterpretation', 'speakers', FieldType.SFString, AccessType.inputOutput, 'StreamAudioSource'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundSourceNode'),
            ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundSourceNode'),
            ('mediaStream', list(), FieldType.MFFloat, AccessType.inputOutput, 'StreamAudioSource'),
            ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 channelCountMode='max',
                 channelInterpretation='speakers',
                 description='',
                 enabled=True,
                 gain=1,
                 mediaStream=list(),
                 pauseTime=0,
                 resumeTime=0,
                 startTime=0,
                 stopTime=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode StreamAudioSource __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.mediaStream = mediaStream
        self.pauseTime = pauseTime
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'max' # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'speakers' # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1 # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def mediaStream(self):
        return self.__mediaStream
    @mediaStream.setter
    def mediaStream(self, mediaStream):
        if  mediaStream is None:
            mediaStream = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(mediaStream)
        assertGreaterThanEquals('mediaStream', mediaStream, -1)
        assertLessThanEquals('mediaStream', mediaStream, 1)
        self.__mediaStream = mediaStream
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0 # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0 # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0 # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0 # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function StreamAudioSource.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<StreamAudioSource'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.channelCountMode != 'max':
            result += " channelCountMode='" + self.channelCountMode + "'"
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation='" + self.channelInterpretation + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.gain != 1:
            result += " gain='" + SFFloat(self.gain).XML() + "'"
        if self.mediaStream != list():
            result += " mediaStream='" + MFFloat(self.mediaStream).XML() + "'"
        if self.pauseTime != 0:
            result += " pauseTime='" + SFTime(self.pauseTime).XML() + "'"
        if self.resumeTime != 0:
            result += " resumeTime='" + SFTime(self.resumeTime).XML() + "'"
        if self.startTime != 0:
            result += " startTime='" + SFTime(self.startTime).XML() + "'"
        if self.stopTime != 0:
            result += " stopTime='" + SFTime(self.stopTime).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></StreamAudioSource>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</StreamAudioSource>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function StreamAudioSource.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'StreamAudioSource' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'StreamAudioSource' + ' {'
        if self.channelCountMode != 'max':
            result += " channelCountMode " +  '"' + self.channelCountMode + '"' + ""
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation " +  '"' + self.channelInterpretation + '"' + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.gain != 1:
            result += " gain " + SFFloat(self.gain).VRML() + ""
        if self.mediaStream != list():
            result += " mediaStream " + MFFloat(self.mediaStream).VRML() + ""
        if self.pauseTime != 0:
            result += " pauseTime " + SFTime(self.pauseTime).VRML() + ""
        if self.resumeTime != 0:
            result += " resumeTime " + SFTime(self.resumeTime).VRML() + ""
        if self.startTime != 0:
            result += " startTime " + SFTime(self.startTime).VRML() + ""
        if self.stopTime != 0:
            result += " stopTime " + SFTime(self.stopTime).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class StringSensor(_X3DKeyDeviceSensorNode):
    """
    StringSensor generates events as the user presses keys on the keyboard.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'StringSensor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/keyDeviceSensor.html#StringSensor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#StringSensor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('deletionAllowed', True, FieldType.SFBool, AccessType.inputOutput, 'StringSensor'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 deletionAllowed=True,
                 enabled=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode StringSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.deletionAllowed = deletionAllowed
        self.enabled = enabled
    @property # getter - - - - - - - - - -
    def deletionAllowed(self):
        """If deletionAllowed is true, then previously entered character in enteredText can be removed."""
        return self.__deletionAllowed
    @deletionAllowed.setter
    def deletionAllowed(self, deletionAllowed):
        if  deletionAllowed is None:
            deletionAllowed = True # default
        assertValidSFBool(deletionAllowed)
        self.__deletionAllowed = deletionAllowed
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function StringSensor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<StringSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.deletionAllowed: # default=true
            result += " deletionAllowed='" + SFBool(self.deletionAllowed).XML() + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></StringSensor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</StringSensor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function StringSensor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'StringSensor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'StringSensor' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.deletionAllowed: # default=true
            result += " deletionAllowed " + SFBool(self.deletionAllowed).VRML() + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class SurfaceEmitter(_X3DParticleEmitterNode):
    """
    SurfaceEmitter generates particles from the surface of an object.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'SurfaceEmitter'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/particleSystems.html#SurfaceEmitter'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#SurfaceEmitter'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('coordIndex', [-1], FieldType.MFInt32, AccessType.initializeOnly, 'SurfaceEmitter'),
            ('mass', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('speed', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('surfaceArea', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('variation', 0.25, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('surface', None, FieldType.SFNode, AccessType.initializeOnly, 'SurfaceEmitter'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 coordIndex=[-1],
                 mass=0,
                 speed=0,
                 surfaceArea=0,
                 variation=0.25,
                 surface=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode SurfaceEmitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.coordIndex = coordIndex
        self.mass = mass
        self.speed = speed
        self.surfaceArea = surfaceArea
        self.variation = variation
        self.surface = surface
    @property # getter - - - - - - - - - -
    def coordIndex(self):
        """[-1,+infinity) coordIndex indices are applied to contained Coordinate values in order to define randomly generated initial geometry of the particles."""
        return self.__coordIndex
    @coordIndex.setter
    def coordIndex(self, coordIndex):
        if  coordIndex is None:
            coordIndex = [-1] # default
        assertValidMFInt32(coordIndex)
        assertGreaterThanEquals('coordIndex', coordIndex, -1)
        self.__coordIndex = coordIndex
    @property # getter - - - - - - - - - -
    def mass(self):
        """[0,+infinity) Basic mass of each particle, defined in mass base units (default is kilograms)."""
        return self.__mass
    @mass.setter
    def mass(self, mass):
        if  mass is None:
            mass = 0 # default
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def speed(self):
        """[0,+infinity) Initial linear speed (default is m/s) imparted to all particles along their direction of movement."""
        return self.__speed
    @speed.setter
    def speed(self, speed):
        if  speed is None:
            speed = 0 # default
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def surfaceArea(self):
        """[0,+infinity) Particle surface area in area base units (default is meters squared)."""
        return self.__surfaceArea
    @surfaceArea.setter
    def surfaceArea(self, surfaceArea):
        if  surfaceArea is None:
            surfaceArea = 0 # default
        assertValidSFFloat(surfaceArea)
        assertNonNegative('surfaceArea', surfaceArea)
        self.__surfaceArea = surfaceArea
    @property # getter - - - - - - - - - -
    def variation(self):
        """[0,+infinity) Multiplier for the randomness used to control the range of possible output values."""
        return self.__variation
    @variation.setter
    def variation(self, variation):
        if  variation is None:
            variation = 0.25 # default
        assertValidSFFloat(variation)
        assertNonNegative('variation', variation)
        self.__variation = variation
    @property # getter - - - - - - - - - -
    def surface(self):
        """[X3DGeometryNode] The geometry node provides geometry used as the emitting surface."""
        return self.__surface
    @surface.setter
    def surface(self, surface):
        if  surface is None:
            surface = None # default
        assertValidSFNode(surface)
        if not isinstance(surface, object):
            # print(flush=True)
            raise X3DTypeError(str(surface) + ' does not have a valid node type object')
        self.__surface = surface
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.surface
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function SurfaceEmitter.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<SurfaceEmitter'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.coordIndex != [-1]:
            result += " coordIndex='" + MFInt32(self.coordIndex).XML() + "'"
        if self.mass != 0:
            result += " mass='" + SFFloat(self.mass).XML() + "'"
        if self.speed != 0:
            result += " speed='" + SFFloat(self.speed).XML() + "'"
        if self.surfaceArea != 0:
            result += " surfaceArea='" + SFFloat(self.surfaceArea).XML() + "'"
        if self.variation != 0.25:
            result += " variation='" + SFFloat(self.variation).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></SurfaceEmitter>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.surface: # output this SFNode
                result += self.surface.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</SurfaceEmitter>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function SurfaceEmitter.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'SurfaceEmitter' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'SurfaceEmitter' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.coordIndex != [-1]:
            result += " coordIndex " + MFInt32(self.coordIndex).VRML() + ""
        if self.mass != 0:
            result += " mass " + SFFloat(self.mass).VRML() + ""
        if self.speed != 0:
            result += " speed " + SFFloat(self.speed).VRML() + ""
        if self.surfaceArea != 0:
            result += " surfaceArea " + SFFloat(self.surfaceArea).VRML() + ""
        if self.variation != 0.25:
            result += " variation " + SFFloat(self.variation).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.surface: # output this SFNode
            result += '\n' + '  ' + indent + 'surface ' + self.surface.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Switch(_X3DGroupingNode):
    """
    Switch is a Grouping node that only renders one (or zero) child at a time.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Switch'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/grouping.html#Switch'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Switch'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('whichChoice', -1, FieldType.SFInt32, AccessType.inputOutput, 'Switch'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 visible=True,
                 whichChoice=-1,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Switch __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.visible = visible
        self.whichChoice = whichChoice
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def whichChoice(self):
        """[-1,+infinity) Index of active child choice, counting from 0."""
        return self.__whichChoice
    @whichChoice.setter
    def whichChoice(self, whichChoice):
        if  whichChoice is None:
            whichChoice = -1 # default
        assertValidSFInt32(whichChoice)
        assertGreaterThanEquals('whichChoice', whichChoice, -1)
        self.__whichChoice = whichChoice
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Switch.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Switch'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if self.whichChoice != -1:
            result += " whichChoice='" + SFInt32(self.whichChoice).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Switch>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* Switch found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Switch>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Switch.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Switch' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Switch' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.whichChoice != -1:
            result += " whichChoice " + SFInt32(self.whichChoice).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TexCoordChaser2D(_X3DChaserNode):
    """
    TexCoordChaser2D generates a series of single floating-point values that progressively change from initial value to destination value.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TexCoordChaser2D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/followers.html#TexCoordChaser2D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TexCoordChaser2D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('duration', 1, FieldType.SFTime, AccessType.initializeOnly, 'X3DChaserNode'),
            ('initialDestination', list(), FieldType.MFVec2f, AccessType.initializeOnly, 'TexCoordChaser2D'),
            ('initialValue', list(), FieldType.MFVec2f, AccessType.initializeOnly, 'TexCoordChaser2D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 duration=1,
                 initialDestination=list(),
                 initialValue=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TexCoordChaser2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.duration = duration
        self.initialDestination = initialDestination
        self.initialValue = initialValue
    @property # getter - - - - - - - - - -
    def duration(self):
        """[0,+infinity) duration is the time interval for filter response in seconds."""
        return self.__duration
    @duration.setter
    def duration(self, duration):
        if  duration is None:
            duration = 1 # default
        assertValidSFTime(duration)
        assertNonNegative('duration', duration)
        self.__duration = duration
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = MFVec2f.DEFAULT_VALUE(self)
        assertValidMFVec2f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = MFVec2f.DEFAULT_VALUE(self)
        assertValidMFVec2f(initialValue)
        self.__initialValue = initialValue
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TexCoordChaser2D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TexCoordChaser2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.duration != 1:
            result += " duration='" + SFTime(self.duration).XML() + "'"
        if self.initialDestination != list():
            result += " initialDestination='" + MFVec2f(self.initialDestination).XML() + "'"
        if self.initialValue != list():
            result += " initialValue='" + MFVec2f(self.initialValue).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TexCoordChaser2D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TexCoordChaser2D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TexCoordChaser2D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TexCoordChaser2D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TexCoordChaser2D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.duration != 1:
            result += " duration " + SFTime(self.duration).VRML() + ""
        if self.initialDestination != list():
            result += " initialDestination " + MFVec2f(self.initialDestination).VRML() + ""
        if self.initialValue != list():
            result += " initialValue " + MFVec2f(self.initialValue).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TexCoordDamper2D(_X3DDamperNode):
    """
    TexCoordDamper2D generates a series of 2D floating-point arrays that progressively change from initial value to destination value.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TexCoordDamper2D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/followers.html#TexCoordDamper2D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TexCoordDamper2D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('initialDestination', list(), FieldType.MFVec2f, AccessType.initializeOnly, 'TexCoordDamper2D'),
            ('initialValue', list(), FieldType.MFVec2f, AccessType.initializeOnly, 'TexCoordDamper2D'),
            ('order', 3, FieldType.SFInt32, AccessType.initializeOnly, 'X3DDamperNode'),
            ('tau', 0.3, FieldType.SFTime, AccessType.inputOutput, 'X3DDamperNode'),
            ('tolerance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DDamperNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 initialDestination=list(),
                 initialValue=list(),
                 order=3,
                 tau=0.3,
                 tolerance=-1,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TexCoordDamper2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.initialDestination = initialDestination
        self.initialValue = initialValue
        self.order = order
        self.tau = tau
        self.tolerance = tolerance
    @property # getter - - - - - - - - - -
    def initialDestination(self):
        """Initial destination value for this node."""
        return self.__initialDestination
    @initialDestination.setter
    def initialDestination(self, initialDestination):
        if  initialDestination is None:
            initialDestination = MFVec2f.DEFAULT_VALUE(self)
        assertValidMFVec2f(initialDestination)
        self.__initialDestination = initialDestination
    @property # getter - - - - - - - - - -
    def initialValue(self):
        """Initial starting value for this node."""
        return self.__initialValue
    @initialValue.setter
    def initialValue(self, initialValue):
        if  initialValue is None:
            initialValue = MFVec2f.DEFAULT_VALUE(self)
        assertValidMFVec2f(initialValue)
        self.__initialValue = initialValue
    @property # getter - - - - - - - - - -
    def order(self):
        """[0,5] order defines the number of internal filters (larger means smoother response, longer delay)."""
        return self.__order
    @order.setter
    def order(self, order):
        if  order is None:
            order = 3 # default
        assertValidSFInt32(order)
        assertGreaterThanEquals('order', order, 0)
        assertLessThanEquals('order', order, 5)
        self.__order = order
    @property # getter - - - - - - - - - -
    def tau(self):
        """[0,+infinity) tau is the exponential-decay time constant for filter response in seconds."""
        return self.__tau
    @tau.setter
    def tau(self, tau):
        if  tau is None:
            tau = 0.3 # default
        assertValidSFTime(tau)
        assertNonNegative('tau', tau)
        self.__tau = tau
    @property # getter - - - - - - - - - -
    def tolerance(self):
        """[0,+infinity) or -1."""
        return self.__tolerance
    @tolerance.setter
    def tolerance(self, tolerance):
        if  tolerance is None:
            tolerance = -1 # default
        assertValidSFFloat(tolerance)
        self.__tolerance = tolerance
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TexCoordDamper2D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TexCoordDamper2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.initialDestination != list():
            result += " initialDestination='" + MFVec2f(self.initialDestination).XML() + "'"
        if self.initialValue != list():
            result += " initialValue='" + MFVec2f(self.initialValue).XML() + "'"
        if self.order != 3:
            result += " order='" + SFInt32(self.order).XML() + "'"
        if self.tau != 0.3:
            result += " tau='" + SFTime(self.tau).XML() + "'"
        if self.tolerance != -1:
            result += " tolerance='" + SFFloat(self.tolerance).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TexCoordDamper2D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TexCoordDamper2D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TexCoordDamper2D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TexCoordDamper2D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TexCoordDamper2D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.initialDestination != list():
            result += " initialDestination " + MFVec2f(self.initialDestination).VRML() + ""
        if self.initialValue != list():
            result += " initialValue " + MFVec2f(self.initialValue).VRML() + ""
        if self.order != 3:
            result += " order " + SFInt32(self.order).VRML() + ""
        if self.tau != 0.3:
            result += " tau " + SFTime(self.tau).VRML() + ""
        if self.tolerance != -1:
            result += " tolerance " + SFFloat(self.tolerance).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Text(_X3DGeometryNode):
    """
    Text is a 2D (flat) geometry node that can contain multiple lines of string values.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Text'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/text.html#Text'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Text'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('length', list(), FieldType.MFFloat, AccessType.inputOutput, 'Text'),
            ('maxExtent', 0.0, FieldType.SFFloat, AccessType.inputOutput, 'Text'),
            ('solid', False, FieldType.SFBool, AccessType.initializeOnly, 'Text'),
            ('string', list(), FieldType.MFString, AccessType.inputOutput, 'Text'),
            ('fontStyle', None, FieldType.SFNode, AccessType.inputOutput, 'Text'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 length=list(),
                 maxExtent=0.0,
                 solid=False,
                 string=list(),
                 fontStyle=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Text __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.length = length
        self.maxExtent = maxExtent
        self.solid = solid
        self.string = string
        self.fontStyle = fontStyle
    @property # getter - - - - - - - - - -
    def length(self):
        """Array of length values for each text string in the local coordinate system."""
        return self.__length
    @length.setter
    def length(self, length):
        if  length is None:
            length = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(length)
        assertNonNegative('length', length)
        self.__length = length
    @property # getter - - - - - - - - - -
    def maxExtent(self):
        """Limits/compresses all text strings if max string length is longer than maxExtent, as measured in local coordinate system."""
        return self.__maxExtent
    @maxExtent.setter
    def maxExtent(self, maxExtent):
        if  maxExtent is None:
            maxExtent = 0.0 # default
        assertValidSFFloat(maxExtent)
        assertNonNegative('maxExtent', maxExtent)
        self.__maxExtent = maxExtent
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = False # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def string(self):
        """Single or multiple string values to present as Text."""
        return self.__string
    @string.setter
    def string(self, string):
        if  string is None:
            string = MFString.DEFAULT_VALUE(self)
        assertValidMFString(string)
        self.__string = string
    @property # getter - - - - - - - - - -
    def fontStyle(self):
        return self.__fontStyle
    @fontStyle.setter
    def fontStyle(self, fontStyle):
        if  fontStyle is None:
            fontStyle = None # default
        assertValidSFNode(fontStyle)
        if not isinstance(fontStyle, object):
            # print(flush=True)
            raise X3DTypeError(str(fontStyle) + ' does not have a valid node type object')
        self.__fontStyle = fontStyle
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.fontStyle or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Text.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Text'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.length != list():
            result += " length='" + MFFloat(self.length).XML() + "'"
        if self.maxExtent != 0.0:
            result += " maxExtent='" + SFFloat(self.maxExtent).XML() + "'"
        if self.solid: # default=false
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if self.string != list():
            result += " string='" + MFString(self.string).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Text>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.fontStyle: # output this SFNode
                result += self.fontStyle.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Text>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Text.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Text' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Text' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.length != list():
            result += " length " + MFFloat(self.length).VRML() + ""
        if self.maxExtent != 0.0:
            result += " maxExtent " + SFFloat(self.maxExtent).VRML() + ""
        if self.solid: # default=false
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.string != list():
            result += " string " + MFString(self.string).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.fontStyle: # output this SFNode
            result += '\n' + '  ' + indent + 'fontStyle ' + self.fontStyle.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TextureBackground(_X3DBackgroundNode):
    """
    TextureBackground simulates ground and sky, using vertical arrays of wraparound color values, TextureBackground can also provide backdrop texture images on all six sides.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TextureBackground'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/environmentalEffects.html#TextureBackground'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureBackground'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('groundAngle', list(), FieldType.MFFloat, AccessType.inputOutput, 'X3DBackgroundNode'),
            ('groundColor', list(), FieldType.MFColor, AccessType.inputOutput, 'X3DBackgroundNode'),
            ('skyAngle', list(), FieldType.MFFloat, AccessType.inputOutput, 'X3DBackgroundNode'),
            ('skyColor', [(0, 0, 0)], FieldType.MFColor, AccessType.inputOutput, 'X3DBackgroundNode'),
            ('transparency', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DBackgroundNode'),
            ('backTexture', None, FieldType.SFNode, AccessType.inputOutput, 'TextureBackground'),
            ('bottomTexture', None, FieldType.SFNode, AccessType.inputOutput, 'TextureBackground'),
            ('frontTexture', None, FieldType.SFNode, AccessType.inputOutput, 'TextureBackground'),
            ('leftTexture', None, FieldType.SFNode, AccessType.inputOutput, 'TextureBackground'),
            ('rightTexture', None, FieldType.SFNode, AccessType.inputOutput, 'TextureBackground'),
            ('topTexture', None, FieldType.SFNode, AccessType.inputOutput, 'TextureBackground'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 groundAngle=list(),
                 groundColor=list(),
                 skyAngle=list(),
                 skyColor=[(0, 0, 0)],
                 transparency=0,
                 backTexture=None,
                 bottomTexture=None,
                 frontTexture=None,
                 leftTexture=None,
                 rightTexture=None,
                 topTexture=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureBackground __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.groundAngle = groundAngle
        self.groundColor = groundColor
        self.skyAngle = skyAngle
        self.skyColor = skyColor
        self.transparency = transparency
        self.backTexture = backTexture
        self.bottomTexture = bottomTexture
        self.frontTexture = frontTexture
        self.leftTexture = leftTexture
        self.rightTexture = rightTexture
        self.topTexture = topTexture
    @property # getter - - - - - - - - - -
    def groundAngle(self):
        """[0,pi/2] The angle array values increase from 0."""
        return self.__groundAngle
    @groundAngle.setter
    def groundAngle(self, groundAngle):
        if  groundAngle is None:
            groundAngle = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(groundAngle)
        assertGreaterThanEquals('groundAngle', groundAngle, 0)
        assertLessThanEquals('groundAngle', groundAngle, 1.5708)
        self.__groundAngle = groundAngle
    @property # getter - - - - - - - - - -
    def groundColor(self):
        """Color of the ground at the various angles on the ground partial sphere."""
        return self.__groundColor
    @groundColor.setter
    def groundColor(self, groundColor):
        if  groundColor is None:
            groundColor = MFColor.DEFAULT_VALUE(self)
        assertValidMFColor(groundColor)
        assertZeroToOne('groundColor', groundColor)
        self.__groundColor = groundColor
    @property # getter - - - - - - - - - -
    def skyAngle(self):
        """[0,pi] The angle array values increase from 0."""
        return self.__skyAngle
    @skyAngle.setter
    def skyAngle(self, skyAngle):
        if  skyAngle is None:
            skyAngle = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(skyAngle)
        assertGreaterThanEquals('skyAngle', skyAngle, 0)
        assertLessThanEquals('skyAngle', skyAngle, 3.1416)
        self.__skyAngle = skyAngle
    @property # getter - - - - - - - - - -
    def skyColor(self):
        """Color of the sky at various angles on the sky sphere."""
        return self.__skyColor
    @skyColor.setter
    def skyColor(self, skyColor):
        if  skyColor is None:
            skyColor = [(0, 0, 0)] # default
        assertValidMFColor(skyColor)
        assertZeroToOne('skyColor', skyColor)
        self.__skyColor = skyColor
    @property # getter - - - - - - - - - -
    def transparency(self):
        """transparency applied to texture images, enabling an X3D scene to overlay an HTML page or desktop."""
        return self.__transparency
    @transparency.setter
    def transparency(self, transparency):
        if  transparency is None:
            transparency = 0 # default
        assertValidSFFloat(transparency)
        assertZeroToOne('transparency', transparency)
        self.__transparency = transparency
    @property # getter - - - - - - - - - -
    def backTexture(self):
        """[X3DTexture2DNode | MultiTexture] Parent TextureBackground element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture MultiTexture)."""
        return self.__backTexture
    @backTexture.setter
    def backTexture(self, backTexture):
        if  backTexture is None:
            backTexture = None # default
        assertValidSFNode(backTexture)
        if not isinstance(backTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(backTexture) + ' does not have a valid node type object')
        self.__backTexture = backTexture
    @property # getter - - - - - - - - - -
    def bottomTexture(self):
        """[X3DTexture2DNode | MultiTexture] Parent TextureBackground element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture MultiTexture)."""
        return self.__bottomTexture
    @bottomTexture.setter
    def bottomTexture(self, bottomTexture):
        if  bottomTexture is None:
            bottomTexture = None # default
        assertValidSFNode(bottomTexture)
        if not isinstance(bottomTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(bottomTexture) + ' does not have a valid node type object')
        self.__bottomTexture = bottomTexture
    @property # getter - - - - - - - - - -
    def frontTexture(self):
        """[X3DTexture2DNode | MultiTexture] Parent TextureBackground element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture MultiTexture)."""
        return self.__frontTexture
    @frontTexture.setter
    def frontTexture(self, frontTexture):
        if  frontTexture is None:
            frontTexture = None # default
        assertValidSFNode(frontTexture)
        if not isinstance(frontTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(frontTexture) + ' does not have a valid node type object')
        self.__frontTexture = frontTexture
    @property # getter - - - - - - - - - -
    def leftTexture(self):
        """[X3DTexture2DNode | MultiTexture] Parent TextureBackground element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture MultiTexture)."""
        return self.__leftTexture
    @leftTexture.setter
    def leftTexture(self, leftTexture):
        if  leftTexture is None:
            leftTexture = None # default
        assertValidSFNode(leftTexture)
        if not isinstance(leftTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(leftTexture) + ' does not have a valid node type object')
        self.__leftTexture = leftTexture
    @property # getter - - - - - - - - - -
    def rightTexture(self):
        """[X3DTexture2DNode | MultiTexture] Parent TextureBackground element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture MultiTexture)."""
        return self.__rightTexture
    @rightTexture.setter
    def rightTexture(self, rightTexture):
        if  rightTexture is None:
            rightTexture = None # default
        assertValidSFNode(rightTexture)
        if not isinstance(rightTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(rightTexture) + ' does not have a valid node type object')
        self.__rightTexture = rightTexture
    @property # getter - - - - - - - - - -
    def topTexture(self):
        """[X3DTexture2DNode | MultiTexture] Parent TextureBackground element can contain up to six image nodes (ImageTexture PixelTexture MovieTexture MultiTexture)."""
        return self.__topTexture
    @topTexture.setter
    def topTexture(self, topTexture):
        if  topTexture is None:
            topTexture = None # default
        assertValidSFNode(topTexture)
        if not isinstance(topTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(topTexture) + ' does not have a valid node type object')
        self.__topTexture = topTexture
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.backTexture or self.bottomTexture or self.frontTexture or self.IS or self.leftTexture or self.metadata or self.rightTexture or self.topTexture
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TextureBackground.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TextureBackground'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.groundAngle != list():
            result += " groundAngle='" + MFFloat(self.groundAngle).XML() + "'"
        if self.groundColor != list():
            result += " groundColor='" + MFColor(self.groundColor).XML() + "'"
        if self.skyAngle != list():
            result += " skyAngle='" + MFFloat(self.skyAngle).XML() + "'"
        if self.skyColor != [(0, 0, 0)]:
            result += " skyColor='" + MFColor(self.skyColor).XML() + "'"
        if self.transparency != 0:
            result += " transparency='" + SFFloat(self.transparency).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TextureBackground>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.backTexture: # output this SFNode
                result += self.backTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.bottomTexture: # output this SFNode
                result += self.bottomTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.frontTexture: # output this SFNode
                result += self.frontTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.leftTexture: # output this SFNode
                result += self.leftTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.rightTexture: # output this SFNode
                result += self.rightTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.topTexture: # output this SFNode
                result += self.topTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TextureBackground>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TextureBackground.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TextureBackground' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TextureBackground' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.groundAngle != list():
            result += " groundAngle " + MFFloat(self.groundAngle).VRML() + ""
        if self.groundColor != list():
            result += " groundColor " + MFColor(self.groundColor).VRML() + ""
        if self.skyAngle != list():
            result += " skyAngle " + MFFloat(self.skyAngle).VRML() + ""
        if self.skyColor != [(0, 0, 0)]:
            result += " skyColor " + MFColor(self.skyColor).VRML() + ""
        if self.transparency != 0:
            result += " transparency " + SFFloat(self.transparency).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.backTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'backTexture ' + self.backTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.bottomTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'bottomTexture ' + self.bottomTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.frontTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'frontTexture ' + self.frontTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.leftTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'leftTexture ' + self.leftTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.rightTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'rightTexture ' + self.rightTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.topTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'topTexture ' + self.topTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TextureCoordinate(_X3DSingleTextureCoordinateNode):
    """
    TextureCoordinate specifies 2D (s,t) texture-coordinate points, used by vertex-based geometry nodes (such as IndexedFaceSet or ElevationGrid) to map textures to vertices (and patches to NURBS surfaces).
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TextureCoordinate'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texturing.html#TextureCoordinate'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureCoordinate'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('mapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DSingleTextureCoordinateNode'),
            ('point', list(), FieldType.MFVec2f, AccessType.inputOutput, 'TextureCoordinate'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 mapping='',
                 point=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureCoordinate __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.mapping = mapping
        self.point = point
    @property # getter - - - - - - - - - -
    def mapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__mapping
    @mapping.setter
    def mapping(self, mapping):
        if  mapping is None:
            mapping = SFString.DEFAULT_VALUE(self)
        assertValidSFString(mapping)
        self.__mapping = mapping
    @property # getter - - - - - - - - - -
    def point(self):
        """pairs of 2D (s,t) texture coordinates, either in range [0,1] or higher if repeating."""
        return self.__point
    @point.setter
    def point(self, point):
        if  point is None:
            point = MFVec2f.DEFAULT_VALUE(self)
        assertValidMFVec2f(point)
        self.__point = point
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TextureCoordinate.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TextureCoordinate'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.mapping:
            result += " mapping='" + self.mapping + "'"
        if self.point != list():
            result += " point='" + MFVec2f(self.point).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TextureCoordinate>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TextureCoordinate>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TextureCoordinate.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TextureCoordinate' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TextureCoordinate' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.mapping:
            result += " mapping " +  '"' + self.mapping + '"' + ""
        if self.point != list():
            result += " point " + MFVec2f(self.point).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TextureCoordinate3D(_X3DSingleTextureCoordinateNode):
    """
    TextureCoordinate3D specifies a set of 3D texture coordinates used by vertex-based geometry nodes (such as IndexedFaceSet or ElevationGrid) to map 3D textures to vertices.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TextureCoordinate3D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texture3D.html#TextureCoordinate3D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureCoordinate3D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('mapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DSingleTextureCoordinateNode'),
            ('point', list(), FieldType.MFVec3f, AccessType.inputOutput, 'TextureCoordinate3D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 mapping='',
                 point=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureCoordinate3D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.mapping = mapping
        self.point = point
    @property # getter - - - - - - - - - -
    def mapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__mapping
    @mapping.setter
    def mapping(self, mapping):
        if  mapping is None:
            mapping = SFString.DEFAULT_VALUE(self)
        assertValidSFString(mapping)
        self.__mapping = mapping
    @property # getter - - - - - - - - - -
    def point(self):
        """triplets of 3D (s,t,r) texture coordinates, either in range [0,1] or higher if repeating."""
        return self.__point
    @point.setter
    def point(self, point):
        if  point is None:
            point = MFVec3f.DEFAULT_VALUE(self)
        assertValidMFVec3f(point)
        self.__point = point
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TextureCoordinate3D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TextureCoordinate3D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.mapping:
            result += " mapping='" + self.mapping + "'"
        if self.point != list():
            result += " point='" + MFVec3f(self.point).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TextureCoordinate3D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TextureCoordinate3D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TextureCoordinate3D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TextureCoordinate3D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TextureCoordinate3D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.mapping:
            result += " mapping " +  '"' + self.mapping + '"' + ""
        if self.point != list():
            result += " point " + MFVec3f(self.point).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TextureCoordinate4D(_X3DSingleTextureCoordinateNode):
    """
    TextureCoordinate4D specifies a set of 4D (homogeneous 3D) texture coordinates used by vertex-based geometry nodes (such as IndexedFaceSet or ElevationGrid) to map 3D textures to vertices.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TextureCoordinate4D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texture3D.html#TextureCoordinate4D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureCoordinate4D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('mapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DSingleTextureCoordinateNode'),
            ('point', list(), FieldType.MFVec4f, AccessType.inputOutput, 'TextureCoordinate4D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 mapping='',
                 point=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureCoordinate4D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.mapping = mapping
        self.point = point
    @property # getter - - - - - - - - - -
    def mapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__mapping
    @mapping.setter
    def mapping(self, mapping):
        if  mapping is None:
            mapping = SFString.DEFAULT_VALUE(self)
        assertValidSFString(mapping)
        self.__mapping = mapping
    @property # getter - - - - - - - - - -
    def point(self):
        """4-tuple values of 4D texture coordinates, either in range [0,1] or higher if repeating."""
        return self.__point
    @point.setter
    def point(self, point):
        if  point is None:
            point = MFVec4f.DEFAULT_VALUE(self)
        assertValidMFVec4f(point)
        self.__point = point
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TextureCoordinate4D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TextureCoordinate4D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.mapping:
            result += " mapping='" + self.mapping + "'"
        if self.point != list():
            result += " point='" + MFVec4f(self.point).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TextureCoordinate4D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TextureCoordinate4D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TextureCoordinate4D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TextureCoordinate4D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TextureCoordinate4D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.mapping:
            result += " mapping " +  '"' + self.mapping + '"' + ""
        if self.point != list():
            result += " point " + MFVec4f(self.point).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TextureCoordinateGenerator(_X3DSingleTextureCoordinateNode):
    """
    TextureCoordinateGenerator computes 2D (s,t) texture-coordinate points, used by vertex-based geometry nodes (such as IndexedFaceSet or ElevationGrid) to map textures to vertices (and patches to NURBS surfaces).
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TextureCoordinateGenerator'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texturing.html#TextureCoordinateGenerator'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureCoordinateGenerator'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('mapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DSingleTextureCoordinateNode'),
            ('mode', 'SPHERE', FieldType.SFString, AccessType.inputOutput, 'TextureCoordinateGenerator'),
            ('parameter', list(), FieldType.MFFloat, AccessType.inputOutput, 'TextureCoordinateGenerator'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 mapping='',
                 mode='SPHERE',
                 parameter=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureCoordinateGenerator __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.mapping = mapping
        self.mode = mode
        self.parameter = parameter
    @property # getter - - - - - - - - - -
    def mapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__mapping
    @mapping.setter
    def mapping(self, mapping):
        if  mapping is None:
            mapping = SFString.DEFAULT_VALUE(self)
        assertValidSFString(mapping)
        self.__mapping = mapping
    @property # getter - - - - - - - - - -
    def mode(self):
        """parameter field defines the algorithm used to compute texture coordinates."""
        return self.__mode
    @mode.setter
    def mode(self, mode):
        if  mode is None:
            mode = 'SPHERE' # default
        assertValidSFString(mode)
        assertValidTextureCoordinateGeneratorMode('mode', mode)
        self.__mode = mode
    @property # getter - - - - - - - - - -
    def parameter(self):
        """parameter array contains scale and translation (x y z) values for Perlin NOISE mode, parameter[0] contains index of refraction for SPHERE-REFLECT mode, parameter[0] contains index of refraction and parameter[1 to 3] contains the eye point in local coordinates for SPHERE-REFLECT-LOCAL mode."""
        return self.__parameter
    @parameter.setter
    def parameter(self, parameter):
        if  parameter is None:
            parameter = MFFloat.DEFAULT_VALUE(self)
        assertValidMFFloat(parameter)
        self.__parameter = parameter
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TextureCoordinateGenerator.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TextureCoordinateGenerator'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.mapping:
            result += " mapping='" + self.mapping + "'"
        if self.mode != 'SPHERE':
            result += " mode='" + self.mode + "'"
        if self.parameter != list():
            result += " parameter='" + MFFloat(self.parameter).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TextureCoordinateGenerator>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TextureCoordinateGenerator>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TextureCoordinateGenerator.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TextureCoordinateGenerator' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TextureCoordinateGenerator' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.mapping:
            result += " mapping " +  '"' + self.mapping + '"' + ""
        if self.mode != 'SPHERE':
            result += " mode " +  '"' + self.mode + '"' + ""
        if self.parameter != list():
            result += " parameter " + MFFloat(self.parameter).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TextureProjector(_X3DTextureProjectorNode):
    """
    TextureProjector is similar to a light that projects a texture into the scene, illuminating geometry that intersects the perspective projection volume.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TextureProjector'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/TextureProjector.html#TextureProjector'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureProjector'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ambientIntensity', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
            ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'X3DLightNode'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureProjectorNode'),
            ('direction', (0, 0, 1), FieldType.SFVec3f, AccessType.inputOutput, 'X3DTextureProjectorNode'),
            ('farDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DTextureProjectorNode'),
            ('fieldOfView', 0.7854, FieldType.SFFloat, AccessType.inputOutput, 'TextureProjector'),
            ('global_', True, FieldType.SFBool, AccessType.inputOutput, 'X3DTextureProjectorNode'),
            ('intensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
            ('location', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'X3DTextureProjectorNode'),
            ('nearDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DTextureProjectorNode'),
            ('on', True, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
            ('shadowIntensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
            ('shadows', False, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
            ('upVector', (0, 0, 1), FieldType.SFVec3f, AccessType.inputOutput, 'TextureProjector'),
            ('texture', None, FieldType.SFNode, AccessType.inputOutput, 'X3DTextureProjectorNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ambientIntensity=0,
                 color=(1, 1, 1),
                 description='',
                 direction=(0, 0, 1),
                 farDistance=-1,
                 fieldOfView=0.7854,
                 global_=True,
                 intensity=1,
                 location=(0, 0, 0),
                 nearDistance=-1,
                 on=True,
                 shadowIntensity=1,
                 shadows=False,
                 upVector=(0, 0, 1),
                 texture=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureProjector __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.color = color
        self.description = description
        self.direction = direction
        self.farDistance = farDistance
        self.fieldOfView = fieldOfView
        self.global_ = global_
        self.intensity = intensity
        self.location = location
        self.nearDistance = nearDistance
        self.on = on
        self.shadowIntensity = shadowIntensity
        self.shadows = shadows
        self.upVector = upVector
        self.texture = texture
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        """[0,1] Brightness of ambient (nondirectional background) emission from the light."""
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity):
        if  ambientIntensity is None:
            ambientIntensity = 0 # default
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def color(self):
        """[0,1] color of light, applied to colors of objects."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = (1, 1, 1) # default
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def direction(self):
        """Initial direction from which particles emanate."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 0, 1) # default
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def farDistance(self):
        """or (0,+infinity) maximum distance necessary for texture display."""
        return self.__farDistance
    @farDistance.setter
    def farDistance(self, farDistance):
        if  farDistance is None:
            farDistance = -1 # default
        assertValidSFFloat(farDistance)
        assertGreaterThanEquals('farDistance', farDistance, -1)
        self.__farDistance = farDistance
    @property # getter - - - - - - - - - -
    def fieldOfView(self):
        """Preferred minimum viewing angle for this projection in radians, providing minimum height or minimum width (whichever is smaller)."""
        return self.__fieldOfView
    @fieldOfView.setter
    def fieldOfView(self, fieldOfView):
        if  fieldOfView is None:
            fieldOfView = 0.7854 # default
        assertValidSFFloat(fieldOfView)
        assertGreaterThanEquals('fieldOfView', fieldOfView, 0)
        assertLessThanEquals('fieldOfView', fieldOfView, 3.1416)
        self.__fieldOfView = fieldOfView
    @property # getter - - - - - - - - - -
    def global_(self): # Appended underscore to field name to avoid naming collision with Python reserved word
        return self.__global_
    @global_.setter
    def global_(self, global_):
        if  global_ is None:
            global_ = True # default
        assertValidSFBool(global_)
        self.__global_ = global_
    @property # getter - - - - - - - - - -
    def intensity(self):
        """[0,1] Brightness of direct emission from the light."""
        return self.__intensity
    @intensity.setter
    def intensity(self, intensity):
        if  intensity is None:
            intensity = 1 # default
        assertValidSFFloat(intensity)
        assertZeroToOne('intensity', intensity)
        self.__intensity = intensity
    @property # getter - - - - - - - - - -
    def location(self):
        """Position of center of texture projection relative to local coordinate system."""
        return self.__location
    @location.setter
    def location(self, location):
        if  location is None:
            location = (0, 0, 0) # default
        assertValidSFVec3f(location)
        self.__location = location
    @property # getter - - - - - - - - - -
    def nearDistance(self):
        """or (0,+infinity) minimum distance necessary for texture display."""
        return self.__nearDistance
    @nearDistance.setter
    def nearDistance(self, nearDistance):
        if  nearDistance is None:
            nearDistance = -1 # default
        assertValidSFFloat(nearDistance)
        assertGreaterThanEquals('nearDistance', nearDistance, -1)
        self.__nearDistance = nearDistance
    @property # getter - - - - - - - - - -
    def on(self):
        """Enables/disables this texture projection source."""
        return self.__on
    @on.setter
    def on(self, on):
        if  on is None:
            on = True # default
        assertValidSFBool(on)
        self.__on = on
    @property # getter - - - - - - - - - -
    def shadowIntensity(self):
        """[0,1] shadowIntensity field defines how much light is obscured by shapes that cast shadows, ranging from 0 (light not obscured, no visible shadows) to 1 (light completely obscured, full-intensity shadows)."""
        return self.__shadowIntensity
    @shadowIntensity.setter
    def shadowIntensity(self, shadowIntensity):
        if  shadowIntensity is None:
            shadowIntensity = 1 # default
        assertValidSFFloat(shadowIntensity)
        assertZeroToOne('shadowIntensity', shadowIntensity)
        self.__shadowIntensity = shadowIntensity
    @property # getter - - - - - - - - - -
    def shadows(self):
        """shadows field indicates whether or not this light casts a shadow behind illuminated X3DShapeNode geometry."""
        return self.__shadows
    @shadows.setter
    def shadows(self, shadows):
        if  shadows is None:
            shadows = False # default
        assertValidSFBool(shadows)
        self.__shadows = shadows
    @property # getter - - - - - - - - - -
    def upVector(self):
        return self.__upVector
    @upVector.setter
    def upVector(self, upVector):
        if  upVector is None:
            upVector = (0, 0, 1) # default
        assertValidSFVec3f(upVector)
        self.__upVector = upVector
    @property # getter - - - - - - - - - -
    def texture(self):
        """[X3DTextureNode] Single contained texture node (ImageTexture, MovieTexture, PixelTexture, MultiTexture) that maps image(s) to surface geometry."""
        return self.__texture
    @texture.setter
    def texture(self, texture):
        if  texture is None:
            texture = None # default
        assertValidSFNode(texture)
        if not isinstance(texture, object):
            # print(flush=True)
            raise X3DTypeError(str(texture) + ' does not have a valid node type object')
        self.__texture = texture
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.texture
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TextureProjector.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TextureProjector'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ambientIntensity != 0:
            result += " ambientIntensity='" + SFFloat(self.ambientIntensity).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.color != (1, 1, 1):
            result += " color='" + SFColor(self.color).XML() + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.direction != (0, 0, 1):
            result += " direction='" + SFVec3f(self.direction).XML() + "'"
        if self.farDistance != -1:
            result += " farDistance='" + SFFloat(self.farDistance).XML() + "'"
        if self.fieldOfView != 0.7854:
            result += " fieldOfView='" + SFFloat(self.fieldOfView).XML() + "'"
        if not self.global_: # default=true
            result += " global_='" + SFBool(self.global_).XML() + "'"
        if self.intensity != 1:
            result += " intensity='" + SFFloat(self.intensity).XML() + "'"
        if self.location != (0, 0, 0):
            result += " location='" + SFVec3f(self.location).XML() + "'"
        if self.nearDistance != -1:
            result += " nearDistance='" + SFFloat(self.nearDistance).XML() + "'"
        if not self.on: # default=true
            result += " on='" + SFBool(self.on).XML() + "'"
        if self.shadowIntensity != 1:
            result += " shadowIntensity='" + SFFloat(self.shadowIntensity).XML() + "'"
        if self.shadows: # default=false
            result += " shadows='" + SFBool(self.shadows).XML() + "'"
        if self.upVector != (0, 0, 1):
            result += " upVector='" + SFVec3f(self.upVector).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TextureProjector>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.texture: # output this SFNode
                result += self.texture.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TextureProjector>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TextureProjector.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TextureProjector' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TextureProjector' + ' {'
        if self.ambientIntensity != 0:
            result += " ambientIntensity " + SFFloat(self.ambientIntensity).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.color != (1, 1, 1):
            result += " color " + SFColor(self.color).VRML() + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.direction != (0, 0, 1):
            result += " direction " + SFVec3f(self.direction).VRML() + ""
        if self.farDistance != -1:
            result += " farDistance " + SFFloat(self.farDistance).VRML() + ""
        if self.fieldOfView != 0.7854:
            result += " fieldOfView " + SFFloat(self.fieldOfView).VRML() + ""
        if not self.global_: # default=true
            result += " global_ " + SFBool(self.global_).VRML() + ""
        if self.intensity != 1:
            result += " intensity " + SFFloat(self.intensity).VRML() + ""
        if self.location != (0, 0, 0):
            result += " location " + SFVec3f(self.location).VRML() + ""
        if self.nearDistance != -1:
            result += " nearDistance " + SFFloat(self.nearDistance).VRML() + ""
        if not self.on: # default=true
            result += " on " + SFBool(self.on).VRML() + ""
        if self.shadowIntensity != 1:
            result += " shadowIntensity " + SFFloat(self.shadowIntensity).VRML() + ""
        if self.shadows: # default=false
            result += " shadows " + SFBool(self.shadows).VRML() + ""
        if self.upVector != (0, 0, 1):
            result += " upVector " + SFVec3f(self.upVector).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texture: # output this SFNode
            result += '\n' + '  ' + indent + 'texture ' + self.texture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TextureProjectorParallel(_X3DTextureProjectorNode):
    """
    TextureProjectorParallel is similar to a light that projects a texture into the scene, illuminating geometry that intersects the parallel projection volume.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TextureProjectorParallel'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/TextureProjector.html#TextureProjectorParallel'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureProjectorParallel'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ambientIntensity', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
            ('color', (1, 1, 1), FieldType.SFColor, AccessType.inputOutput, 'X3DLightNode'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTextureProjectorNode'),
            ('direction', (0, 0, 1), FieldType.SFVec3f, AccessType.inputOutput, 'X3DTextureProjectorNode'),
            ('farDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DTextureProjectorNode'),
            ('fieldOfView', (-1, -1, 1, 1), FieldType.SFVec4f, AccessType.inputOutput, 'TextureProjectorParallel'),
            ('global_', True, FieldType.SFBool, AccessType.inputOutput, 'X3DTextureProjectorNode'),
            ('intensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
            ('location', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'X3DTextureProjectorNode'),
            ('nearDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DTextureProjectorNode'),
            ('on', True, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
            ('shadowIntensity', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DLightNode'),
            ('shadows', False, FieldType.SFBool, AccessType.inputOutput, 'X3DLightNode'),
            ('texture', None, FieldType.SFNode, AccessType.inputOutput, 'X3DTextureProjectorNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ambientIntensity=0,
                 color=(1, 1, 1),
                 description='',
                 direction=(0, 0, 1),
                 farDistance=-1,
                 fieldOfView=(-1, -1, 1, 1),
                 global_=True,
                 intensity=1,
                 location=(0, 0, 0),
                 nearDistance=-1,
                 on=True,
                 shadowIntensity=1,
                 shadows=False,
                 texture=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureProjectorParallel __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.color = color
        self.description = description
        self.direction = direction
        self.farDistance = farDistance
        self.fieldOfView = fieldOfView
        self.global_ = global_
        self.intensity = intensity
        self.location = location
        self.nearDistance = nearDistance
        self.on = on
        self.shadowIntensity = shadowIntensity
        self.shadows = shadows
        self.texture = texture
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        """[0,1] Brightness of ambient (nondirectional background) emission from the light."""
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity):
        if  ambientIntensity is None:
            ambientIntensity = 0 # default
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def color(self):
        """[0,1] color of light, applied to colors of objects."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = (1, 1, 1) # default
        assertValidSFColor(color)
        assertZeroToOne('color', color)
        self.__color = color
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def direction(self):
        """Initial direction from which particles emanate."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 0, 1) # default
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def farDistance(self):
        """or (0,+infinity) maximum distance necessary for texture display."""
        return self.__farDistance
    @farDistance.setter
    def farDistance(self, farDistance):
        if  farDistance is None:
            farDistance = -1 # default
        assertValidSFFloat(farDistance)
        assertGreaterThanEquals('farDistance', farDistance, -1)
        self.__farDistance = farDistance
    @property # getter - - - - - - - - - -
    def fieldOfView(self):
        """Minimum and maximum extents of projection texture in units of local coordinate system."""
        return self.__fieldOfView
    @fieldOfView.setter
    def fieldOfView(self, fieldOfView):
        if  fieldOfView is None:
            fieldOfView = (-1, -1, 1, 1) # default
        assertValidSFVec4f(fieldOfView)
        self.__fieldOfView = fieldOfView
    @property # getter - - - - - - - - - -
    def global_(self): # Appended underscore to field name to avoid naming collision with Python reserved word
        return self.__global_
    @global_.setter
    def global_(self, global_):
        if  global_ is None:
            global_ = True # default
        assertValidSFBool(global_)
        self.__global_ = global_
    @property # getter - - - - - - - - - -
    def intensity(self):
        """[0,1] Brightness of direct emission from the light."""
        return self.__intensity
    @intensity.setter
    def intensity(self, intensity):
        if  intensity is None:
            intensity = 1 # default
        assertValidSFFloat(intensity)
        assertZeroToOne('intensity', intensity)
        self.__intensity = intensity
    @property # getter - - - - - - - - - -
    def location(self):
        """Position of center of texture projection relative to local coordinate system."""
        return self.__location
    @location.setter
    def location(self, location):
        if  location is None:
            location = (0, 0, 0) # default
        assertValidSFVec3f(location)
        self.__location = location
    @property # getter - - - - - - - - - -
    def nearDistance(self):
        """or (0,+infinity) minimum distance necessary for texture display."""
        return self.__nearDistance
    @nearDistance.setter
    def nearDistance(self, nearDistance):
        if  nearDistance is None:
            nearDistance = -1 # default
        assertValidSFFloat(nearDistance)
        assertGreaterThanEquals('nearDistance', nearDistance, -1)
        self.__nearDistance = nearDistance
    @property # getter - - - - - - - - - -
    def on(self):
        """Enables/disables this texture projection source."""
        return self.__on
    @on.setter
    def on(self, on):
        if  on is None:
            on = True # default
        assertValidSFBool(on)
        self.__on = on
    @property # getter - - - - - - - - - -
    def shadowIntensity(self):
        """[0,1] shadowIntensity field defines how much light is obscured by shapes that cast shadows, ranging from 0 (light not obscured, no visible shadows) to 1 (light completely obscured, full-intensity shadows)."""
        return self.__shadowIntensity
    @shadowIntensity.setter
    def shadowIntensity(self, shadowIntensity):
        if  shadowIntensity is None:
            shadowIntensity = 1 # default
        assertValidSFFloat(shadowIntensity)
        assertZeroToOne('shadowIntensity', shadowIntensity)
        self.__shadowIntensity = shadowIntensity
    @property # getter - - - - - - - - - -
    def shadows(self):
        """shadows field indicates whether or not this light casts a shadow behind illuminated X3DShapeNode geometry."""
        return self.__shadows
    @shadows.setter
    def shadows(self, shadows):
        if  shadows is None:
            shadows = False # default
        assertValidSFBool(shadows)
        self.__shadows = shadows
    @property # getter - - - - - - - - - -
    def texture(self):
        """[X3DTextureNode] Single contained texture node (ImageTexture, MovieTexture, PixelTexture, MultiTexture) that maps image(s) to surface geometry."""
        return self.__texture
    @texture.setter
    def texture(self, texture):
        if  texture is None:
            texture = None # default
        assertValidSFNode(texture)
        if not isinstance(texture, object):
            # print(flush=True)
            raise X3DTypeError(str(texture) + ' does not have a valid node type object')
        self.__texture = texture
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.texture
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TextureProjectorParallel.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TextureProjectorParallel'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ambientIntensity != 0:
            result += " ambientIntensity='" + SFFloat(self.ambientIntensity).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.color != (1, 1, 1):
            result += " color='" + SFColor(self.color).XML() + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.direction != (0, 0, 1):
            result += " direction='" + SFVec3f(self.direction).XML() + "'"
        if self.farDistance != -1:
            result += " farDistance='" + SFFloat(self.farDistance).XML() + "'"
        if self.fieldOfView != (-1, -1, 1, 1):
            result += " fieldOfView='" + SFVec4f(self.fieldOfView).XML() + "'"
        if not self.global_: # default=true
            result += " global_='" + SFBool(self.global_).XML() + "'"
        if self.intensity != 1:
            result += " intensity='" + SFFloat(self.intensity).XML() + "'"
        if self.location != (0, 0, 0):
            result += " location='" + SFVec3f(self.location).XML() + "'"
        if self.nearDistance != -1:
            result += " nearDistance='" + SFFloat(self.nearDistance).XML() + "'"
        if not self.on: # default=true
            result += " on='" + SFBool(self.on).XML() + "'"
        if self.shadowIntensity != 1:
            result += " shadowIntensity='" + SFFloat(self.shadowIntensity).XML() + "'"
        if self.shadows: # default=false
            result += " shadows='" + SFBool(self.shadows).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TextureProjectorParallel>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.texture: # output this SFNode
                result += self.texture.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TextureProjectorParallel>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TextureProjectorParallel.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TextureProjectorParallel' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TextureProjectorParallel' + ' {'
        if self.ambientIntensity != 0:
            result += " ambientIntensity " + SFFloat(self.ambientIntensity).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.color != (1, 1, 1):
            result += " color " + SFColor(self.color).VRML() + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.direction != (0, 0, 1):
            result += " direction " + SFVec3f(self.direction).VRML() + ""
        if self.farDistance != -1:
            result += " farDistance " + SFFloat(self.farDistance).VRML() + ""
        if self.fieldOfView != (-1, -1, 1, 1):
            result += " fieldOfView " + SFVec4f(self.fieldOfView).VRML() + ""
        if not self.global_: # default=true
            result += " global_ " + SFBool(self.global_).VRML() + ""
        if self.intensity != 1:
            result += " intensity " + SFFloat(self.intensity).VRML() + ""
        if self.location != (0, 0, 0):
            result += " location " + SFVec3f(self.location).VRML() + ""
        if self.nearDistance != -1:
            result += " nearDistance " + SFFloat(self.nearDistance).VRML() + ""
        if not self.on: # default=true
            result += " on " + SFBool(self.on).VRML() + ""
        if self.shadowIntensity != 1:
            result += " shadowIntensity " + SFFloat(self.shadowIntensity).VRML() + ""
        if self.shadows: # default=false
            result += " shadows " + SFBool(self.shadows).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texture: # output this SFNode
            result += '\n' + '  ' + indent + 'texture ' + self.texture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TextureProperties(_X3DNode):
    """
    TextureProperties allows precise fine-grained control over application of image textures to geometry.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TextureProperties'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texturing.html#TextureProperties'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureProperties'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('anisotropicDegree', 1, FieldType.SFFloat, AccessType.inputOutput, 'TextureProperties'),
            ('borderColor', (0, 0, 0, 0), FieldType.SFColorRGBA, AccessType.inputOutput, 'TextureProperties'),
            ('borderWidth', 0, FieldType.SFInt32, AccessType.inputOutput, 'TextureProperties'),
            ('boundaryModeR', 'REPEAT', FieldType.SFString, AccessType.inputOutput, 'TextureProperties'),
            ('boundaryModeS', 'REPEAT', FieldType.SFString, AccessType.inputOutput, 'TextureProperties'),
            ('boundaryModeT', 'REPEAT', FieldType.SFString, AccessType.inputOutput, 'TextureProperties'),
            ('generateMipMaps', False, FieldType.SFBool, AccessType.initializeOnly, 'TextureProperties'),
            ('magnificationFilter', 'FASTEST', FieldType.SFString, AccessType.inputOutput, 'TextureProperties'),
            ('minificationFilter', 'FASTEST', FieldType.SFString, AccessType.inputOutput, 'TextureProperties'),
            ('textureCompression', 'FASTEST', FieldType.SFString, AccessType.inputOutput, 'TextureProperties'),
            ('texturePriority', 0, FieldType.SFFloat, AccessType.inputOutput, 'TextureProperties'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 anisotropicDegree=1,
                 borderColor=(0, 0, 0, 0),
                 borderWidth=0,
                 boundaryModeR='REPEAT',
                 boundaryModeS='REPEAT',
                 boundaryModeT='REPEAT',
                 generateMipMaps=False,
                 magnificationFilter='FASTEST',
                 minificationFilter='FASTEST',
                 textureCompression='FASTEST',
                 texturePriority=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureProperties __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.anisotropicDegree = anisotropicDegree
        self.borderColor = borderColor
        self.borderWidth = borderWidth
        self.boundaryModeR = boundaryModeR
        self.boundaryModeS = boundaryModeS
        self.boundaryModeT = boundaryModeT
        self.generateMipMaps = generateMipMaps
        self.magnificationFilter = magnificationFilter
        self.minificationFilter = minificationFilter
        self.textureCompression = textureCompression
        self.texturePriority = texturePriority
    @property # getter - - - - - - - - - -
    def anisotropicDegree(self):
        """[1,+infinity) anisotropicDegree defines minimum degree of anisotropy to account for in texture filtering (1=no effect for symmetric filtering, otherwise provide higher value)."""
        return self.__anisotropicDegree
    @anisotropicDegree.setter
    def anisotropicDegree(self, anisotropicDegree):
        if  anisotropicDegree is None:
            anisotropicDegree = 1 # default
        assertValidSFFloat(anisotropicDegree)
        assertGreaterThanEquals('anisotropicDegree', anisotropicDegree, 1)
        self.__anisotropicDegree = anisotropicDegree
    @property # getter - - - - - - - - - -
    def borderColor(self):
        """[0,1] borderColor defines border pixel color."""
        return self.__borderColor
    @borderColor.setter
    def borderColor(self, borderColor):
        if  borderColor is None:
            borderColor = (0, 0, 0, 0) # default
        assertValidSFColorRGBA(borderColor)
        assertZeroToOne('borderColor', borderColor)
        self.__borderColor = borderColor
    @property # getter - - - - - - - - - -
    def borderWidth(self):
        """[0,+infinity) borderWidth number of pixels for texture border."""
        return self.__borderWidth
    @borderWidth.setter
    def borderWidth(self, borderWidth):
        if  borderWidth is None:
            borderWidth = 0 # default
        assertValidSFInt32(borderWidth)
        assertNonNegative('borderWidth', borderWidth)
        self.__borderWidth = borderWidth
    @property # getter - - - - - - - - - -
    def boundaryModeR(self):
        """boundaryModeR describes handling of texture-coordinate boundaries."""
        return self.__boundaryModeR
    @boundaryModeR.setter
    def boundaryModeR(self, boundaryModeR):
        if  boundaryModeR is None:
            boundaryModeR = 'REPEAT' # default
        assertValidSFString(boundaryModeR)
        assertValidTextureBoundaryMode('boundaryModeR', boundaryModeR)
        self.__boundaryModeR = boundaryModeR
    @property # getter - - - - - - - - - -
    def boundaryModeS(self):
        """boundaryModeS describes handling of texture-coordinate boundaries."""
        return self.__boundaryModeS
    @boundaryModeS.setter
    def boundaryModeS(self, boundaryModeS):
        if  boundaryModeS is None:
            boundaryModeS = 'REPEAT' # default
        assertValidSFString(boundaryModeS)
        assertValidTextureBoundaryMode('boundaryModeS', boundaryModeS)
        self.__boundaryModeS = boundaryModeS
    @property # getter - - - - - - - - - -
    def boundaryModeT(self):
        """boundaryModeT describes handling of texture-coordinate boundaries."""
        return self.__boundaryModeT
    @boundaryModeT.setter
    def boundaryModeT(self, boundaryModeT):
        if  boundaryModeT is None:
            boundaryModeT = 'REPEAT' # default
        assertValidSFString(boundaryModeT)
        assertValidTextureBoundaryMode('boundaryModeT', boundaryModeT)
        self.__boundaryModeT = boundaryModeT
    @property # getter - - - - - - - - - -
    def generateMipMaps(self):
        """Determines whether MIPMAPs are generated for texture images."""
        return self.__generateMipMaps
    @generateMipMaps.setter
    def generateMipMaps(self, generateMipMaps):
        if  generateMipMaps is None:
            generateMipMaps = False # default
        assertValidSFBool(generateMipMaps)
        self.__generateMipMaps = generateMipMaps
    @property # getter - - - - - - - - - -
    def magnificationFilter(self):
        """magnificationFilter indicates texture filter when image is smaller than screen space representation."""
        return self.__magnificationFilter
    @magnificationFilter.setter
    def magnificationFilter(self, magnificationFilter):
        if  magnificationFilter is None:
            magnificationFilter = 'FASTEST' # default
        assertValidSFString(magnificationFilter)
        assertValidTextureMagnificationMode('magnificationFilter', magnificationFilter)
        self.__magnificationFilter = magnificationFilter
    @property # getter - - - - - - - - - -
    def minificationFilter(self):
        """minificationFilter indicates texture filter when image is larger than screen space representation."""
        return self.__minificationFilter
    @minificationFilter.setter
    def minificationFilter(self, minificationFilter):
        if  minificationFilter is None:
            minificationFilter = 'FASTEST' # default
        assertValidSFString(minificationFilter)
        assertValidTextureMinificationMode('minificationFilter', minificationFilter)
        self.__minificationFilter = minificationFilter
    @property # getter - - - - - - - - - -
    def textureCompression(self):
        """textureCompression indicates compression algorithm selection mode."""
        return self.__textureCompression
    @textureCompression.setter
    def textureCompression(self, textureCompression):
        if  textureCompression is None:
            textureCompression = 'FASTEST' # default
        assertValidSFString(textureCompression)
        assertValidTextureCompressionMode('textureCompression', textureCompression)
        self.__textureCompression = textureCompression
    @property # getter - - - - - - - - - -
    def texturePriority(self):
        """[0,1] texturePriority defines relative priority for this texture when allocating texture memory, an important rendering resource in graphics-card hardware."""
        return self.__texturePriority
    @texturePriority.setter
    def texturePriority(self, texturePriority):
        if  texturePriority is None:
            texturePriority = 0 # default
        assertValidSFFloat(texturePriority)
        assertZeroToOne('texturePriority', texturePriority)
        self.__texturePriority = texturePriority
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TextureProperties.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TextureProperties'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.anisotropicDegree != 1:
            result += " anisotropicDegree='" + SFFloat(self.anisotropicDegree).XML() + "'"
        if self.borderColor != (0, 0, 0, 0):
            result += " borderColor='" + SFColorRGBA(self.borderColor).XML() + "'"
        if self.borderWidth != 0:
            result += " borderWidth='" + SFInt32(self.borderWidth).XML() + "'"
        if self.boundaryModeR != 'REPEAT':
            result += " boundaryModeR='" + self.boundaryModeR + "'"
        if self.boundaryModeS != 'REPEAT':
            result += " boundaryModeS='" + self.boundaryModeS + "'"
        if self.boundaryModeT != 'REPEAT':
            result += " boundaryModeT='" + self.boundaryModeT + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.generateMipMaps: # default=false
            result += " generateMipMaps='" + SFBool(self.generateMipMaps).XML() + "'"
        if self.magnificationFilter != 'FASTEST':
            result += " magnificationFilter='" + self.magnificationFilter + "'"
        if self.minificationFilter != 'FASTEST':
            result += " minificationFilter='" + self.minificationFilter + "'"
        if self.textureCompression != 'FASTEST':
            result += " textureCompression='" + self.textureCompression + "'"
        if self.texturePriority != 0:
            result += " texturePriority='" + SFFloat(self.texturePriority).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TextureProperties>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TextureProperties>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TextureProperties.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TextureProperties' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TextureProperties' + ' {'
        if self.anisotropicDegree != 1:
            result += " anisotropicDegree " + SFFloat(self.anisotropicDegree).VRML() + ""
        if self.borderColor != (0, 0, 0, 0):
            result += " borderColor " + SFColorRGBA(self.borderColor).VRML() + ""
        if self.borderWidth != 0:
            result += " borderWidth " + SFInt32(self.borderWidth).VRML() + ""
        if self.boundaryModeR != 'REPEAT':
            result += " boundaryModeR " +  '"' + self.boundaryModeR + '"' + ""
        if self.boundaryModeS != 'REPEAT':
            result += " boundaryModeS " +  '"' + self.boundaryModeS + '"' + ""
        if self.boundaryModeT != 'REPEAT':
            result += " boundaryModeT " +  '"' + self.boundaryModeT + '"' + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.generateMipMaps: # default=false
            result += " generateMipMaps " + SFBool(self.generateMipMaps).VRML() + ""
        if self.magnificationFilter != 'FASTEST':
            result += " magnificationFilter " +  '"' + self.magnificationFilter + '"' + ""
        if self.minificationFilter != 'FASTEST':
            result += " minificationFilter " +  '"' + self.minificationFilter + '"' + ""
        if self.textureCompression != 'FASTEST':
            result += " textureCompression " +  '"' + self.textureCompression + '"' + ""
        if self.texturePriority != 0:
            result += " texturePriority " + SFFloat(self.texturePriority).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TextureTransform(_X3DTextureTransformNode):
    """
    TextureTransform shifts 2D texture coordinates for positioning, orienting and scaling image textures on geometry.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TextureTransform'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texturing.html#TextureTransform'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureTransform'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('center', (0, 0), FieldType.SFVec2f, AccessType.inputOutput, 'TextureTransform'),
            ('rotation', 0, FieldType.SFFloat, AccessType.inputOutput, 'TextureTransform'),
            ('scale', (1, 1), FieldType.SFVec2f, AccessType.inputOutput, 'TextureTransform'),
            ('translation', (0, 0), FieldType.SFVec2f, AccessType.inputOutput, 'TextureTransform'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 center=(0, 0),
                 rotation=0,
                 scale=(1, 1),
                 translation=(0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureTransform __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.rotation = rotation
        self.scale = scale
        self.translation = translation
    @property # getter - - - - - - - - - -
    def center(self):
        """center point in 2D (s,t) texture coordinates for rotation and scaling."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0) # default
        assertValidSFVec2f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def rotation(self):
        """single rotation angle of texture about center (opposite effect appears on geometry)."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = 0 # default
        assertValidSFFloat(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        """Non-uniform planar scaling of texture about center (opposite effect appears on geometry)."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = (1, 1) # default
        assertValidSFVec2f(scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def translation(self):
        """Lateral/vertical shift in 2D (s,t) texture coordinates (opposite effect appears on geometry)."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0) # default
        assertValidSFVec2f(translation)
        self.__translation = translation
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TextureTransform.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TextureTransform'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.center != (0, 0):
            result += " center='" + SFVec2f(self.center).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.rotation != 0:
            result += " rotation='" + SFFloat(self.rotation).XML() + "'"
        if self.scale != (1, 1):
            result += " scale='" + SFVec2f(self.scale).XML() + "'"
        if self.translation != (0, 0):
            result += " translation='" + SFVec2f(self.translation).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TextureTransform>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TextureTransform>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TextureTransform.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TextureTransform' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TextureTransform' + ' {'
        if self.center != (0, 0):
            result += " center " + SFVec2f(self.center).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.rotation != 0:
            result += " rotation " + SFFloat(self.rotation).VRML() + ""
        if self.scale != (1, 1):
            result += " scale " + SFVec2f(self.scale).VRML() + ""
        if self.translation != (0, 0):
            result += " translation " + SFVec2f(self.translation).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TextureTransform3D(_X3DTextureTransformNode):
    """
    TextureTransform3D applies a 3D transformation to texture coordinates.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TextureTransform3D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texture3D.html#TextureTransform3D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureTransform3D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'TextureTransform3D'),
            ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'TextureTransform3D'),
            ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'TextureTransform3D'),
            ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'TextureTransform3D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 center=(0, 0, 0),
                 rotation=(0, 0, 1, 0),
                 scale=(1, 1, 1),
                 translation=(0, 0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureTransform3D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.rotation = rotation
        self.scale = scale
        self.translation = translation
    @property # getter - - - - - - - - - -
    def center(self):
        """center point in 2D (s,t) texture coordinates for rotation and scaling."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0) # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def rotation(self):
        """rotation angle of texture about center (opposite effect appears on geometry)."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0) # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        """Non-uniform planar scaling of texture about center (opposite effect appears on geometry)."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = (1, 1, 1) # default
        assertValidSFVec3f(scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def translation(self):
        """Lateral/vertical shift in 2D (s,t) texture coordinates (opposite effect appears on geometry)."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0) # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TextureTransform3D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TextureTransform3D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.center != (0, 0, 0):
            result += " center='" + SFVec3f(self.center).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + SFRotation(self.rotation).XML() + "'"
        if self.scale != (1, 1, 1):
            result += " scale='" + SFVec3f(self.scale).XML() + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + SFVec3f(self.translation).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TextureTransform3D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TextureTransform3D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TextureTransform3D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TextureTransform3D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TextureTransform3D' + ' {'
        if self.center != (0, 0, 0):
            result += " center " + SFVec3f(self.center).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.rotation != (0, 0, 1, 0):
            result += " rotation " + SFRotation(self.rotation).VRML() + ""
        if self.scale != (1, 1, 1):
            result += " scale " + SFVec3f(self.scale).VRML() + ""
        if self.translation != (0, 0, 0):
            result += " translation " + SFVec3f(self.translation).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TextureTransformMatrix3D(_X3DTextureTransformNode):
    """
    TextureTransformMatrix3D applies a 3D transformation to texture coordinates.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TextureTransformMatrix3D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/texture3D.html#TextureTransformMatrix3D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TextureTransformMatrix3D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('matrix', (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), FieldType.SFMatrix4f, AccessType.inputOutput, 'TextureTransformMatrix3D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 matrix=(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TextureTransformMatrix3D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.matrix = matrix
    @property # getter - - - - - - - - - -
    def matrix(self):
        """matrix is a generalized, unfiltered 4x4 transformation matrix to modify texture (opposite effect appears on geometry)."""
        return self.__matrix
    @matrix.setter
    def matrix(self, matrix):
        if  matrix is None:
            matrix = (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1) # default
        assertValidSFMatrix4f(matrix)
        self.__matrix = matrix
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TextureTransformMatrix3D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TextureTransformMatrix3D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.matrix != (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1):
            result += " matrix='" + SFMatrix4f(self.matrix).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TextureTransformMatrix3D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TextureTransformMatrix3D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TextureTransformMatrix3D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TextureTransformMatrix3D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TextureTransformMatrix3D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.matrix != (1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1):
            result += " matrix " + SFMatrix4f(self.matrix).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TimeSensor(_X3DTimeDependentNode, _X3DSensorNode):
    """
    TimeSensor continuously generates events as time passes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TimeSensor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/time.html#TimeSensor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TimeSensor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('cycleInterval', 1.0, FieldType.SFTime, AccessType.inputOutput, 'TimeSensor'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('loop', False, FieldType.SFBool, AccessType.inputOutput, 'TimeSensor'),
            ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 cycleInterval=1.0,
                 description='',
                 enabled=True,
                 loop=False,
                 pauseTime=0,
                 resumeTime=0,
                 startTime=0,
                 stopTime=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TimeSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.cycleInterval = cycleInterval
        self.description = description
        self.enabled = enabled
        self.loop = loop
        self.pauseTime = pauseTime
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
    @property # getter - - - - - - - - - -
    def cycleInterval(self):
        """[0,+infinity) cycleInterval is loop duration in seconds."""
        return self.__cycleInterval
    @cycleInterval.setter
    def cycleInterval(self, cycleInterval):
        if  cycleInterval is None:
            cycleInterval = 1.0 # default
        assertValidSFTime(cycleInterval)
        assertNonNegative('cycleInterval', cycleInterval)
        self.__cycleInterval = cycleInterval
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def loop(self):
        """Repeat indefinitely when loop=true, repeat only once when loop=false."""
        return self.__loop
    @loop.setter
    def loop(self, loop):
        if  loop is None:
            loop = False # default
        assertValidSFBool(loop)
        self.__loop = loop
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and TimeSensor becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0 # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and TimeSensor becomes inactive."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0 # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """When time now >= startTime, isActive becomes true and TimeSensor becomes active."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0 # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """When stopTime becomes <= time now, isActive becomes false and TimeSensor becomes inactive."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0 # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TimeSensor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TimeSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.cycleInterval != 1.0:
            result += " cycleInterval='" + SFTime(self.cycleInterval).XML() + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.loop: # default=false
            result += " loop='" + SFBool(self.loop).XML() + "'"
        if self.pauseTime != 0:
            result += " pauseTime='" + SFTime(self.pauseTime).XML() + "'"
        if self.resumeTime != 0:
            result += " resumeTime='" + SFTime(self.resumeTime).XML() + "'"
        if self.startTime != 0:
            result += " startTime='" + SFTime(self.startTime).XML() + "'"
        if self.stopTime != 0:
            result += " stopTime='" + SFTime(self.stopTime).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TimeSensor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TimeSensor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TimeSensor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TimeSensor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TimeSensor' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.cycleInterval != 1.0:
            result += " cycleInterval " + SFTime(self.cycleInterval).VRML() + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.loop: # default=false
            result += " loop " + SFBool(self.loop).VRML() + ""
        if self.pauseTime != 0:
            result += " pauseTime " + SFTime(self.pauseTime).VRML() + ""
        if self.resumeTime != 0:
            result += " resumeTime " + SFTime(self.resumeTime).VRML() + ""
        if self.startTime != 0:
            result += " startTime " + SFTime(self.startTime).VRML() + ""
        if self.stopTime != 0:
            result += " stopTime " + SFTime(self.stopTime).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TimeTrigger(_X3DTriggerNode):
    """
    TimeTrigger converts boolean true events to time events.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TimeTrigger'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/eventUtilities.html#TimeTrigger'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TimeTrigger'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TimeTrigger __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TimeTrigger.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TimeTrigger'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TimeTrigger>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TimeTrigger>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TimeTrigger.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TimeTrigger' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TimeTrigger' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ToneMappedVolumeStyle(_X3DComposableVolumeRenderStyleNode):
    """
    ToneMappedVolumeStyle specifies that volumetric data is rendered with Gooch shading model of two-toned warm/cool coloring.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ToneMappedVolumeStyle'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/volume.html#ToneMappedVolumeStyle'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ToneMappedVolumeStyle'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('coolColor', (0, 0, 1, 0), FieldType.SFColorRGBA, AccessType.inputOutput, 'ToneMappedVolumeStyle'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeRenderStyleNode'),
            ('warmColor', (1, 1, 0, 0), FieldType.SFColorRGBA, AccessType.inputOutput, 'ToneMappedVolumeStyle'),
            ('surfaceNormals', None, FieldType.SFNode, AccessType.inputOutput, 'ToneMappedVolumeStyle'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 coolColor=(0, 0, 1, 0),
                 enabled=True,
                 warmColor=(1, 1, 0, 0),
                 surfaceNormals=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ToneMappedVolumeStyle __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.coolColor = coolColor
        self.enabled = enabled
        self.warmColor = warmColor
        self.surfaceNormals = surfaceNormals
    @property # getter - - - - - - - - - -
    def coolColor(self):
        """[0,1] coolColor is used for surfaces facing away from the light direction."""
        return self.__coolColor
    @coolColor.setter
    def coolColor(self, coolColor):
        if  coolColor is None:
            coolColor = (0, 0, 1, 0) # default
        assertValidSFColorRGBA(coolColor)
        assertZeroToOne('coolColor', coolColor)
        self.__coolColor = coolColor
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def warmColor(self):
        """[0,1] warmColor is used for surfaces facing towards the light."""
        return self.__warmColor
    @warmColor.setter
    def warmColor(self, warmColor):
        if  warmColor is None:
            warmColor = (1, 1, 0, 0) # default
        assertValidSFColorRGBA(warmColor)
        assertZeroToOne('warmColor', warmColor)
        self.__warmColor = warmColor
    @property # getter - - - - - - - - - -
    def surfaceNormals(self):
        return self.__surfaceNormals
    @surfaceNormals.setter
    def surfaceNormals(self, surfaceNormals):
        if  surfaceNormals is None:
            surfaceNormals = None # default
        assertValidSFNode(surfaceNormals)
        if not isinstance(surfaceNormals, object):
            # print(flush=True)
            raise X3DTypeError(str(surfaceNormals) + ' does not have a valid node type object')
        self.__surfaceNormals = surfaceNormals
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.surfaceNormals
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ToneMappedVolumeStyle.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ToneMappedVolumeStyle'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.coolColor != (0, 0, 1, 0):
            result += " coolColor='" + SFColorRGBA(self.coolColor).XML() + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.warmColor != (1, 1, 0, 0):
            result += " warmColor='" + SFColorRGBA(self.warmColor).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ToneMappedVolumeStyle>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.surfaceNormals: # output this SFNode
                result += self.surfaceNormals.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ToneMappedVolumeStyle>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ToneMappedVolumeStyle.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ToneMappedVolumeStyle' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ToneMappedVolumeStyle' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.coolColor != (0, 0, 1, 0):
            result += " coolColor " + SFColorRGBA(self.coolColor).VRML() + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.warmColor != (1, 1, 0, 0):
            result += " warmColor " + SFColorRGBA(self.warmColor).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.surfaceNormals: # output this SFNode
            result += '\n' + '  ' + indent + 'surfaceNormals ' + self.surfaceNormals.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TouchSensor(_X3DTouchSensorNode):
    """
    TouchSensor tracks location and state of the pointing device, detecting when a user points at or selects (activates) geometry.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TouchSensor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/pointingDeviceSensor.html#TouchSensor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TouchSensor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DPointingDeviceSensorNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 description='',
                 enabled=True,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TouchSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.description = description
        self.enabled = enabled
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of this node."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TouchSensor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TouchSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TouchSensor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TouchSensor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TouchSensor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TouchSensor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TouchSensor' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Transform(_X3DGroupingNode):
    """
    Transform is a Grouping node that can contain most nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Transform'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/grouping.html#Transform'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Transform'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'Transform'),
            ('rotation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'Transform'),
            ('scale', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'Transform'),
            ('scaleOrientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'Transform'),
            ('translation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'Transform'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 center=(0, 0, 0),
                 rotation=(0, 0, 1, 0),
                 scale=(1, 1, 1),
                 scaleOrientation=(0, 0, 1, 0),
                 translation=(0, 0, 0),
                 visible=True,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Transform __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.center = center
        self.rotation = rotation
        self.scale = scale
        self.scaleOrientation = scaleOrientation
        self.translation = translation
        self.visible = visible
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def center(self):
        """Translation offset from origin of local coordinate system, applied prior to rotation or scaling."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0) # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def rotation(self):
        """Orientation (axis, angle in radians) of children relative to local coordinate system."""
        return self.__rotation
    @rotation.setter
    def rotation(self, rotation):
        if  rotation is None:
            rotation = (0, 0, 1, 0) # default
        assertValidSFRotation(rotation)
        self.__rotation = rotation
    @property # getter - - - - - - - - - -
    def scale(self):
        """Non-uniform x-y-z scale of child coordinate system, adjusted by center and scaleOrientation."""
        return self.__scale
    @scale.setter
    def scale(self, scale):
        if  scale is None:
            scale = (1, 1, 1) # default
        assertValidSFVec3f(scale)
        self.__scale = scale
    @property # getter - - - - - - - - - -
    def scaleOrientation(self):
        """Preliminary rotation of coordinate system before scaling (to allow scaling around arbitrary orientations)."""
        return self.__scaleOrientation
    @scaleOrientation.setter
    def scaleOrientation(self, scaleOrientation):
        if  scaleOrientation is None:
            scaleOrientation = (0, 0, 1, 0) # default
        assertValidSFRotation(scaleOrientation)
        self.__scaleOrientation = scaleOrientation
    @property # getter - - - - - - - - - -
    def translation(self):
        """Position (x, y, z in meters) of children relative to local coordinate system."""
        return self.__translation
    @translation.setter
    def translation(self, translation):
        if  translation is None:
            translation = (0, 0, 0) # default
        assertValidSFVec3f(translation)
        self.__translation = translation
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Transform.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Transform'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.center != (0, 0, 0):
            result += " center='" + SFVec3f(self.center).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.rotation != (0, 0, 1, 0):
            result += " rotation='" + SFRotation(self.rotation).XML() + "'"
        if self.scale != (1, 1, 1):
            result += " scale='" + SFVec3f(self.scale).XML() + "'"
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation='" + SFRotation(self.scaleOrientation).XML() + "'"
        if self.translation != (0, 0, 0):
            result += " translation='" + SFVec3f(self.translation).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Transform>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* Transform found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Transform>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Transform.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Transform' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Transform' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.center != (0, 0, 0):
            result += " center " + SFVec3f(self.center).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.rotation != (0, 0, 1, 0):
            result += " rotation " + SFRotation(self.rotation).VRML() + ""
        if self.scale != (1, 1, 1):
            result += " scale " + SFVec3f(self.scale).VRML() + ""
        if self.scaleOrientation != (0, 0, 1, 0):
            result += " scaleOrientation " + SFRotation(self.scaleOrientation).VRML() + ""
        if self.translation != (0, 0, 0):
            result += " translation " + SFVec3f(self.translation).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TransformSensor(_X3DEnvironmentalSensorNode):
    """
    TransformSensor generates output events when its targetObject enters, exits, and moves within a region in space (defined by a box).
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TransformSensor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/environmentalSensor.html#TransformSensor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TransformSensor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'TransformSensor'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('size', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DEnvironmentalSensorNode'),
            ('targetObject', None, FieldType.SFNode, AccessType.inputOutput, 'TransformSensor'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 center=(0, 0, 0),
                 enabled=True,
                 size=(0, 0, 0),
                 targetObject=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TransformSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.enabled = enabled
        self.size = size
        self.targetObject = targetObject
    @property # getter - - - - - - - - - -
    def center(self):
        """Translation offset from origin of local coordinate system."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0) # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def size(self):
        """[0,+infinity) size of intersection box, measured from center in meters."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = (0, 0, 0) # default
        assertValidSFVec3f(size)
        assertNonNegative('size', size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def targetObject(self):
        """[X3DGroupingNode|X3DShapeNode] targetObject is the movable geometry represented by any valid X3DGroupingNode or X3DShapeNode which may enter or exit the box."""
        return self.__targetObject
    @targetObject.setter
    def targetObject(self, targetObject):
        if  targetObject is None:
            targetObject = None # default
        assertValidSFNode(targetObject)
        if not isinstance(targetObject, object):
            # print(flush=True)
            raise X3DTypeError(str(targetObject) + ' does not have a valid node type object')
        self.__targetObject = targetObject
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.targetObject
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TransformSensor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TransformSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.center != (0, 0, 0):
            result += " center='" + SFVec3f(self.center).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.size != (0, 0, 0):
            result += " size='" + SFVec3f(self.size).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TransformSensor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.targetObject: # output this SFNode
                result += self.targetObject.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TransformSensor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TransformSensor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TransformSensor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TransformSensor' + ' {'
        if self.center != (0, 0, 0):
            result += " center " + SFVec3f(self.center).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.size != (0, 0, 0):
            result += " size " + SFVec3f(self.size).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.targetObject: # output this SFNode
            result += '\n' + '  ' + indent + 'targetObject ' + self.targetObject.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TransmitterPdu(_X3DNetworkSensorNode, _X3DBoundedObject):
    """
    TransmitterPdu is a networked Protocol Data Unit (PDU) information node that provides detailed information about a radio transmitter modeled in a simulation.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TransmitterPdu'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/dis.html#TransmitterPdu'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TransmitterPdu'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('address', 'localhost', FieldType.SFString, AccessType.inputOutput, 'TransmitterPdu'),
            ('antennaLocation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'TransmitterPdu'),
            ('antennaPatternLength', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('antennaPatternType', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('applicationID', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DBoundedObject'),
            ('cryptoKeyID', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('cryptoSystem', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('entityID', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('frequency', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('geoCoords', (0, 0, 0), FieldType.SFVec3d, AccessType.inputOutput, 'TransmitterPdu'),
            ('geoSystem', ["GD", "WE"], FieldType.MFString, AccessType.initializeOnly, 'TransmitterPdu'),
            ('inputSource', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('lengthOfModulationParameters', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('modulationTypeDetail', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('modulationTypeMajor', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('modulationTypeSpreadSpectrum', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('modulationTypeSystem', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('multicastRelayHost', '', FieldType.SFString, AccessType.inputOutput, 'TransmitterPdu'),
            ('multicastRelayPort', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('networkMode', 'standAlone', FieldType.SFString, AccessType.inputOutput, 'TransmitterPdu'),
            ('port', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('power', 0.0, FieldType.SFFloat, AccessType.inputOutput, 'TransmitterPdu'),
            ('radioEntityTypeCategory', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('radioEntityTypeCountry', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('radioEntityTypeDomain', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('radioEntityTypeKind', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('radioEntityTypeNomenclature', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('radioEntityTypeNomenclatureVersion', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('radioID', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('readInterval', 0.1, FieldType.SFTime, AccessType.inputOutput, 'TransmitterPdu'),
            ('relativeAntennaLocation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'TransmitterPdu'),
            ('rtpHeaderExpected', False, FieldType.SFBool, AccessType.initializeOnly, 'TransmitterPdu'),
            ('siteID', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('transmitFrequencyBandwidth', 0, FieldType.SFFloat, AccessType.inputOutput, 'TransmitterPdu'),
            ('transmitState', 0, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DBoundedObject'),
            ('whichGeometry', 1, FieldType.SFInt32, AccessType.inputOutput, 'TransmitterPdu'),
            ('writeInterval', 1.0, FieldType.SFTime, AccessType.inputOutput, 'TransmitterPdu'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 address='localhost',
                 antennaLocation=(0, 0, 0),
                 antennaPatternLength=0,
                 antennaPatternType=0,
                 applicationID=0,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 cryptoKeyID=0,
                 cryptoSystem=0,
                 enabled=True,
                 entityID=0,
                 frequency=0,
                 geoCoords=(0, 0, 0),
                 geoSystem=["GD", "WE"],
                 inputSource=0,
                 lengthOfModulationParameters=0,
                 modulationTypeDetail=0,
                 modulationTypeMajor=0,
                 modulationTypeSpreadSpectrum=0,
                 modulationTypeSystem=0,
                 multicastRelayHost='',
                 multicastRelayPort=0,
                 networkMode='standAlone',
                 port=0,
                 power=0.0,
                 radioEntityTypeCategory=0,
                 radioEntityTypeCountry=0,
                 radioEntityTypeDomain=0,
                 radioEntityTypeKind=0,
                 radioEntityTypeNomenclature=0,
                 radioEntityTypeNomenclatureVersion=0,
                 radioID=0,
                 readInterval=0.1,
                 relativeAntennaLocation=(0, 0, 0),
                 rtpHeaderExpected=False,
                 siteID=0,
                 transmitFrequencyBandwidth=0,
                 transmitState=0,
                 visible=True,
                 whichGeometry=1,
                 writeInterval=1.0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TransmitterPdu __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.address = address
        self.antennaLocation = antennaLocation
        self.antennaPatternLength = antennaPatternLength
        self.antennaPatternType = antennaPatternType
        self.applicationID = applicationID
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.cryptoKeyID = cryptoKeyID
        self.cryptoSystem = cryptoSystem
        self.enabled = enabled
        self.entityID = entityID
        self.frequency = frequency
        self.geoCoords = geoCoords
        self.geoSystem = geoSystem
        self.inputSource = inputSource
        self.lengthOfModulationParameters = lengthOfModulationParameters
        self.modulationTypeDetail = modulationTypeDetail
        self.modulationTypeMajor = modulationTypeMajor
        self.modulationTypeSpreadSpectrum = modulationTypeSpreadSpectrum
        self.modulationTypeSystem = modulationTypeSystem
        self.multicastRelayHost = multicastRelayHost
        self.multicastRelayPort = multicastRelayPort
        self.networkMode = networkMode
        self.port = port
        self.power = power
        self.radioEntityTypeCategory = radioEntityTypeCategory
        self.radioEntityTypeCountry = radioEntityTypeCountry
        self.radioEntityTypeDomain = radioEntityTypeDomain
        self.radioEntityTypeKind = radioEntityTypeKind
        self.radioEntityTypeNomenclature = radioEntityTypeNomenclature
        self.radioEntityTypeNomenclatureVersion = radioEntityTypeNomenclatureVersion
        self.radioID = radioID
        self.readInterval = readInterval
        self.relativeAntennaLocation = relativeAntennaLocation
        self.rtpHeaderExpected = rtpHeaderExpected
        self.siteID = siteID
        self.transmitFrequencyBandwidth = transmitFrequencyBandwidth
        self.transmitState = transmitState
        self.visible = visible
        self.whichGeometry = whichGeometry
        self.writeInterval = writeInterval
    @property # getter - - - - - - - - - -
    def address(self):
        """Multicast network address, or else "localhost" example: 224."""
        return self.__address
    @address.setter
    def address(self, address):
        if  address is None:
            address = 'localhost' # default
        assertValidSFString(address)
        self.__address = address
    @property # getter - - - - - - - - - -
    def antennaLocation(self):
        """World coordinates for antenna location."""
        return self.__antennaLocation
    @antennaLocation.setter
    def antennaLocation(self, antennaLocation):
        if  antennaLocation is None:
            antennaLocation = (0, 0, 0) # default
        assertValidSFVec3f(antennaLocation)
        self.__antennaLocation = antennaLocation
    @property # getter - - - - - - - - - -
    def antennaPatternLength(self):
        """."""
        return self.__antennaPatternLength
    @antennaPatternLength.setter
    def antennaPatternLength(self, antennaPatternLength):
        if  antennaPatternLength is None:
            antennaPatternLength = 0 # default
        assertValidSFInt32(antennaPatternLength)
        self.__antennaPatternLength = antennaPatternLength
    @property # getter - - - - - - - - - -
    def antennaPatternType(self):
        """Antenna shape pattern: 0 for omnidirectional, 1 for beam, 2 for spherical harmonic (deprecated), or optional higher value."""
        return self.__antennaPatternType
    @antennaPatternType.setter
    def antennaPatternType(self, antennaPatternType):
        if  antennaPatternType is None:
            antennaPatternType = 0 # default
        assertValidSFInt32(antennaPatternType)
        self.__antennaPatternType = antennaPatternType
    @property # getter - - - - - - - - - -
    def applicationID(self):
        """Each simulation application that can respond to simulation management PDUs needs to have a unique applicationID."""
        return self.__applicationID
    @applicationID.setter
    def applicationID(self, applicationID):
        if  applicationID is None:
            applicationID = 0 # default
        assertValidSFInt32(applicationID)
        self.__applicationID = applicationID
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def cryptoKeyID(self):
        """Nonzero value corresponding to the simulated cryptographic key."""
        return self.__cryptoKeyID
    @cryptoKeyID.setter
    def cryptoKeyID(self, cryptoKeyID):
        if  cryptoKeyID is None:
            cryptoKeyID = 0 # default
        assertValidSFInt32(cryptoKeyID)
        self.__cryptoKeyID = cryptoKeyID
    @property # getter - - - - - - - - - -
    def cryptoSystem(self):
        """Indicates type of crypto system being used, even if the encryption equipment is not keyed."""
        return self.__cryptoSystem
    @cryptoSystem.setter
    def cryptoSystem(self, cryptoSystem):
        if  cryptoSystem is None:
            cryptoSystem = 0 # default
        assertValidSFInt32(cryptoSystem)
        self.__cryptoSystem = cryptoSystem
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables the sensor node."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def entityID(self):
        """EntityID unique ID for entity within that application."""
        return self.__entityID
    @entityID.setter
    def entityID(self, entityID):
        if  entityID is None:
            entityID = 0 # default
        assertValidSFInt32(entityID)
        self.__entityID = entityID
    @property # getter - - - - - - - - - -
    def frequency(self):
        """Transmission frequency in Hz."""
        return self.__frequency
    @frequency.setter
    def frequency(self, frequency):
        if  frequency is None:
            frequency = 0 # default
        assertValidSFInt32(frequency)
        assertNonNegative('frequency', frequency)
        self.__frequency = frequency
    @property # getter - - - - - - - - - -
    def geoCoords(self):
        """Geographic location (specified in current geoSystem coordinates) for children geometry (specified in relative coordinate system, in meters)."""
        return self.__geoCoords
    @geoCoords.setter
    def geoCoords(self, geoCoords):
        if  geoCoords is None:
            geoCoords = (0, 0, 0) # default
        assertValidSFVec3d(geoCoords)
        self.__geoCoords = geoCoords
    @property # getter - - - - - - - - - -
    def geoSystem(self):
        """Identifies spatial reference frame: Geodetic (GD), Geocentric (GC), Universal Transverse Mercator (UTM)."""
        return self.__geoSystem
    @geoSystem.setter
    def geoSystem(self, geoSystem):
        if  geoSystem is None:
            geoSystem = ["GD", "WE"] # default
        assertValidMFString(geoSystem)
        self.__geoSystem = geoSystem
    @property # getter - - - - - - - - - -
    def inputSource(self):
        """Source of transmission input."""
        return self.__inputSource
    @inputSource.setter
    def inputSource(self, inputSource):
        if  inputSource is None:
            inputSource = 0 # default
        assertValidSFInt32(inputSource)
        self.__inputSource = inputSource
    @property # getter - - - - - - - - - -
    def lengthOfModulationParameters(self):
        """."""
        return self.__lengthOfModulationParameters
    @lengthOfModulationParameters.setter
    def lengthOfModulationParameters(self, lengthOfModulationParameters):
        if  lengthOfModulationParameters is None:
            lengthOfModulationParameters = 0 # default
        assertValidSFInt32(lengthOfModulationParameters)
        self.__lengthOfModulationParameters = lengthOfModulationParameters
    @property # getter - - - - - - - - - -
    def modulationTypeDetail(self):
        """Integer enumeration containing detailed information depending on the major modulation type."""
        return self.__modulationTypeDetail
    @modulationTypeDetail.setter
    def modulationTypeDetail(self, modulationTypeDetail):
        if  modulationTypeDetail is None:
            modulationTypeDetail = 0 # default
        assertValidSFInt32(modulationTypeDetail)
        self.__modulationTypeDetail = modulationTypeDetail
    @property # getter - - - - - - - - - -
    def modulationTypeMajor(self):
        """Integer enumeration containing major classification of the modulation type."""
        return self.__modulationTypeMajor
    @modulationTypeMajor.setter
    def modulationTypeMajor(self, modulationTypeMajor):
        if  modulationTypeMajor is None:
            modulationTypeMajor = 0 # default
        assertValidSFInt32(modulationTypeMajor)
        self.__modulationTypeMajor = modulationTypeMajor
    @property # getter - - - - - - - - - -
    def modulationTypeSpreadSpectrum(self):
        """Indicates the spread spectrum technique or combination of spread spectrum techniques in use."""
        return self.__modulationTypeSpreadSpectrum
    @modulationTypeSpreadSpectrum.setter
    def modulationTypeSpreadSpectrum(self, modulationTypeSpreadSpectrum):
        if  modulationTypeSpreadSpectrum is None:
            modulationTypeSpreadSpectrum = 0 # default
        assertValidSFInt32(modulationTypeSpreadSpectrum)
        self.__modulationTypeSpreadSpectrum = modulationTypeSpreadSpectrum
    @property # getter - - - - - - - - - -
    def modulationTypeSystem(self):
        """Specifies radio system associated with this Transmitter PDU and used to interpret other fields whose values depend on a specific radio system."""
        return self.__modulationTypeSystem
    @modulationTypeSystem.setter
    def modulationTypeSystem(self, modulationTypeSystem):
        if  modulationTypeSystem is None:
            modulationTypeSystem = 0 # default
        assertValidSFInt32(modulationTypeSystem)
        self.__modulationTypeSystem = modulationTypeSystem
    @property # getter - - - - - - - - - -
    def multicastRelayHost(self):
        """Fallback server address if multicast not available locally."""
        return self.__multicastRelayHost
    @multicastRelayHost.setter
    def multicastRelayHost(self, multicastRelayHost):
        if  multicastRelayHost is None:
            multicastRelayHost = SFString.DEFAULT_VALUE(self)
        assertValidSFString(multicastRelayHost)
        self.__multicastRelayHost = multicastRelayHost
    @property # getter - - - - - - - - - -
    def multicastRelayPort(self):
        """Fallback server port if multicast not available locally."""
        return self.__multicastRelayPort
    @multicastRelayPort.setter
    def multicastRelayPort(self, multicastRelayPort):
        if  multicastRelayPort is None:
            multicastRelayPort = 0 # default
        assertValidSFInt32(multicastRelayPort)
        self.__multicastRelayPort = multicastRelayPort
    @property # getter - - - - - - - - - -
    def networkMode(self):
        """Whether this entity is ignoring the network, sending DIS packets to the network, or receiving DIS packets from the network."""
        return self.__networkMode
    @networkMode.setter
    def networkMode(self, networkMode):
        if  networkMode is None:
            networkMode = 'standAlone' # default
        assertValidSFString(networkMode)
        assertValidNetworkMode('networkMode', networkMode)
        self.__networkMode = networkMode
    @property # getter - - - - - - - - - -
    def port(self):
        """Multicast network port, for example: 3000."""
        return self.__port
    @port.setter
    def port(self, port):
        if  port is None:
            port = 0 # default
        assertValidSFInt32(port)
        self.__port = port
    @property # getter - - - - - - - - - -
    def power(self):
        """Power that radio would be capable of outputting if on and transmitting, independent of actual transmit state of the radio."""
        return self.__power
    @power.setter
    def power(self, power):
        if  power is None:
            power = 0.0 # default
        assertValidSFFloat(power)
        self.__power = power
    @property # getter - - - - - - - - - -
    def radioEntityTypeCategory(self):
        """Integer enumeration containing EntityType of transmitter radio."""
        return self.__radioEntityTypeCategory
    @radioEntityTypeCategory.setter
    def radioEntityTypeCategory(self, radioEntityTypeCategory):
        if  radioEntityTypeCategory is None:
            radioEntityTypeCategory = 0 # default
        assertValidSFInt32(radioEntityTypeCategory)
        self.__radioEntityTypeCategory = radioEntityTypeCategory
    @property # getter - - - - - - - - - -
    def radioEntityTypeCountry(self):
        """Integer enumerations value for country to which the design of the entity or its design specification is attributed."""
        return self.__radioEntityTypeCountry
    @radioEntityTypeCountry.setter
    def radioEntityTypeCountry(self, radioEntityTypeCountry):
        if  radioEntityTypeCountry is None:
            radioEntityTypeCountry = 0 # default
        assertValidSFInt32(radioEntityTypeCountry)
        self.__radioEntityTypeCountry = radioEntityTypeCountry
    @property # getter - - - - - - - - - -
    def radioEntityTypeDomain(self):
        """Integer enumerations value for domain in which the entity operates: LAND, AIR, SURFACE, SUBSURFACE, SPACE or OTHER."""
        return self.__radioEntityTypeDomain
    @radioEntityTypeDomain.setter
    def radioEntityTypeDomain(self, radioEntityTypeDomain):
        if  radioEntityTypeDomain is None:
            radioEntityTypeDomain = 0 # default
        assertValidSFInt32(radioEntityTypeDomain)
        self.__radioEntityTypeDomain = radioEntityTypeDomain
    @property # getter - - - - - - - - - -
    def radioEntityTypeKind(self):
        """Integer enumerations value for whether entity is a PLATFORM, MUNITION, LIFE_FORM, ENVIRONMENTAL, CULTURAL_FEATURE, SUPPLY, RADIO, EXPENDABLE, SENSOR_EMITTER or OTHER."""
        return self.__radioEntityTypeKind
    @radioEntityTypeKind.setter
    def radioEntityTypeKind(self, radioEntityTypeKind):
        if  radioEntityTypeKind is None:
            radioEntityTypeKind = 0 # default
        assertValidSFInt32(radioEntityTypeKind)
        self.__radioEntityTypeKind = radioEntityTypeKind
    @property # getter - - - - - - - - - -
    def radioEntityTypeNomenclature(self):
        """Integer enumerations value indicating nomenclature (name) for a particular emitter."""
        return self.__radioEntityTypeNomenclature
    @radioEntityTypeNomenclature.setter
    def radioEntityTypeNomenclature(self, radioEntityTypeNomenclature):
        if  radioEntityTypeNomenclature is None:
            radioEntityTypeNomenclature = 0 # default
        assertValidSFInt32(radioEntityTypeNomenclature)
        self.__radioEntityTypeNomenclature = radioEntityTypeNomenclature
    @property # getter - - - - - - - - - -
    def radioEntityTypeNomenclatureVersion(self):
        """Named equipment version number."""
        return self.__radioEntityTypeNomenclatureVersion
    @radioEntityTypeNomenclatureVersion.setter
    def radioEntityTypeNomenclatureVersion(self, radioEntityTypeNomenclatureVersion):
        if  radioEntityTypeNomenclatureVersion is None:
            radioEntityTypeNomenclatureVersion = 0 # default
        assertValidSFInt32(radioEntityTypeNomenclatureVersion)
        self.__radioEntityTypeNomenclatureVersion = radioEntityTypeNomenclatureVersion
    @property # getter - - - - - - - - - -
    def radioID(self):
        """Identifies a particular radio within a given entity."""
        return self.__radioID
    @radioID.setter
    def radioID(self, radioID):
        if  radioID is None:
            radioID = 0 # default
        assertValidSFInt32(radioID)
        self.__radioID = radioID
    @property # getter - - - - - - - - - -
    def readInterval(self):
        """[0,+infinity) Seconds between read updates, 0 means no reading."""
        return self.__readInterval
    @readInterval.setter
    def readInterval(self, readInterval):
        if  readInterval is None:
            readInterval = 0.1 # default
        assertValidSFTime(readInterval)
        assertNonNegative('readInterval', readInterval)
        self.__readInterval = readInterval
    @property # getter - - - - - - - - - -
    def relativeAntennaLocation(self):
        """Relative coordinates for antenna location."""
        return self.__relativeAntennaLocation
    @relativeAntennaLocation.setter
    def relativeAntennaLocation(self, relativeAntennaLocation):
        if  relativeAntennaLocation is None:
            relativeAntennaLocation = (0, 0, 0) # default
        assertValidSFVec3f(relativeAntennaLocation)
        self.__relativeAntennaLocation = relativeAntennaLocation
    @property # getter - - - - - - - - - -
    def rtpHeaderExpected(self):
        """Whether RTP headers are prepended to DIS PDUs."""
        return self.__rtpHeaderExpected
    @rtpHeaderExpected.setter
    def rtpHeaderExpected(self, rtpHeaderExpected):
        if  rtpHeaderExpected is None:
            rtpHeaderExpected = False # default
        assertValidSFBool(rtpHeaderExpected)
        self.__rtpHeaderExpected = rtpHeaderExpected
    @property # getter - - - - - - - - - -
    def siteID(self):
        """Simulation/exercise siteID of the participating LAN or organization."""
        return self.__siteID
    @siteID.setter
    def siteID(self, siteID):
        if  siteID is None:
            siteID = 0 # default
        assertValidSFInt32(siteID)
        self.__siteID = siteID
    @property # getter - - - - - - - - - -
    def transmitFrequencyBandwidth(self):
        """Bandwidth of the particular transmitter measured between the half-power (-3 dB) points (this value represents total bandwidth, not the deviation from the center frequency)."""
        return self.__transmitFrequencyBandwidth
    @transmitFrequencyBandwidth.setter
    def transmitFrequencyBandwidth(self, transmitFrequencyBandwidth):
        if  transmitFrequencyBandwidth is None:
            transmitFrequencyBandwidth = 0 # default
        assertValidSFFloat(transmitFrequencyBandwidth)
        self.__transmitFrequencyBandwidth = transmitFrequencyBandwidth
    @property # getter - - - - - - - - - -
    def transmitState(self):
        """Specify radio transmission state where enumerations value 0 is for off, value 1 for powered but not transmitting, or value 1 is for powered and transmitting,."""
        return self.__transmitState
    @transmitState.setter
    def transmitState(self, transmitState):
        if  transmitState is None:
            transmitState = 0 # default
        assertValidSFInt32(transmitState)
        self.__transmitState = transmitState
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def whichGeometry(self):
        """Select geometry to render: -1 for no geometry, 0 for text trace, 1 for default geometry, (optional) higher values to render different states."""
        return self.__whichGeometry
    @whichGeometry.setter
    def whichGeometry(self, whichGeometry):
        if  whichGeometry is None:
            whichGeometry = 1 # default
        assertValidSFInt32(whichGeometry)
        self.__whichGeometry = whichGeometry
    @property # getter - - - - - - - - - -
    def writeInterval(self):
        """[0,+infinity) Seconds between write updates, 0 means no writing (sending)."""
        return self.__writeInterval
    @writeInterval.setter
    def writeInterval(self, writeInterval):
        if  writeInterval is None:
            writeInterval = 1.0 # default
        assertValidSFTime(writeInterval)
        assertNonNegative('writeInterval', writeInterval)
        self.__writeInterval = writeInterval
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TransmitterPdu.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TransmitterPdu'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.address != 'localhost':
            result += " address='" + self.address + "'"
        if self.antennaLocation != (0, 0, 0):
            result += " antennaLocation='" + SFVec3f(self.antennaLocation).XML() + "'"
        if self.antennaPatternLength != 0:
            result += " antennaPatternLength='" + SFInt32(self.antennaPatternLength).XML() + "'"
        if self.antennaPatternType != 0:
            result += " antennaPatternType='" + SFInt32(self.antennaPatternType).XML() + "'"
        if self.applicationID != 0:
            result += " applicationID='" + SFInt32(self.applicationID).XML() + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.cryptoKeyID != 0:
            result += " cryptoKeyID='" + SFInt32(self.cryptoKeyID).XML() + "'"
        if self.cryptoSystem != 0:
            result += " cryptoSystem='" + SFInt32(self.cryptoSystem).XML() + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.entityID != 0:
            result += " entityID='" + SFInt32(self.entityID).XML() + "'"
        if self.frequency != 0:
            result += " frequency='" + SFInt32(self.frequency).XML() + "'"
        if self.geoCoords != (0, 0, 0):
            result += " geoCoords='" + SFVec3d(self.geoCoords).XML() + "'"
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem='" + MFString(self.geoSystem).XML() + "'"
        if self.inputSource != 0:
            result += " inputSource='" + SFInt32(self.inputSource).XML() + "'"
        if self.lengthOfModulationParameters != 0:
            result += " lengthOfModulationParameters='" + SFInt32(self.lengthOfModulationParameters).XML() + "'"
        if self.modulationTypeDetail != 0:
            result += " modulationTypeDetail='" + SFInt32(self.modulationTypeDetail).XML() + "'"
        if self.modulationTypeMajor != 0:
            result += " modulationTypeMajor='" + SFInt32(self.modulationTypeMajor).XML() + "'"
        if self.modulationTypeSpreadSpectrum != 0:
            result += " modulationTypeSpreadSpectrum='" + SFInt32(self.modulationTypeSpreadSpectrum).XML() + "'"
        if self.modulationTypeSystem != 0:
            result += " modulationTypeSystem='" + SFInt32(self.modulationTypeSystem).XML() + "'"
        if self.multicastRelayHost:
            result += " multicastRelayHost='" + self.multicastRelayHost + "'"
        if self.multicastRelayPort != 0:
            result += " multicastRelayPort='" + SFInt32(self.multicastRelayPort).XML() + "'"
        if self.networkMode != 'standAlone':
            result += " networkMode='" + self.networkMode + "'"
        if self.port != 0:
            result += " port='" + SFInt32(self.port).XML() + "'"
        if self.power != 0.0:
            result += " power='" + SFFloat(self.power).XML() + "'"
        if self.radioEntityTypeCategory != 0:
            result += " radioEntityTypeCategory='" + SFInt32(self.radioEntityTypeCategory).XML() + "'"
        if self.radioEntityTypeCountry != 0:
            result += " radioEntityTypeCountry='" + SFInt32(self.radioEntityTypeCountry).XML() + "'"
        if self.radioEntityTypeDomain != 0:
            result += " radioEntityTypeDomain='" + SFInt32(self.radioEntityTypeDomain).XML() + "'"
        if self.radioEntityTypeKind != 0:
            result += " radioEntityTypeKind='" + SFInt32(self.radioEntityTypeKind).XML() + "'"
        if self.radioEntityTypeNomenclature != 0:
            result += " radioEntityTypeNomenclature='" + SFInt32(self.radioEntityTypeNomenclature).XML() + "'"
        if self.radioEntityTypeNomenclatureVersion != 0:
            result += " radioEntityTypeNomenclatureVersion='" + SFInt32(self.radioEntityTypeNomenclatureVersion).XML() + "'"
        if self.radioID != 0:
            result += " radioID='" + SFInt32(self.radioID).XML() + "'"
        if self.readInterval != 0.1:
            result += " readInterval='" + SFTime(self.readInterval).XML() + "'"
        if self.relativeAntennaLocation != (0, 0, 0):
            result += " relativeAntennaLocation='" + SFVec3f(self.relativeAntennaLocation).XML() + "'"
        if self.rtpHeaderExpected: # default=false
            result += " rtpHeaderExpected='" + SFBool(self.rtpHeaderExpected).XML() + "'"
        if self.siteID != 0:
            result += " siteID='" + SFInt32(self.siteID).XML() + "'"
        if self.transmitFrequencyBandwidth != 0:
            result += " transmitFrequencyBandwidth='" + SFFloat(self.transmitFrequencyBandwidth).XML() + "'"
        if self.transmitState != 0:
            result += " transmitState='" + SFInt32(self.transmitState).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if self.whichGeometry != 1:
            result += " whichGeometry='" + SFInt32(self.whichGeometry).XML() + "'"
        if self.writeInterval != 1.0:
            result += " writeInterval='" + SFTime(self.writeInterval).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TransmitterPdu>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TransmitterPdu>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TransmitterPdu.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TransmitterPdu' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TransmitterPdu' + ' {'
        if self.address != 'localhost':
            result += " address " +  '"' + self.address + '"' + ""
        if self.antennaLocation != (0, 0, 0):
            result += " antennaLocation " + SFVec3f(self.antennaLocation).VRML() + ""
        if self.antennaPatternLength != 0:
            result += " antennaPatternLength " + SFInt32(self.antennaPatternLength).VRML() + ""
        if self.antennaPatternType != 0:
            result += " antennaPatternType " + SFInt32(self.antennaPatternType).VRML() + ""
        if self.applicationID != 0:
            result += " applicationID " + SFInt32(self.applicationID).VRML() + ""
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.cryptoKeyID != 0:
            result += " cryptoKeyID " + SFInt32(self.cryptoKeyID).VRML() + ""
        if self.cryptoSystem != 0:
            result += " cryptoSystem " + SFInt32(self.cryptoSystem).VRML() + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.entityID != 0:
            result += " entityID " + SFInt32(self.entityID).VRML() + ""
        if self.frequency != 0:
            result += " frequency " + SFInt32(self.frequency).VRML() + ""
        if self.geoCoords != (0, 0, 0):
            result += " geoCoords " + SFVec3d(self.geoCoords).VRML() + ""
        if self.geoSystem != ["GD", "WE"]:
            result += " geoSystem " + MFString(self.geoSystem).VRML() + ""
        if self.inputSource != 0:
            result += " inputSource " + SFInt32(self.inputSource).VRML() + ""
        if self.lengthOfModulationParameters != 0:
            result += " lengthOfModulationParameters " + SFInt32(self.lengthOfModulationParameters).VRML() + ""
        if self.modulationTypeDetail != 0:
            result += " modulationTypeDetail " + SFInt32(self.modulationTypeDetail).VRML() + ""
        if self.modulationTypeMajor != 0:
            result += " modulationTypeMajor " + SFInt32(self.modulationTypeMajor).VRML() + ""
        if self.modulationTypeSpreadSpectrum != 0:
            result += " modulationTypeSpreadSpectrum " + SFInt32(self.modulationTypeSpreadSpectrum).VRML() + ""
        if self.modulationTypeSystem != 0:
            result += " modulationTypeSystem " + SFInt32(self.modulationTypeSystem).VRML() + ""
        if self.multicastRelayHost:
            result += " multicastRelayHost " +  '"' + self.multicastRelayHost + '"' + ""
        if self.multicastRelayPort != 0:
            result += " multicastRelayPort " + SFInt32(self.multicastRelayPort).VRML() + ""
        if self.networkMode != 'standAlone':
            result += " networkMode " +  '"' + self.networkMode + '"' + ""
        if self.port != 0:
            result += " port " + SFInt32(self.port).VRML() + ""
        if self.power != 0.0:
            result += " power " + SFFloat(self.power).VRML() + ""
        if self.radioEntityTypeCategory != 0:
            result += " radioEntityTypeCategory " + SFInt32(self.radioEntityTypeCategory).VRML() + ""
        if self.radioEntityTypeCountry != 0:
            result += " radioEntityTypeCountry " + SFInt32(self.radioEntityTypeCountry).VRML() + ""
        if self.radioEntityTypeDomain != 0:
            result += " radioEntityTypeDomain " + SFInt32(self.radioEntityTypeDomain).VRML() + ""
        if self.radioEntityTypeKind != 0:
            result += " radioEntityTypeKind " + SFInt32(self.radioEntityTypeKind).VRML() + ""
        if self.radioEntityTypeNomenclature != 0:
            result += " radioEntityTypeNomenclature " + SFInt32(self.radioEntityTypeNomenclature).VRML() + ""
        if self.radioEntityTypeNomenclatureVersion != 0:
            result += " radioEntityTypeNomenclatureVersion " + SFInt32(self.radioEntityTypeNomenclatureVersion).VRML() + ""
        if self.radioID != 0:
            result += " radioID " + SFInt32(self.radioID).VRML() + ""
        if self.readInterval != 0.1:
            result += " readInterval " + SFTime(self.readInterval).VRML() + ""
        if self.relativeAntennaLocation != (0, 0, 0):
            result += " relativeAntennaLocation " + SFVec3f(self.relativeAntennaLocation).VRML() + ""
        if self.rtpHeaderExpected: # default=false
            result += " rtpHeaderExpected " + SFBool(self.rtpHeaderExpected).VRML() + ""
        if self.siteID != 0:
            result += " siteID " + SFInt32(self.siteID).VRML() + ""
        if self.transmitFrequencyBandwidth != 0:
            result += " transmitFrequencyBandwidth " + SFFloat(self.transmitFrequencyBandwidth).VRML() + ""
        if self.transmitState != 0:
            result += " transmitState " + SFInt32(self.transmitState).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.whichGeometry != 1:
            result += " whichGeometry " + SFInt32(self.whichGeometry).VRML() + ""
        if self.writeInterval != 1.0:
            result += " writeInterval " + SFTime(self.writeInterval).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TriangleFanSet(_X3DComposedGeometryNode):
    """
    TriangleFanSet is a geometry node containing a Coordinate|CoordinateDouble node, and can also contain Color|ColorRGBA, Normal and TextureCoordinate nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TriangleFanSet'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#TriangleFanSet'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TriangleFanSet'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('fanCount', list(), FieldType.MFInt32, AccessType.inputOutput, 'TriangleFanSet'),
            ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('color', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('attrib', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 fanCount=list(),
                 normalPerVertex=True,
                 solid=True,
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TriangleFanSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.fanCount = fanCount
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color|ColorRGBA values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def fanCount(self):
        """(3,+infinity) fanCount array provides number of vertices in each fan."""
        return self.__fanCount
    @fanCount.setter
    def fanCount(self, fanCount):
        if  fanCount is None:
            fanCount = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(fanCount)
        assertGreaterThanEquals('fanCount', fanCount, 3)
        self.__fanCount = fanCount
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that specifies color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None # default
        assertValidSFNode(color)
        if not isinstance(color, object):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that specifies a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None # default
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that specifies depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None # default
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that specifies perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None # default
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that specifies coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None # default
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that specifies list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.attrib or self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TriangleFanSet.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TriangleFanSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.ccw: # default=true
            result += " ccw='" + SFBool(self.ccw).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex='" + SFBool(self.colorPerVertex).XML() + "'"
        if self.fanCount != list():
            result += " fanCount='" + MFInt32(self.fanCount).XML() + "'"
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex='" + SFBool(self.normalPerVertex).XML() + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TriangleFanSet>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.color: # output this SFNode
                result += self.color.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.coord: # output this SFNode
                result += self.coord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.fogCoord: # output this SFNode
                result += self.fogCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.normal: # output this SFNode
                result += self.normal.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.texCoord: # output this SFNode
                result += self.texCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.attrib: # walk each child in MFNode list, if any
            ### print('* TriangleFanSet found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(attrib)=' + str(len(self.attrib)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.attrib:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TriangleFanSet>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TriangleFanSet.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TriangleFanSet' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TriangleFanSet' + ' {'
        if not self.ccw: # default=true
            result += " ccw " + SFBool(self.ccw).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex " + SFBool(self.colorPerVertex).VRML() + ""
        if self.fanCount != list():
            result += " fanCount " + MFInt32(self.fanCount).VRML() + ""
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex " + SFBool(self.normalPerVertex).VRML() + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.color: # output this SFNode
            result += '\n' + '  ' + indent + 'color ' + self.color.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.coord: # output this SFNode
            result += '\n' + '  ' + indent + 'coord ' + self.coord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.fogCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'fogCoord ' + self.fogCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.normal: # output this SFNode
            result += '\n' + '  ' + indent + 'normal ' + self.normal.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'texCoord ' + self.texCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.attrib: # walk each child in MFNode list, if any
            for each in self.attrib:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TriangleSet(_X3DComposedGeometryNode):
    """
    TriangleSet is a geometry node containing a Coordinate|CoordinateDouble node, and can also contain Color|ColorRGBA, Normal and TextureCoordinate nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TriangleSet'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#TriangleSet'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TriangleSet'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('color', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('attrib', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 normalPerVertex=True,
                 solid=True,
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TriangleSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color|ColorRGBA values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that specifies color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None # default
        assertValidSFNode(color)
        if not isinstance(color, object):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that specifies a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None # default
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that specifies depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None # default
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that specifies perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None # default
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that specifies coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None # default
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that specifies list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.attrib or self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TriangleSet.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TriangleSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.ccw: # default=true
            result += " ccw='" + SFBool(self.ccw).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex='" + SFBool(self.colorPerVertex).XML() + "'"
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex='" + SFBool(self.normalPerVertex).XML() + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TriangleSet>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.color: # output this SFNode
                result += self.color.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.coord: # output this SFNode
                result += self.coord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.fogCoord: # output this SFNode
                result += self.fogCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.normal: # output this SFNode
                result += self.normal.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.texCoord: # output this SFNode
                result += self.texCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.attrib: # walk each child in MFNode list, if any
            ### print('* TriangleSet found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(attrib)=' + str(len(self.attrib)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.attrib:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TriangleSet>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TriangleSet.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TriangleSet' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TriangleSet' + ' {'
        if not self.ccw: # default=true
            result += " ccw " + SFBool(self.ccw).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex " + SFBool(self.colorPerVertex).VRML() + ""
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex " + SFBool(self.normalPerVertex).VRML() + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.color: # output this SFNode
            result += '\n' + '  ' + indent + 'color ' + self.color.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.coord: # output this SFNode
            result += '\n' + '  ' + indent + 'coord ' + self.coord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.fogCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'fogCoord ' + self.fogCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.normal: # output this SFNode
            result += '\n' + '  ' + indent + 'normal ' + self.normal.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'texCoord ' + self.texCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.attrib: # walk each child in MFNode list, if any
            for each in self.attrib:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TriangleSet2D(_X3DGeometryNode):
    """
    TriangleSet2D is a geometry node that defines a set of filled 2D triangles in X-Y plane.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TriangleSet2D'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/geometry2D.html#TriangleSet2D'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TriangleSet2D'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('solid', False, FieldType.SFBool, AccessType.initializeOnly, 'TriangleSet2D'),
            ('vertices', list(), FieldType.MFVec2f, AccessType.inputOutput, 'TriangleSet2D'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 solid=False,
                 vertices=list(),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TriangleSet2D __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.solid = solid
        self.vertices = vertices
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = False # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def vertices(self):
        """2D coordinates of TriangleSet2D vertices."""
        return self.__vertices
    @vertices.setter
    def vertices(self, vertices):
        if  vertices is None:
            vertices = MFVec2f.DEFAULT_VALUE(self)
        assertValidMFVec2f(vertices)
        self.__vertices = vertices
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TriangleSet2D.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TriangleSet2D'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.solid: # default=false
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if self.vertices != list():
            result += " vertices='" + MFVec2f(self.vertices).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TriangleSet2D>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TriangleSet2D>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TriangleSet2D.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TriangleSet2D' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TriangleSet2D' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.solid: # default=false
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.vertices != list():
            result += " vertices " + MFVec2f(self.vertices).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TriangleStripSet(_X3DComposedGeometryNode):
    """
    TriangleStripSet is a geometry node containing a Coordinate|CoordinateDouble node, and can also contain Color|ColorRGBA, Normal and TextureCoordinate nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TriangleStripSet'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rendering.html#TriangleStripSet'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TriangleStripSet'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ccw', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('colorPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('normalPerVertex', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('solid', True, FieldType.SFBool, AccessType.initializeOnly, 'X3DComposedGeometryNode'),
            ('stripCount', list(), FieldType.MFInt32, AccessType.inputOutput, 'TriangleStripSet'),
            ('color', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('fogCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('normal', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('texCoord', None, FieldType.SFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('attrib', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DComposedGeometryNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ccw=True,
                 colorPerVertex=True,
                 normalPerVertex=True,
                 solid=True,
                 stripCount=list(),
                 color=None,
                 coord=None,
                 fogCoord=None,
                 normal=None,
                 texCoord=None,
                 attrib=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TriangleStripSet __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ccw = ccw
        self.colorPerVertex = colorPerVertex
        self.normalPerVertex = normalPerVertex
        self.solid = solid
        self.stripCount = stripCount
        self.color = color
        self.coord = coord
        self.fogCoord = fogCoord
        self.normal = normal
        self.texCoord = texCoord
        self.attrib = attrib
    @property # getter - - - - - - - - - -
    def ccw(self):
        """ccw defines clockwise/counterclockwise ordering of vertex coordinates, which in turn defines front/back orientation of polygon normals according to Right-Hand Rule (RHR)."""
        return self.__ccw
    @ccw.setter
    def ccw(self, ccw):
        if  ccw is None:
            ccw = True # default
        assertValidSFBool(ccw)
        self.__ccw = ccw
    @property # getter - - - - - - - - - -
    def colorPerVertex(self):
        """Whether Color|ColorRGBA values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__colorPerVertex
    @colorPerVertex.setter
    def colorPerVertex(self, colorPerVertex):
        if  colorPerVertex is None:
            colorPerVertex = True # default
        assertValidSFBool(colorPerVertex)
        self.__colorPerVertex = colorPerVertex
    @property # getter - - - - - - - - - -
    def normalPerVertex(self):
        """Whether Normal node vector values are applied to each point vertex (true) or to each polygon face (false)."""
        return self.__normalPerVertex
    @normalPerVertex.setter
    def normalPerVertex(self, normalPerVertex):
        if  normalPerVertex is None:
            normalPerVertex = True # default
        assertValidSFBool(normalPerVertex)
        self.__normalPerVertex = normalPerVertex
    @property # getter - - - - - - - - - -
    def solid(self):
        """Setting solid true means draw only one side of polygons (backface culling on), setting solid false means draw both sides of polygons (backface culling off)."""
        return self.__solid
    @solid.setter
    def solid(self, solid):
        if  solid is None:
            solid = True # default
        assertValidSFBool(solid)
        self.__solid = solid
    @property # getter - - - - - - - - - -
    def stripCount(self):
        """(3,+infinity) stripCount array provides number of vertices in each strip."""
        return self.__stripCount
    @stripCount.setter
    def stripCount(self, stripCount):
        if  stripCount is None:
            stripCount = MFInt32.DEFAULT_VALUE(self)
        assertValidMFInt32(stripCount)
        assertGreaterThanEquals('stripCount', stripCount, 3)
        self.__stripCount = stripCount
    @property # getter - - - - - - - - - -
    def color(self):
        """[X3DColorNode] Single contained Color or ColorRGBA node that specifies color values applied to corresponding vertices according to colorIndex and colorPerVertex fields."""
        return self.__color
    @color.setter
    def color(self, color):
        if  color is None:
            color = None # default
        assertValidSFNode(color)
        if not isinstance(color, object):
            # print(flush=True)
            raise X3DTypeError(str(color) + ' does not have a valid node type object')
        self.__color = color
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Single contained Coordinate or CoordinateDouble node that specifies a list of vertex values."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None # default
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    @property # getter - - - - - - - - - -
    def fogCoord(self):
        """[FogCoordinate] Single contained FogCoordinate node that specifies depth parameters for fog in corresponding geometry."""
        return self.__fogCoord
    @fogCoord.setter
    def fogCoord(self, fogCoord):
        if  fogCoord is None:
            fogCoord = None # default
        assertValidSFNode(fogCoord)
        if not isinstance(fogCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(fogCoord) + ' does not have a valid node type object')
        self.__fogCoord = fogCoord
    @property # getter - - - - - - - - - -
    def normal(self):
        """[X3DNormalNode] Single contained Normal node that specifies perpendicular vectors for corresponding vertices to support rendering computations, applied according to the normalPerVertex field."""
        return self.__normal
    @normal.setter
    def normal(self, normal):
        if  normal is None:
            normal = None # default
        assertValidSFNode(normal)
        if not isinstance(normal, object):
            # print(flush=True)
            raise X3DTypeError(str(normal) + ' does not have a valid node type object')
        self.__normal = normal
    @property # getter - - - - - - - - - -
    def texCoord(self):
        """[X3DTextureCoordinateNode] Single contained TextureCoordinate, TextureCoordinateGenerator or MultiTextureCoordinate node that specifies coordinates for texture mapping onto corresponding geometry."""
        return self.__texCoord
    @texCoord.setter
    def texCoord(self, texCoord):
        if  texCoord is None:
            texCoord = None # default
        assertValidSFNode(texCoord)
        if not isinstance(texCoord, object):
            # print(flush=True)
            raise X3DTypeError(str(texCoord) + ' does not have a valid node type object')
        self.__texCoord = texCoord
    @property # getter - - - - - - - - - -
    def attrib(self):
        """[X3DVertexAttributeNode] Single contained FloatVertexAttribute node that specifies list of per-vertex attribute information for programmable shaders."""
        return self.__attrib
    @attrib.setter
    def attrib(self, attrib):
        if  attrib is None:
            attrib = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(attrib)
        self.__attrib = attrib
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.attrib or self.color or self.coord or self.fogCoord or self.IS or self.metadata or self.normal or self.texCoord
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TriangleStripSet.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TriangleStripSet'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if not self.ccw: # default=true
            result += " ccw='" + SFBool(self.ccw).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex='" + SFBool(self.colorPerVertex).XML() + "'"
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex='" + SFBool(self.normalPerVertex).XML() + "'"
        if not self.solid: # default=true
            result += " solid='" + SFBool(self.solid).XML() + "'"
        if self.stripCount != list():
            result += " stripCount='" + MFInt32(self.stripCount).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TriangleStripSet>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.color: # output this SFNode
                result += self.color.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.coord: # output this SFNode
                result += self.coord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.fogCoord: # output this SFNode
                result += self.fogCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.normal: # output this SFNode
                result += self.normal.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.texCoord: # output this SFNode
                result += self.texCoord.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.attrib: # walk each child in MFNode list, if any
            ### print('* TriangleStripSet found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(attrib)=' + str(len(self.attrib)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.attrib:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TriangleStripSet>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TriangleStripSet.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TriangleStripSet' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TriangleStripSet' + ' {'
        if not self.ccw: # default=true
            result += " ccw " + SFBool(self.ccw).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.colorPerVertex: # default=true
            result += " colorPerVertex " + SFBool(self.colorPerVertex).VRML() + ""
        if not self.normalPerVertex: # default=true
            result += " normalPerVertex " + SFBool(self.normalPerVertex).VRML() + ""
        if not self.solid: # default=true
            result += " solid " + SFBool(self.solid).VRML() + ""
        if self.stripCount != list():
            result += " stripCount " + MFInt32(self.stripCount).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.color: # output this SFNode
            result += '\n' + '  ' + indent + 'color ' + self.color.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.coord: # output this SFNode
            result += '\n' + '  ' + indent + 'coord ' + self.coord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.fogCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'fogCoord ' + self.fogCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.normal: # output this SFNode
            result += '\n' + '  ' + indent + 'normal ' + self.normal.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.texCoord: # output this SFNode
            result += '\n' + '  ' + indent + 'texCoord ' + self.texCoord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.attrib: # walk each child in MFNode list, if any
            for each in self.attrib:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class TwoSidedMaterial(_X3DMaterialNode):
    """
    TwoSidedMaterial specifies surface rendering properties for associated geometry nodes, for outer (front) and inner (back) sides of polygons.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'TwoSidedMaterial'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shape.html#TwoSidedMaterial'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#TwoSidedMaterial'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('ambientIntensity', 0.2, FieldType.SFFloat, AccessType.inputOutput, 'TwoSidedMaterial'),
            ('backAmbientIntensity', 0.2, FieldType.SFFloat, AccessType.inputOutput, 'TwoSidedMaterial'),
            ('backDiffuseColor', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.inputOutput, 'TwoSidedMaterial'),
            ('backEmissiveColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput, 'TwoSidedMaterial'),
            ('backShininess', 0.2, FieldType.SFFloat, AccessType.inputOutput, 'TwoSidedMaterial'),
            ('backSpecularColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput, 'TwoSidedMaterial'),
            ('backTransparency', 0, FieldType.SFFloat, AccessType.inputOutput, 'TwoSidedMaterial'),
            ('diffuseColor', (0.8, 0.8, 0.8), FieldType.SFColor, AccessType.inputOutput, 'TwoSidedMaterial'),
            ('emissiveColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput, 'TwoSidedMaterial'),
            ('separateBackColor', False, FieldType.SFBool, AccessType.inputOutput, 'TwoSidedMaterial'),
            ('shininess', 0.2, FieldType.SFFloat, AccessType.inputOutput, 'TwoSidedMaterial'),
            ('specularColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput, 'TwoSidedMaterial'),
            ('transparency', 0, FieldType.SFFloat, AccessType.inputOutput, 'TwoSidedMaterial'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 ambientIntensity=0.2,
                 backAmbientIntensity=0.2,
                 backDiffuseColor=(0.8, 0.8, 0.8),
                 backEmissiveColor=(0, 0, 0),
                 backShininess=0.2,
                 backSpecularColor=(0, 0, 0),
                 backTransparency=0,
                 diffuseColor=(0.8, 0.8, 0.8),
                 emissiveColor=(0, 0, 0),
                 separateBackColor=False,
                 shininess=0.2,
                 specularColor=(0, 0, 0),
                 transparency=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode TwoSidedMaterial __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.ambientIntensity = ambientIntensity
        self.backAmbientIntensity = backAmbientIntensity
        self.backDiffuseColor = backDiffuseColor
        self.backEmissiveColor = backEmissiveColor
        self.backShininess = backShininess
        self.backSpecularColor = backSpecularColor
        self.backTransparency = backTransparency
        self.diffuseColor = diffuseColor
        self.emissiveColor = emissiveColor
        self.separateBackColor = separateBackColor
        self.shininess = shininess
        self.specularColor = specularColor
        self.transparency = transparency
    @property # getter - - - - - - - - - -
    def ambientIntensity(self):
        """[0,1] how much ambient omnidirectional light is reflected from all light sources."""
        return self.__ambientIntensity
    @ambientIntensity.setter
    def ambientIntensity(self, ambientIntensity):
        if  ambientIntensity is None:
            ambientIntensity = 0.2 # default
        assertValidSFFloat(ambientIntensity)
        assertZeroToOne('ambientIntensity', ambientIntensity)
        self.__ambientIntensity = ambientIntensity
    @property # getter - - - - - - - - - -
    def backAmbientIntensity(self):
        """[0,1] how much ambient omnidirectional light is reflected from all light sources."""
        return self.__backAmbientIntensity
    @backAmbientIntensity.setter
    def backAmbientIntensity(self, backAmbientIntensity):
        if  backAmbientIntensity is None:
            backAmbientIntensity = 0.2 # default
        assertValidSFFloat(backAmbientIntensity)
        assertZeroToOne('backAmbientIntensity', backAmbientIntensity)
        self.__backAmbientIntensity = backAmbientIntensity
    @property # getter - - - - - - - - - -
    def backDiffuseColor(self):
        """[0,1] how much direct, angle-dependent light is reflected from all light sources."""
        return self.__backDiffuseColor
    @backDiffuseColor.setter
    def backDiffuseColor(self, backDiffuseColor):
        if  backDiffuseColor is None:
            backDiffuseColor = (0.8, 0.8, 0.8) # default
        assertValidSFColor(backDiffuseColor)
        assertZeroToOne('backDiffuseColor', backDiffuseColor)
        self.__backDiffuseColor = backDiffuseColor
    @property # getter - - - - - - - - - -
    def backEmissiveColor(self):
        """[0,1] how much glowing light is emitted from this object."""
        return self.__backEmissiveColor
    @backEmissiveColor.setter
    def backEmissiveColor(self, backEmissiveColor):
        if  backEmissiveColor is None:
            backEmissiveColor = (0, 0, 0) # default
        assertValidSFColor(backEmissiveColor)
        assertZeroToOne('backEmissiveColor', backEmissiveColor)
        self.__backEmissiveColor = backEmissiveColor
    @property # getter - - - - - - - - - -
    def backShininess(self):
        """[0,1] Lower shininess values provide soft specular glows, while higher values result in sharper, smaller highlights."""
        return self.__backShininess
    @backShininess.setter
    def backShininess(self, backShininess):
        if  backShininess is None:
            backShininess = 0.2 # default
        assertValidSFFloat(backShininess)
        assertZeroToOne('backShininess', backShininess)
        self.__backShininess = backShininess
    @property # getter - - - - - - - - - -
    def backSpecularColor(self):
        """[0,1] specular highlights are brightness reflections (example: shiny spots on an apple)."""
        return self.__backSpecularColor
    @backSpecularColor.setter
    def backSpecularColor(self, backSpecularColor):
        if  backSpecularColor is None:
            backSpecularColor = (0, 0, 0) # default
        assertValidSFColor(backSpecularColor)
        assertZeroToOne('backSpecularColor', backSpecularColor)
        self.__backSpecularColor = backSpecularColor
    @property # getter - - - - - - - - - -
    def backTransparency(self):
        """[0,1] how "clear" an object is: 1."""
        return self.__backTransparency
    @backTransparency.setter
    def backTransparency(self, backTransparency):
        if  backTransparency is None:
            backTransparency = 0 # default
        assertValidSFFloat(backTransparency)
        assertZeroToOne('backTransparency', backTransparency)
        self.__backTransparency = backTransparency
    @property # getter - - - - - - - - - -
    def diffuseColor(self):
        """[0,1] how much direct, angle-dependent light is reflected from all light sources."""
        return self.__diffuseColor
    @diffuseColor.setter
    def diffuseColor(self, diffuseColor):
        if  diffuseColor is None:
            diffuseColor = (0.8, 0.8, 0.8) # default
        assertValidSFColor(diffuseColor)
        assertZeroToOne('diffuseColor', diffuseColor)
        self.__diffuseColor = diffuseColor
    @property # getter - - - - - - - - - -
    def emissiveColor(self):
        """[0,1] how much glowing light is emitted from this object."""
        return self.__emissiveColor
    @emissiveColor.setter
    def emissiveColor(self, emissiveColor):
        if  emissiveColor is None:
            emissiveColor = (0, 0, 0) # default
        assertValidSFColor(emissiveColor)
        assertZeroToOne('emissiveColor', emissiveColor)
        self.__emissiveColor = emissiveColor
    @property # getter - - - - - - - - - -
    def separateBackColor(self):
        """separateBackColor determines whether separate Material values are used for back faces."""
        return self.__separateBackColor
    @separateBackColor.setter
    def separateBackColor(self, separateBackColor):
        if  separateBackColor is None:
            separateBackColor = False # default
        assertValidSFBool(separateBackColor)
        self.__separateBackColor = separateBackColor
    @property # getter - - - - - - - - - -
    def shininess(self):
        """[0,1] Lower shininess values provide soft specular glows, while higher values result in sharper, smaller highlights."""
        return self.__shininess
    @shininess.setter
    def shininess(self, shininess):
        if  shininess is None:
            shininess = 0.2 # default
        assertValidSFFloat(shininess)
        assertZeroToOne('shininess', shininess)
        self.__shininess = shininess
    @property # getter - - - - - - - - - -
    def specularColor(self):
        """[0,1] specular highlights are brightness reflections (example: shiny spots on an apple)."""
        return self.__specularColor
    @specularColor.setter
    def specularColor(self, specularColor):
        if  specularColor is None:
            specularColor = (0, 0, 0) # default
        assertValidSFColor(specularColor)
        assertZeroToOne('specularColor', specularColor)
        self.__specularColor = specularColor
    @property # getter - - - - - - - - - -
    def transparency(self):
        """[0,1] how "clear" an object is: 1."""
        return self.__transparency
    @transparency.setter
    def transparency(self, transparency):
        if  transparency is None:
            transparency = 0 # default
        assertValidSFFloat(transparency)
        assertZeroToOne('transparency', transparency)
        self.__transparency = transparency
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function TwoSidedMaterial.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<TwoSidedMaterial'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.ambientIntensity != 0.2:
            result += " ambientIntensity='" + SFFloat(self.ambientIntensity).XML() + "'"
        if self.backAmbientIntensity != 0.2:
            result += " backAmbientIntensity='" + SFFloat(self.backAmbientIntensity).XML() + "'"
        if self.backDiffuseColor != (0.8, 0.8, 0.8):
            result += " backDiffuseColor='" + SFColor(self.backDiffuseColor).XML() + "'"
        if self.backEmissiveColor != (0, 0, 0):
            result += " backEmissiveColor='" + SFColor(self.backEmissiveColor).XML() + "'"
        if self.backShininess != 0.2:
            result += " backShininess='" + SFFloat(self.backShininess).XML() + "'"
        if self.backSpecularColor != (0, 0, 0):
            result += " backSpecularColor='" + SFColor(self.backSpecularColor).XML() + "'"
        if self.backTransparency != 0:
            result += " backTransparency='" + SFFloat(self.backTransparency).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.diffuseColor != (0.8, 0.8, 0.8):
            result += " diffuseColor='" + SFColor(self.diffuseColor).XML() + "'"
        if self.emissiveColor != (0, 0, 0):
            result += " emissiveColor='" + SFColor(self.emissiveColor).XML() + "'"
        if self.separateBackColor: # default=false
            result += " separateBackColor='" + SFBool(self.separateBackColor).XML() + "'"
        if self.shininess != 0.2:
            result += " shininess='" + SFFloat(self.shininess).XML() + "'"
        if self.specularColor != (0, 0, 0):
            result += " specularColor='" + SFColor(self.specularColor).XML() + "'"
        if self.transparency != 0:
            result += " transparency='" + SFFloat(self.transparency).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></TwoSidedMaterial>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</TwoSidedMaterial>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function TwoSidedMaterial.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'TwoSidedMaterial' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'TwoSidedMaterial' + ' {'
        if self.ambientIntensity != 0.2:
            result += " ambientIntensity " + SFFloat(self.ambientIntensity).VRML() + ""
        if self.backAmbientIntensity != 0.2:
            result += " backAmbientIntensity " + SFFloat(self.backAmbientIntensity).VRML() + ""
        if self.backDiffuseColor != (0.8, 0.8, 0.8):
            result += " backDiffuseColor " + SFColor(self.backDiffuseColor).VRML() + ""
        if self.backEmissiveColor != (0, 0, 0):
            result += " backEmissiveColor " + SFColor(self.backEmissiveColor).VRML() + ""
        if self.backShininess != 0.2:
            result += " backShininess " + SFFloat(self.backShininess).VRML() + ""
        if self.backSpecularColor != (0, 0, 0):
            result += " backSpecularColor " + SFColor(self.backSpecularColor).VRML() + ""
        if self.backTransparency != 0:
            result += " backTransparency " + SFFloat(self.backTransparency).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.diffuseColor != (0.8, 0.8, 0.8):
            result += " diffuseColor " + SFColor(self.diffuseColor).VRML() + ""
        if self.emissiveColor != (0, 0, 0):
            result += " emissiveColor " + SFColor(self.emissiveColor).VRML() + ""
        if self.separateBackColor: # default=false
            result += " separateBackColor " + SFBool(self.separateBackColor).VRML() + ""
        if self.shininess != 0.2:
            result += " shininess " + SFFloat(self.shininess).VRML() + ""
        if self.specularColor != (0, 0, 0):
            result += " specularColor " + SFColor(self.specularColor).VRML() + ""
        if self.transparency != 0:
            result += " transparency " + SFFloat(self.transparency).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class UniversalJoint(_X3DRigidJointNode):
    """
    UniversalJoint is like a BallJoint that constrains an extra degree of rotational freedom.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'UniversalJoint'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/rigidBodyPhysics.html#UniversalJoint'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#UniversalJoint'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('anchorPoint', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'UniversalJoint'),
            ('axis1', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'UniversalJoint'),
            ('axis2', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'UniversalJoint'),
            ('forceOutput', ["NONE"], FieldType.MFString, AccessType.inputOutput, 'X3DRigidJointNode'),
            ('stop1Bounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'UniversalJoint'),
            ('stop1ErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'UniversalJoint'),
            ('stop2Bounce', 0, FieldType.SFFloat, AccessType.inputOutput, 'UniversalJoint'),
            ('stop2ErrorCorrection', 0.8, FieldType.SFFloat, AccessType.inputOutput, 'UniversalJoint'),
            ('body1', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
            ('body2', None, FieldType.SFNode, AccessType.inputOutput, 'X3DRigidJointNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 anchorPoint=(0, 0, 0),
                 axis1=(0, 0, 0),
                 axis2=(0, 0, 0),
                 forceOutput=["NONE"],
                 stop1Bounce=0,
                 stop1ErrorCorrection=0.8,
                 stop2Bounce=0,
                 stop2ErrorCorrection=0.8,
                 body1=None,
                 body2=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode UniversalJoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.anchorPoint = anchorPoint
        self.axis1 = axis1
        self.axis2 = axis2
        self.forceOutput = forceOutput
        self.stop1Bounce = stop1Bounce
        self.stop1ErrorCorrection = stop1ErrorCorrection
        self.stop2Bounce = stop2Bounce
        self.stop2ErrorCorrection = stop2ErrorCorrection
        self.body1 = body1
        self.body2 = body2
    @property # getter - - - - - - - - - -
    def anchorPoint(self):
        """anchorPoint is joint center, specified in world coordinates."""
        return self.__anchorPoint
    @anchorPoint.setter
    def anchorPoint(self, anchorPoint):
        if  anchorPoint is None:
            anchorPoint = (0, 0, 0) # default
        assertValidSFVec3f(anchorPoint)
        self.__anchorPoint = anchorPoint
    @property # getter - - - - - - - - - -
    def axis1(self):
        """axis1 defines axis vector of joint connection to body1."""
        return self.__axis1
    @axis1.setter
    def axis1(self, axis1):
        if  axis1 is None:
            axis1 = (0, 0, 0) # default
        assertValidSFVec3f(axis1)
        self.__axis1 = axis1
    @property # getter - - - - - - - - - -
    def axis2(self):
        """axis2 defines axis vector of joint connection to body2."""
        return self.__axis2
    @axis2.setter
    def axis2(self, axis2):
        if  axis2 is None:
            axis2 = (0, 0, 0) # default
        assertValidSFVec3f(axis2)
        self.__axis2 = axis2
    @property # getter - - - - - - - - - -
    def forceOutput(self):
        """forceOutput controls which output fields are generated for the next frame."""
        return self.__forceOutput
    @forceOutput.setter
    def forceOutput(self, forceOutput):
        if  forceOutput is None:
            forceOutput = ["NONE"] # default
        assertValidMFString(forceOutput)
        self.__forceOutput = forceOutput
    @property # getter - - - - - - - - - -
    def stop1Bounce(self):
        """[0,1] stop1Bounce is velocity factor for bounce back once stop point is reached."""
        return self.__stop1Bounce
    @stop1Bounce.setter
    def stop1Bounce(self, stop1Bounce):
        if  stop1Bounce is None:
            stop1Bounce = 0 # default
        assertValidSFFloat(stop1Bounce)
        assertZeroToOne('stop1Bounce', stop1Bounce)
        self.__stop1Bounce = stop1Bounce
    @property # getter - - - - - - - - - -
    def stop1ErrorCorrection(self):
        """[0,1] stop1ErrorCorrection is fraction of error correction performed during time step once stop point is reached."""
        return self.__stop1ErrorCorrection
    @stop1ErrorCorrection.setter
    def stop1ErrorCorrection(self, stop1ErrorCorrection):
        if  stop1ErrorCorrection is None:
            stop1ErrorCorrection = 0.8 # default
        assertValidSFFloat(stop1ErrorCorrection)
        assertZeroToOne('stop1ErrorCorrection', stop1ErrorCorrection)
        self.__stop1ErrorCorrection = stop1ErrorCorrection
    @property # getter - - - - - - - - - -
    def stop2Bounce(self):
        """[0,1] stop2Bounce is velocity factor for bounce back once stop point is reached."""
        return self.__stop2Bounce
    @stop2Bounce.setter
    def stop2Bounce(self, stop2Bounce):
        if  stop2Bounce is None:
            stop2Bounce = 0 # default
        assertValidSFFloat(stop2Bounce)
        assertZeroToOne('stop2Bounce', stop2Bounce)
        self.__stop2Bounce = stop2Bounce
    @property # getter - - - - - - - - - -
    def stop2ErrorCorrection(self):
        """[0,1] stop2ErrorCorrection is fraction of error correction performed during time step once stop point is reached."""
        return self.__stop2ErrorCorrection
    @stop2ErrorCorrection.setter
    def stop2ErrorCorrection(self, stop2ErrorCorrection):
        if  stop2ErrorCorrection is None:
            stop2ErrorCorrection = 0.8 # default
        assertValidSFFloat(stop2ErrorCorrection)
        assertZeroToOne('stop2ErrorCorrection', stop2ErrorCorrection)
        self.__stop2ErrorCorrection = stop2ErrorCorrection
    @property # getter - - - - - - - - - -
    def body1(self):
        return self.__body1
    @body1.setter
    def body1(self, body1):
        if  body1 is None:
            body1 = None # default
        assertValidSFNode(body1)
        if not isinstance(body1, object):
            # print(flush=True)
            raise X3DTypeError(str(body1) + ' does not have a valid node type object')
        self.__body1 = body1
    @property # getter - - - - - - - - - -
    def body2(self):
        return self.__body2
    @body2.setter
    def body2(self, body2):
        if  body2 is None:
            body2 = None # default
        assertValidSFNode(body2)
        if not isinstance(body2, object):
            # print(flush=True)
            raise X3DTypeError(str(body2) + ' does not have a valid node type object')
        self.__body2 = body2
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.body1 or self.body2 or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function UniversalJoint.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<UniversalJoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.anchorPoint != (0, 0, 0):
            result += " anchorPoint='" + SFVec3f(self.anchorPoint).XML() + "'"
        if self.axis1 != (0, 0, 0):
            result += " axis1='" + SFVec3f(self.axis1).XML() + "'"
        if self.axis2 != (0, 0, 0):
            result += " axis2='" + SFVec3f(self.axis2).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.forceOutput != ["NONE"]:
            result += " forceOutput='" + MFString(self.forceOutput).XML() + "'"
        if self.stop1Bounce != 0:
            result += " stop1Bounce='" + SFFloat(self.stop1Bounce).XML() + "'"
        if self.stop1ErrorCorrection != 0.8:
            result += " stop1ErrorCorrection='" + SFFloat(self.stop1ErrorCorrection).XML() + "'"
        if self.stop2Bounce != 0:
            result += " stop2Bounce='" + SFFloat(self.stop2Bounce).XML() + "'"
        if self.stop2ErrorCorrection != 0.8:
            result += " stop2ErrorCorrection='" + SFFloat(self.stop2ErrorCorrection).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></UniversalJoint>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.body1: # output this SFNode
                result += self.body1.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.body2: # output this SFNode
                result += self.body2.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</UniversalJoint>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function UniversalJoint.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'UniversalJoint' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'UniversalJoint' + ' {'
        if self.anchorPoint != (0, 0, 0):
            result += " anchorPoint " + SFVec3f(self.anchorPoint).VRML() + ""
        if self.axis1 != (0, 0, 0):
            result += " axis1 " + SFVec3f(self.axis1).VRML() + ""
        if self.axis2 != (0, 0, 0):
            result += " axis2 " + SFVec3f(self.axis2).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.forceOutput != ["NONE"]:
            result += " forceOutput " + MFString(self.forceOutput).VRML() + ""
        if self.stop1Bounce != 0:
            result += " stop1Bounce " + SFFloat(self.stop1Bounce).VRML() + ""
        if self.stop1ErrorCorrection != 0.8:
            result += " stop1ErrorCorrection " + SFFloat(self.stop1ErrorCorrection).VRML() + ""
        if self.stop2Bounce != 0:
            result += " stop2Bounce " + SFFloat(self.stop2Bounce).VRML() + ""
        if self.stop2ErrorCorrection != 0.8:
            result += " stop2ErrorCorrection " + SFFloat(self.stop2ErrorCorrection).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.body1: # output this SFNode
            result += '\n' + '  ' + indent + 'body1 ' + self.body1.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.body2: # output this SFNode
            result += '\n' + '  ' + indent + 'body2 ' + self.body2.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class UnlitMaterial(_X3DOneSidedMaterialNode):
    """
    UnlitMaterial specifies surface rendering properties for associated geometry nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'UnlitMaterial'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/shape.html#UnlitMaterial'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#UnlitMaterial'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('emissiveColor', (0, 0, 0), FieldType.SFColor, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
            ('emissiveTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
            ('normalScale', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
            ('normalTextureMapping', '', FieldType.SFString, AccessType.inputOutput, 'X3DOneSidedMaterialNode'),
            ('transparency', 0, FieldType.SFFloat, AccessType.inputOutput, 'UnlitMaterial'),
            ('emissiveTexture', None, FieldType.SFNode, AccessType.inputOutput, 'UnlitMaterial'),
            ('normalTexture', None, FieldType.SFNode, AccessType.inputOutput, 'UnlitMaterial'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 emissiveColor=(0, 0, 0),
                 emissiveTextureMapping='',
                 normalScale=1,
                 normalTextureMapping='',
                 transparency=0,
                 emissiveTexture=None,
                 normalTexture=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode UnlitMaterial __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.emissiveColor = emissiveColor
        self.emissiveTextureMapping = emissiveTextureMapping
        self.normalScale = normalScale
        self.normalTextureMapping = normalTextureMapping
        self.transparency = transparency
        self.emissiveTexture = emissiveTexture
        self.normalTexture = normalTexture
    @property # getter - - - - - - - - - -
    def emissiveColor(self):
        """[0,1] how much glowing light is emitted from this object."""
        return self.__emissiveColor
    @emissiveColor.setter
    def emissiveColor(self, emissiveColor):
        if  emissiveColor is None:
            emissiveColor = (0, 0, 0) # default
        assertValidSFColor(emissiveColor)
        assertZeroToOne('emissiveColor', emissiveColor)
        self.__emissiveColor = emissiveColor
    @property # getter - - - - - - - - - -
    def emissiveTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__emissiveTextureMapping
    @emissiveTextureMapping.setter
    def emissiveTextureMapping(self, emissiveTextureMapping):
        if  emissiveTextureMapping is None:
            emissiveTextureMapping = SFString.DEFAULT_VALUE(self)
        assertValidSFString(emissiveTextureMapping)
        self.__emissiveTextureMapping = emissiveTextureMapping
    @property # getter - - - - - - - - - -
    def normalScale(self):
        """[0,infinity] normalScale controls the degree to which normalTexture RGB values apply XYZ-normal bump mapping to pixels in the parent material."""
        return self.__normalScale
    @normalScale.setter
    def normalScale(self, normalScale):
        if  normalScale is None:
            normalScale = 1 # default
        assertValidSFFloat(normalScale)
        assertNonNegative('normalScale', normalScale)
        self.__normalScale = normalScale
    @property # getter - - - - - - - - - -
    def normalTextureMapping(self):
        """The mapping label identifies which texture coordinates and transformations are used to compute texture effects from corresponding geometry on a given material."""
        return self.__normalTextureMapping
    @normalTextureMapping.setter
    def normalTextureMapping(self, normalTextureMapping):
        if  normalTextureMapping is None:
            normalTextureMapping = SFString.DEFAULT_VALUE(self)
        assertValidSFString(normalTextureMapping)
        self.__normalTextureMapping = normalTextureMapping
    @property # getter - - - - - - - - - -
    def transparency(self):
        """[0,1] how "clear" an object is: 1."""
        return self.__transparency
    @transparency.setter
    def transparency(self, transparency):
        if  transparency is None:
            transparency = 0 # default
        assertValidSFFloat(transparency)
        assertZeroToOne('transparency', transparency)
        self.__transparency = transparency
    @property # getter - - - - - - - - - -
    def emissiveTexture(self):
        """[X3DSingleTextureNode] When applying emissiveColor for this material node, the contained texture provides Physically Based Rendering (PBR) modulation for each pixel."""
        return self.__emissiveTexture
    @emissiveTexture.setter
    def emissiveTexture(self, emissiveTexture):
        if  emissiveTexture is None:
            emissiveTexture = None # default
        assertValidSFNode(emissiveTexture)
        if not isinstance(emissiveTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(emissiveTexture) + ' does not have a valid node type object')
        self.__emissiveTexture = emissiveTexture
    @property # getter - - - - - - - - - -
    def normalTexture(self):
        """[X3DSingleTextureNode] When applying normalScale for this material node, the contained texture modulates the texture across the surface."""
        return self.__normalTexture
    @normalTexture.setter
    def normalTexture(self, normalTexture):
        if  normalTexture is None:
            normalTexture = None # default
        assertValidSFNode(normalTexture)
        if not isinstance(normalTexture, object):
            # print(flush=True)
            raise X3DTypeError(str(normalTexture) + ' does not have a valid node type object')
        self.__normalTexture = normalTexture
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.emissiveTexture or self.IS or self.metadata or self.normalTexture
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function UnlitMaterial.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<UnlitMaterial'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.emissiveColor != (0, 0, 0):
            result += " emissiveColor='" + SFColor(self.emissiveColor).XML() + "'"
        if self.emissiveTextureMapping:
            result += " emissiveTextureMapping='" + self.emissiveTextureMapping + "'"
        if self.normalScale != 1:
            result += " normalScale='" + SFFloat(self.normalScale).XML() + "'"
        if self.normalTextureMapping:
            result += " normalTextureMapping='" + self.normalTextureMapping + "'"
        if self.transparency != 0:
            result += " transparency='" + SFFloat(self.transparency).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></UnlitMaterial>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.emissiveTexture: # output this SFNode
                result += self.emissiveTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.normalTexture: # output this SFNode
                result += self.normalTexture.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</UnlitMaterial>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function UnlitMaterial.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'UnlitMaterial' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'UnlitMaterial' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.emissiveColor != (0, 0, 0):
            result += " emissiveColor " + SFColor(self.emissiveColor).VRML() + ""
        if self.emissiveTextureMapping:
            result += " emissiveTextureMapping " +  '"' + self.emissiveTextureMapping + '"' + ""
        if self.normalScale != 1:
            result += " normalScale " + SFFloat(self.normalScale).VRML() + ""
        if self.normalTextureMapping:
            result += " normalTextureMapping " +  '"' + self.normalTextureMapping + '"' + ""
        if self.transparency != 0:
            result += " transparency " + SFFloat(self.transparency).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.emissiveTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'emissiveTexture ' + self.emissiveTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.normalTexture: # output this SFNode
            result += '\n' + '  ' + indent + 'normalTexture ' + self.normalTexture.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Viewpoint(_X3DViewpointNode):
    """
    Viewpoint provides a specific location and direction where the user may view the scene.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Viewpoint'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/navigation.html#Viewpoint'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Viewpoint'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('centerOfRotation', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'Viewpoint'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DViewpointNode'),
            ('farDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DViewpointNode'),
            ('fieldOfView', 0.7854, FieldType.SFFloat, AccessType.inputOutput, 'Viewpoint'),
            ('jump', True, FieldType.SFBool, AccessType.inputOutput, 'X3DViewpointNode'),
            ('nearDistance', -1, FieldType.SFFloat, AccessType.inputOutput, 'X3DViewpointNode'),
            ('orientation', (0, 0, 1, 0), FieldType.SFRotation, AccessType.inputOutput, 'X3DViewpointNode'),
            ('position', (0, 0, 10), FieldType.SFVec3f, AccessType.inputOutput, 'Viewpoint'),
            ('retainUserOffsets', False, FieldType.SFBool, AccessType.inputOutput, 'X3DViewpointNode'),
            ('viewAll', False, FieldType.SFBool, AccessType.inputOutput, 'X3DViewpointNode'),
            ('navigationInfo', None, FieldType.SFNode, AccessType.inputOutput, 'X3DViewpointNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 centerOfRotation=(0, 0, 0),
                 description='',
                 farDistance=-1,
                 fieldOfView=0.7854,
                 jump=True,
                 nearDistance=-1,
                 orientation=(0, 0, 1, 0),
                 position=(0, 0, 10),
                 retainUserOffsets=False,
                 viewAll=False,
                 navigationInfo=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Viewpoint __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.centerOfRotation = centerOfRotation
        self.description = description
        self.farDistance = farDistance
        self.fieldOfView = fieldOfView
        self.jump = jump
        self.nearDistance = nearDistance
        self.orientation = orientation
        self.position = position
        self.retainUserOffsets = retainUserOffsets
        self.viewAll = viewAll
        self.navigationInfo = navigationInfo
    @property # getter - - - - - - - - - -
    def centerOfRotation(self):
        """centerOfRotation specifies center point about which to rotate user's eyepoint when in EXAMINE or LOOKAT mode."""
        return self.__centerOfRotation
    @centerOfRotation.setter
    def centerOfRotation(self, centerOfRotation):
        if  centerOfRotation is None:
            centerOfRotation = (0, 0, 0) # default
        assertValidSFVec3f(centerOfRotation)
        self.__centerOfRotation = centerOfRotation
    @property # getter - - - - - - - - - -
    def description(self):
        """Text description or navigation hint to describe the significance of this model Viewpoint."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def farDistance(self):
        """or (0,+infinity) farDistance defines maximum clipping plane distance allowed for object display."""
        return self.__farDistance
    @farDistance.setter
    def farDistance(self, farDistance):
        if  farDistance is None:
            farDistance = -1 # default
        assertValidSFFloat(farDistance)
        self.__farDistance = farDistance
    @property # getter - - - - - - - - - -
    def fieldOfView(self):
        """Preferred minimum viewing angle from this viewpoint in radians, providing minimum height or minimum width (whichever is smaller)."""
        return self.__fieldOfView
    @fieldOfView.setter
    def fieldOfView(self, fieldOfView):
        if  fieldOfView is None:
            fieldOfView = 0.7854 # default
        assertValidSFFloat(fieldOfView)
        assertGreaterThan('fieldOfView', fieldOfView, 0)
        assertLessThan('fieldOfView', fieldOfView, 3.1416)
        self.__fieldOfView = fieldOfView
    @property # getter - - - - - - - - - -
    def jump(self):
        """Transition instantly by jumping, otherwise smoothly adjust offsets in place when changing to this Viewpoint."""
        return self.__jump
    @jump.setter
    def jump(self, jump):
        if  jump is None:
            jump = True # default
        assertValidSFBool(jump)
        self.__jump = jump
    @property # getter - - - - - - - - - -
    def nearDistance(self):
        """or (0,+infinity) nearDistance defines minimum clipping plane distance necessary for object display."""
        return self.__nearDistance
    @nearDistance.setter
    def nearDistance(self, nearDistance):
        if  nearDistance is None:
            nearDistance = -1 # default
        assertValidSFFloat(nearDistance)
        self.__nearDistance = nearDistance
    @property # getter - - - - - - - - - -
    def orientation(self):
        """Rotation (axis, angle in radians) of Viewpoint, relative to default -Z axis direction in local coordinate system."""
        return self.__orientation
    @orientation.setter
    def orientation(self, orientation):
        if  orientation is None:
            orientation = (0, 0, 1, 0) # default
        assertValidSFRotation(orientation)
        self.__orientation = orientation
    @property # getter - - - - - - - - - -
    def position(self):
        """position (x, y, z in meters) relative to local coordinate system."""
        return self.__position
    @position.setter
    def position(self, position):
        if  position is None:
            position = (0, 0, 10) # default
        assertValidSFVec3f(position)
        self.__position = position
    @property # getter - - - - - - - - - -
    def retainUserOffsets(self):
        """Retain (true) or reset to zero (false) any prior user navigation offsets from defined viewpoint position, orientation."""
        return self.__retainUserOffsets
    @retainUserOffsets.setter
    def retainUserOffsets(self, retainUserOffsets):
        if  retainUserOffsets is None:
            retainUserOffsets = False # default
        assertValidSFBool(retainUserOffsets)
        self.__retainUserOffsets = retainUserOffsets
    @property # getter - - - - - - - - - -
    def viewAll(self):
        return self.__viewAll
    @viewAll.setter
    def viewAll(self, viewAll):
        if  viewAll is None:
            viewAll = False # default
        assertValidSFBool(viewAll)
        self.__viewAll = viewAll
    @property # getter - - - - - - - - - -
    def navigationInfo(self):
        return self.__navigationInfo
    @navigationInfo.setter
    def navigationInfo(self, navigationInfo):
        if  navigationInfo is None:
            navigationInfo = None # default
        assertValidSFNode(navigationInfo)
        if not isinstance(navigationInfo, object):
            # print(flush=True)
            raise X3DTypeError(str(navigationInfo) + ' does not have a valid node type object')
        self.__navigationInfo = navigationInfo
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.navigationInfo
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Viewpoint.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Viewpoint'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.centerOfRotation != (0, 0, 0):
            result += " centerOfRotation='" + SFVec3f(self.centerOfRotation).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if self.farDistance != -1:
            result += " farDistance='" + SFFloat(self.farDistance).XML() + "'"
        if self.fieldOfView != 0.7854:
            result += " fieldOfView='" + SFFloat(self.fieldOfView).XML() + "'"
        if not self.jump: # default=true
            result += " jump='" + SFBool(self.jump).XML() + "'"
        if self.nearDistance != -1:
            result += " nearDistance='" + SFFloat(self.nearDistance).XML() + "'"
        if self.orientation != (0, 0, 1, 0):
            result += " orientation='" + SFRotation(self.orientation).XML() + "'"
        if self.position != (0, 0, 10):
            result += " position='" + SFVec3f(self.position).XML() + "'"
        if self.retainUserOffsets: # default=false
            result += " retainUserOffsets='" + SFBool(self.retainUserOffsets).XML() + "'"
        if self.viewAll: # default=false
            result += " viewAll='" + SFBool(self.viewAll).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Viewpoint>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.navigationInfo: # output this SFNode
                result += self.navigationInfo.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Viewpoint>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Viewpoint.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Viewpoint' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Viewpoint' + ' {'
        if self.centerOfRotation != (0, 0, 0):
            result += " centerOfRotation " + SFVec3f(self.centerOfRotation).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if self.farDistance != -1:
            result += " farDistance " + SFFloat(self.farDistance).VRML() + ""
        if self.fieldOfView != 0.7854:
            result += " fieldOfView " + SFFloat(self.fieldOfView).VRML() + ""
        if not self.jump: # default=true
            result += " jump " + SFBool(self.jump).VRML() + ""
        if self.nearDistance != -1:
            result += " nearDistance " + SFFloat(self.nearDistance).VRML() + ""
        if self.orientation != (0, 0, 1, 0):
            result += " orientation " + SFRotation(self.orientation).VRML() + ""
        if self.position != (0, 0, 10):
            result += " position " + SFVec3f(self.position).VRML() + ""
        if self.retainUserOffsets: # default=false
            result += " retainUserOffsets " + SFBool(self.retainUserOffsets).VRML() + ""
        if self.viewAll: # default=false
            result += " viewAll " + SFBool(self.viewAll).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.navigationInfo: # output this SFNode
            result += '\n' + '  ' + indent + 'navigationInfo ' + self.navigationInfo.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class ViewpointGroup(_X3DChildNode):
    """
    ViewpointGroup can contain Viewpoint, OrthoViewpoint, GeoViewpoint and other ViewpointGroup nodes for better user-navigation support with a shared description on the viewpoint list.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'ViewpointGroup'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/navigation.html#ViewpointGroup'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#ViewpointGroup'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'ViewpointGroup'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'ViewpointGroup'),
            ('displayed', True, FieldType.SFBool, AccessType.inputOutput, 'ViewpointGroup'),
            ('retainUserOffsets', False, FieldType.SFBool, AccessType.inputOutput, 'ViewpointGroup'),
            ('size', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'ViewpointGroup'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'ViewpointGroup'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 center=(0, 0, 0),
                 description='',
                 displayed=True,
                 retainUserOffsets=False,
                 size=(0, 0, 0),
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode ViewpointGroup __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.description = description
        self.displayed = displayed
        self.retainUserOffsets = retainUserOffsets
        self.size = size
        self.children = children
    @property # getter - - - - - - - - - -
    def center(self):
        """center specifies center point of proximity box within which ViewpointGroup is usable and displayed on viewpoint list."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0) # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def description(self):
        """Text description or navigation hint to identify this ViewpointGroup."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def displayed(self):
        """displayed determines whether this ViewpointGroup is displayed in the current viewpoint list."""
        return self.__displayed
    @displayed.setter
    def displayed(self, displayed):
        if  displayed is None:
            displayed = True # default
        assertValidSFBool(displayed)
        self.__displayed = displayed
    @property # getter - - - - - - - - - -
    def retainUserOffsets(self):
        """Retain (true) or reset to zero (false) any prior user navigation offsets from defined viewpoint position, orientation."""
        return self.__retainUserOffsets
    @retainUserOffsets.setter
    def retainUserOffsets(self, retainUserOffsets):
        if  retainUserOffsets is None:
            retainUserOffsets = False # default
        assertValidSFBool(retainUserOffsets)
        self.__retainUserOffsets = retainUserOffsets
    @property # getter - - - - - - - - - -
    def size(self):
        """[0,+infinity) Size of proximity box around center location within which ViewpointGroup is usable and displayed on viewpoint list."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = (0, 0, 0) # default
        assertValidSFVec3f(size)
        self.__size = size
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] ViewpointGroup contains Viewpoint, OrthoViewpoint, GeoViewpoint and other ViewpointGroup nodes that each have containerField='children' default value."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function ViewpointGroup.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<ViewpointGroup'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.center != (0, 0, 0):
            result += " center='" + SFVec3f(self.center).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.displayed: # default=true
            result += " displayed='" + SFBool(self.displayed).XML() + "'"
        if self.retainUserOffsets: # default=false
            result += " retainUserOffsets='" + SFBool(self.retainUserOffsets).XML() + "'"
        if self.size != (0, 0, 0):
            result += " size='" + SFVec3f(self.size).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></ViewpointGroup>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* ViewpointGroup found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</ViewpointGroup>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function ViewpointGroup.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'ViewpointGroup' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'ViewpointGroup' + ' {'
        if self.center != (0, 0, 0):
            result += " center " + SFVec3f(self.center).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.displayed: # default=true
            result += " displayed " + SFBool(self.displayed).VRML() + ""
        if self.retainUserOffsets: # default=false
            result += " retainUserOffsets " + SFBool(self.retainUserOffsets).VRML() + ""
        if self.size != (0, 0, 0):
            result += " size " + SFVec3f(self.size).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class Viewport(_X3DViewportNode):
    """
    Viewport is a Grouping node that can contain most nodes.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'Viewport'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/layering.html#Viewport'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#Viewport'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DGroupingNode'),
            ('clipBoundary', [0, 1, 0, 1], FieldType.MFFloat, AccessType.inputOutput, 'Viewport'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DGroupingNode'),
            ('children', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DGroupingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 clipBoundary=[0, 1, 0, 1],
                 visible=True,
                 children=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode Viewport __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.clipBoundary = clipBoundary
        self.visible = visible
        self.children = children
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def clipBoundary(self):
        """[0,1] clipBoundary is specified in fractions of the normal render surface in the sequence left/right/bottom/top."""
        return self.__clipBoundary
    @clipBoundary.setter
    def clipBoundary(self, clipBoundary):
        if  clipBoundary is None:
            clipBoundary = [0, 1, 0, 1] # default
        assertValidMFFloat(clipBoundary)
        assertZeroToOne('clipBoundary', clipBoundary)
        self.__clipBoundary = clipBoundary
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def children(self):
        """[X3DChildNode] Grouping nodes contain an ordered list of children nodes."""
        return self.__children
    @children.setter
    def children(self, children):
        if  children is None:
            children = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(children)
        self.__children = children
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.children or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function Viewport.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<Viewport'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.clipBoundary != [0, 1, 0, 1]:
            result += " clipBoundary='" + MFFloat(self.clipBoundary).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></Viewport>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.children: # walk each child in MFNode list, if any
            ### print('* Viewport found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(children)=' + str(len(self.children)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.children:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</Viewport>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function Viewport.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'Viewport' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'Viewport' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.clipBoundary != [0, 1, 0, 1]:
            result += " clipBoundary " + MFFloat(self.clipBoundary).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.children: # walk each child in MFNode list, if any
            for each in self.children:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class VisibilitySensor(_X3DEnvironmentalSensorNode):
    """
    VisibilitySensor detects when user can see a specific object or region as they navigate the world.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'VisibilitySensor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/environmentalSensor.html#VisibilitySensor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#VisibilitySensor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('center', (0, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'VisibilitySensor'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('size', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DEnvironmentalSensorNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 center=(0, 0, 0),
                 enabled=True,
                 size=(0, 0, 0),
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode VisibilitySensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.center = center
        self.enabled = enabled
        self.size = size
    @property # getter - - - - - - - - - -
    def center(self):
        """Translation offset from origin of local coordinate system."""
        return self.__center
    @center.setter
    def center(self, center):
        if  center is None:
            center = (0, 0, 0) # default
        assertValidSFVec3f(center)
        self.__center = center
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def size(self):
        """[0,+infinity) size of visibility box, measured from center in meters."""
        return self.__size
    @size.setter
    def size(self, size):
        if  size is None:
            size = (0, 0, 0) # default
        assertValidSFVec3f(size)
        assertNonNegative('size', size)
        self.__size = size
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function VisibilitySensor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<VisibilitySensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.center != (0, 0, 0):
            result += " center='" + SFVec3f(self.center).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.size != (0, 0, 0):
            result += " size='" + SFVec3f(self.size).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></VisibilitySensor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</VisibilitySensor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function VisibilitySensor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'VisibilitySensor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'VisibilitySensor' + ' {'
        if self.center != (0, 0, 0):
            result += " center " + SFVec3f(self.center).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.size != (0, 0, 0):
            result += " size " + SFVec3f(self.size).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class VolumeData(_X3DVolumeDataNode):
    """
    VolumeData displays a simple non-segmented voxel dataset with a single RenderStyle node.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'VolumeData'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/volume.html#VolumeData'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#VolumeData'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('bboxCenter', (0, 0, 0), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DVolumeDataNode'),
            ('bboxDisplay', False, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeDataNode'),
            ('bboxSize', (-1, -1, -1), FieldType.SFVec3f, AccessType.initializeOnly, 'X3DVolumeDataNode'),
            ('dimensions', (1, 1, 1), FieldType.SFVec3f, AccessType.inputOutput, 'X3DVolumeDataNode'),
            ('visible', True, FieldType.SFBool, AccessType.inputOutput, 'X3DVolumeDataNode'),
            ('renderStyle', None, FieldType.SFNode, AccessType.inputOutput, 'VolumeData'),
            ('voxels', None, FieldType.SFNode, AccessType.inputOutput, 'VolumeData'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 bboxCenter=(0, 0, 0),
                 bboxDisplay=False,
                 bboxSize=(-1, -1, -1),
                 dimensions=(1, 1, 1),
                 visible=True,
                 renderStyle=None,
                 voxels=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode VolumeData __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.bboxCenter = bboxCenter
        self.bboxDisplay = bboxDisplay
        self.bboxSize = bboxSize
        self.dimensions = dimensions
        self.visible = visible
        self.renderStyle = renderStyle
        self.voxels = voxels
    @property # getter - - - - - - - - - -
    def bboxCenter(self):
        """Bounding box center accompanies bboxSize and provides an optional hint for bounding box position offset from origin of local coordinate system."""
        return self.__bboxCenter
    @bboxCenter.setter
    def bboxCenter(self, bboxCenter):
        if  bboxCenter is None:
            bboxCenter = (0, 0, 0) # default
        assertValidSFVec3f(bboxCenter)
        self.__bboxCenter = bboxCenter
    @property # getter - - - - - - - - - -
    def bboxDisplay(self):
        """Whether to display bounding box for associated geometry, aligned with world coordinates."""
        return self.__bboxDisplay
    @bboxDisplay.setter
    def bboxDisplay(self, bboxDisplay):
        if  bboxDisplay is None:
            bboxDisplay = False # default
        assertValidSFBool(bboxDisplay)
        self.__bboxDisplay = bboxDisplay
    @property # getter - - - - - - - - - -
    def bboxSize(self):
        """or [0,+infinity) Bounding box size is usually omitted, and can easily be calculated automatically by an X3D player at scene-loading time with minimal computational cost."""
        return self.__bboxSize
    @bboxSize.setter
    def bboxSize(self, bboxSize):
        if  bboxSize is None:
            bboxSize = (-1, -1, -1) # default
        assertValidSFVec3f(bboxSize)
        assertBoundingBox('bboxSize', bboxSize)
        self.__bboxSize = bboxSize
    @property # getter - - - - - - - - - -
    def dimensions(self):
        """Actual-size X-Y-Z dimensions of volume data in local coordinate system."""
        return self.__dimensions
    @dimensions.setter
    def dimensions(self, dimensions):
        if  dimensions is None:
            dimensions = (1, 1, 1) # default
        assertValidSFVec3f(dimensions)
        assertPositive('dimensions', dimensions)
        self.__dimensions = dimensions
    @property # getter - - - - - - - - - -
    def visible(self):
        """Whether or not renderable content within this node is visually displayed."""
        return self.__visible
    @visible.setter
    def visible(self, visible):
        if  visible is None:
            visible = True # default
        assertValidSFBool(visible)
        self.__visible = visible
    @property # getter - - - - - - - - - -
    def renderStyle(self):
        """[X3DVolumeRenderStyleNode] Single contained X3DVolumeRenderStyleNode node that defines specific rendering technique for this volumetric object."""
        return self.__renderStyle
    @renderStyle.setter
    def renderStyle(self, renderStyle):
        if  renderStyle is None:
            renderStyle = None # default
        assertValidSFNode(renderStyle)
        if not isinstance(renderStyle, object):
            # print(flush=True)
            raise X3DTypeError(str(renderStyle) + ' does not have a valid node type object')
        self.__renderStyle = renderStyle
    @property # getter - - - - - - - - - -
    def voxels(self):
        """[X3DTexture3DNode] Single contained X3DTexture3DNode (ComposedTexture3D, ImageTexture3D, PixelTexture3D) that provides raw voxel information utilized by corresponding rendering styles."""
        return self.__voxels
    @voxels.setter
    def voxels(self, voxels):
        if  voxels is None:
            voxels = None # default
        assertValidSFNode(voxels)
        if not isinstance(voxels, object):
            # print(flush=True)
            raise X3DTypeError(str(voxels) + ' does not have a valid node type object')
        self.__voxels = voxels
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata or self.renderStyle or self.voxels
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function VolumeData.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<VolumeData'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter='" + SFVec3f(self.bboxCenter).XML() + "'"
        if self.bboxDisplay: # default=false
            result += " bboxDisplay='" + SFBool(self.bboxDisplay).XML() + "'"
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize='" + SFVec3f(self.bboxSize).XML() + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.dimensions != (1, 1, 1):
            result += " dimensions='" + SFVec3f(self.dimensions).XML() + "'"
        if not self.visible: # default=true
            result += " visible='" + SFBool(self.visible).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></VolumeData>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.renderStyle: # output this SFNode
                result += self.renderStyle.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.voxels: # output this SFNode
                result += self.voxels.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</VolumeData>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function VolumeData.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'VolumeData' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'VolumeData' + ' {'
        if self.bboxCenter != (0, 0, 0):
            result += " bboxCenter " + SFVec3f(self.bboxCenter).VRML() + ""
        if self.bboxDisplay: # default=false
            result += " bboxDisplay " + SFBool(self.bboxDisplay).VRML() + ""
        if self.bboxSize != (-1, -1, -1):
            result += " bboxSize " + SFVec3f(self.bboxSize).VRML() + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.dimensions != (1, 1, 1):
            result += " dimensions " + SFVec3f(self.dimensions).VRML() + ""
        if not self.visible: # default=true
            result += " visible " + SFBool(self.visible).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.renderStyle: # output this SFNode
            result += '\n' + '  ' + indent + 'renderStyle ' + self.renderStyle.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.voxels: # output this SFNode
            result += '\n' + '  ' + indent + 'voxels ' + self.voxels.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class VolumeEmitter(_X3DParticleEmitterNode):
    """
    VolumeEmitter emits particles from a random position confined within the given closed geometry volume.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'VolumeEmitter'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/particleSystems.html#VolumeEmitter'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#VolumeEmitter'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('coordIndex', [-1], FieldType.MFInt32, AccessType.initializeOnly, 'VolumeEmitter'),
            ('direction', (0, 1, 0), FieldType.SFVec3f, AccessType.inputOutput, 'VolumeEmitter'),
            ('internal', True, FieldType.SFBool, AccessType.initializeOnly, 'VolumeEmitter'),
            ('mass', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('speed', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('surfaceArea', 0, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('variation', 0.25, FieldType.SFFloat, AccessType.inputOutput, 'X3DParticleEmitterNode'),
            ('coord', None, FieldType.SFNode, AccessType.inputOutput, 'VolumeEmitter'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 coordIndex=[-1],
                 direction=(0, 1, 0),
                 internal=True,
                 mass=0,
                 speed=0,
                 surfaceArea=0,
                 variation=0.25,
                 coord=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode VolumeEmitter __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.coordIndex = coordIndex
        self.direction = direction
        self.internal = internal
        self.mass = mass
        self.speed = speed
        self.surfaceArea = surfaceArea
        self.variation = variation
        self.coord = coord
    @property # getter - - - - - - - - - -
    def coordIndex(self):
        """[-1,+infinity) coordIndex indices are applied to contained Coordinate values in order to define randomly generated initial geometry of the particles."""
        return self.__coordIndex
    @coordIndex.setter
    def coordIndex(self, coordIndex):
        if  coordIndex is None:
            coordIndex = [-1] # default
        assertValidMFInt32(coordIndex)
        assertGreaterThanEquals('coordIndex', coordIndex, -1)
        self.__coordIndex = coordIndex
    @property # getter - - - - - - - - - -
    def direction(self):
        """Initial direction from which particles emanate."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (0, 1, 0) # default
        assertValidSFVec3f(direction)
        assertGreaterThanEquals('direction', direction, -1)
        assertLessThanEquals('direction', direction, 1)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def internal(self):
        """TODO, X3D specification is undefined."""
        return self.__internal
    @internal.setter
    def internal(self, internal):
        if  internal is None:
            internal = True # default
        assertValidSFBool(internal)
        self.__internal = internal
    @property # getter - - - - - - - - - -
    def mass(self):
        """[0,+infinity) Basic mass of each particle, defined in mass base units (default is kilograms)."""
        return self.__mass
    @mass.setter
    def mass(self, mass):
        if  mass is None:
            mass = 0 # default
        assertValidSFFloat(mass)
        assertNonNegative('mass', mass)
        self.__mass = mass
    @property # getter - - - - - - - - - -
    def speed(self):
        """[0,+infinity) Initial linear speed (default is m/s) imparted to all particles along their direction of movement."""
        return self.__speed
    @speed.setter
    def speed(self, speed):
        if  speed is None:
            speed = 0 # default
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def surfaceArea(self):
        """[0,+infinity) Particle surface area in area base units (default is meters squared)."""
        return self.__surfaceArea
    @surfaceArea.setter
    def surfaceArea(self, surfaceArea):
        if  surfaceArea is None:
            surfaceArea = 0 # default
        assertValidSFFloat(surfaceArea)
        assertNonNegative('surfaceArea', surfaceArea)
        self.__surfaceArea = surfaceArea
    @property # getter - - - - - - - - - -
    def variation(self):
        """[0,+infinity) Multiplier for the randomness used to control the range of possible output values."""
        return self.__variation
    @variation.setter
    def variation(self, variation):
        if  variation is None:
            variation = 0.25 # default
        assertValidSFFloat(variation)
        assertNonNegative('variation', variation)
        self.__variation = variation
    @property # getter - - - - - - - - - -
    def coord(self):
        """[X3DCoordinateNode] Coordinates for the geometry used as the emitting volume."""
        return self.__coord
    @coord.setter
    def coord(self, coord):
        if  coord is None:
            coord = None # default
        assertValidSFNode(coord)
        if not isinstance(coord, object):
            # print(flush=True)
            raise X3DTypeError(str(coord) + ' does not have a valid node type object')
        self.__coord = coord
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.coord or self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function VolumeEmitter.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<VolumeEmitter'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.coordIndex != [-1]:
            result += " coordIndex='" + MFInt32(self.coordIndex).XML() + "'"
        if self.direction != (0, 1, 0):
            result += " direction='" + SFVec3f(self.direction).XML() + "'"
        if not self.internal: # default=true
            result += " internal='" + SFBool(self.internal).XML() + "'"
        if self.mass != 0:
            result += " mass='" + SFFloat(self.mass).XML() + "'"
        if self.speed != 0:
            result += " speed='" + SFFloat(self.speed).XML() + "'"
        if self.surfaceArea != 0:
            result += " surfaceArea='" + SFFloat(self.surfaceArea).XML() + "'"
        if self.variation != 0.25:
            result += " variation='" + SFFloat(self.variation).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></VolumeEmitter>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.coord: # output this SFNode
                result += self.coord.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</VolumeEmitter>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function VolumeEmitter.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'VolumeEmitter' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'VolumeEmitter' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.coordIndex != [-1]:
            result += " coordIndex " + MFInt32(self.coordIndex).VRML() + ""
        if self.direction != (0, 1, 0):
            result += " direction " + SFVec3f(self.direction).VRML() + ""
        if not self.internal: # default=true
            result += " internal " + SFBool(self.internal).VRML() + ""
        if self.mass != 0:
            result += " mass " + SFFloat(self.mass).VRML() + ""
        if self.speed != 0:
            result += " speed " + SFFloat(self.speed).VRML() + ""
        if self.surfaceArea != 0:
            result += " surfaceArea " + SFFloat(self.surfaceArea).VRML() + ""
        if self.variation != 0.25:
            result += " variation " + SFFloat(self.variation).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.coord: # output this SFNode
            result += '\n' + '  ' + indent + 'coord ' + self.coord.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class VolumePickSensor(_X3DPickSensorNode):
    """
    VolumePickSensor tests picking intersections using the pickingGeometry against the pickTarget geometry volume.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'VolumePickSensor'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/picking.html#VolumePickSensor'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#VolumePickSensor'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSensorNode'),
            ('intersectionType', 'BOUNDS', FieldType.SFString, AccessType.initializeOnly, 'X3DPickSensorNode'),
            ('matchCriterion', 'MATCH_ANY', FieldType.SFString, AccessType.inputOutput, 'X3DPickSensorNode'),
            ('objectType', ["ALL"], FieldType.MFString, AccessType.inputOutput, 'X3DPickSensorNode'),
            ('sortOrder', 'CLOSEST', FieldType.SFString, AccessType.initializeOnly, 'X3DPickSensorNode'),
            ('pickingGeometry', None, FieldType.SFNode, AccessType.inputOutput, 'X3DPickSensorNode'),
            ('pickTarget', list(), FieldType.MFNode, AccessType.inputOutput, 'X3DPickSensorNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 enabled=True,
                 intersectionType='BOUNDS',
                 matchCriterion='MATCH_ANY',
                 objectType=["ALL"],
                 sortOrder='CLOSEST',
                 pickingGeometry=None,
                 pickTarget=None,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode VolumePickSensor __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.enabled = enabled
        self.intersectionType = intersectionType
        self.matchCriterion = matchCriterion
        self.objectType = objectType
        self.sortOrder = sortOrder
        self.pickingGeometry = pickingGeometry
        self.pickTarget = pickTarget
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def intersectionType(self):
        """intersectionType specifies precision of the collision computation."""
        return self.__intersectionType
    @intersectionType.setter
    def intersectionType(self, intersectionType):
        if  intersectionType is None:
            intersectionType = 'BOUNDS' # default
        assertValidSFString(intersectionType)
        self.__intersectionType = intersectionType
    @property # getter - - - - - - - - - -
    def matchCriterion(self):
        """defines whether the intersection test (i."""
        return self.__matchCriterion
    @matchCriterion.setter
    def matchCriterion(self, matchCriterion):
        if  matchCriterion is None:
            matchCriterion = 'MATCH_ANY' # default
        assertValidSFString(matchCriterion)
        assertValidPickSensorMatchCriterion('matchCriterion', matchCriterion)
        self.__matchCriterion = matchCriterion
    @property # getter - - - - - - - - - -
    def objectType(self):
        """The objectType field specifies a set of labels used in the picking process."""
        return self.__objectType
    @objectType.setter
    def objectType(self, objectType):
        if  objectType is None:
            objectType = ["ALL"] # default
        assertValidMFString(objectType)
        self.__objectType = objectType
    @property # getter - - - - - - - - - -
    def sortOrder(self):
        """The sortOrder field determines the order provided for picked output events."""
        return self.__sortOrder
    @sortOrder.setter
    def sortOrder(self, sortOrder):
        if  sortOrder is None:
            sortOrder = 'CLOSEST' # default
        assertValidSFString(sortOrder)
        self.__sortOrder = sortOrder
    @property # getter - - - - - - - - - -
    def pickingGeometry(self):
        """[X3DGeometryNode] pickingGeometry specifies the exact geometry coordinates that are used to perform the intersection testing of the picking operation."""
        return self.__pickingGeometry
    @pickingGeometry.setter
    def pickingGeometry(self, pickingGeometry):
        if  pickingGeometry is None:
            pickingGeometry = None # default
        assertValidSFNode(pickingGeometry)
        if not isinstance(pickingGeometry, object):
            # print(flush=True)
            raise X3DTypeError(str(pickingGeometry) + ' does not have a valid node type object')
        self.__pickingGeometry = pickingGeometry
    @property # getter - - - - - - - - - -
    def pickTarget(self):
        """[X3DGroupingNode|X3DShapeNode|Inline] pickTarget specifies the list of nodes against which picking operations are performed."""
        return self.__pickTarget
    @pickTarget.setter
    def pickTarget(self, pickTarget):
        if  pickTarget is None:
            pickTarget = MFNode.DEFAULT_VALUE(self)
        assertValidMFNode(pickTarget)
        self.__pickTarget = pickTarget
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.pickTarget or self.IS or self.metadata or self.pickingGeometry
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function VolumePickSensor.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<VolumePickSensor'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.intersectionType != 'BOUNDS':
            result += " intersectionType='" + self.intersectionType + "'"
        if self.matchCriterion != 'MATCH_ANY':
            result += " matchCriterion='" + self.matchCriterion + "'"
        if self.objectType != ["ALL"]:
            result += " objectType='" + MFString(self.objectType).XML() + "'"
        if self.sortOrder != 'CLOSEST':
            result += " sortOrder='" + self.sortOrder + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></VolumePickSensor>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.pickingGeometry: # output this SFNode
                result += self.pickingGeometry.XML(indentLevel=indentLevel+1, syntax=syntax)
            ### if self.pickTarget: # walk each child in MFNode list, if any
            ### print('* VolumePickSensor found self.children with self.hasChild()=' + str(self.hasChild()) + ' and len(pickTarget)=' + str(len(self.pickTarget)) + ', now invoking XML(' + str(indentLevel+1) + ')', flush=True)
            for each in self.pickTarget:
                result += each.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</VolumePickSensor>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function VolumePickSensor.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'VolumePickSensor' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'VolumePickSensor' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.intersectionType != 'BOUNDS':
            result += " intersectionType " +  '"' + self.intersectionType + '"' + ""
        if self.matchCriterion != 'MATCH_ANY':
            result += " matchCriterion " +  '"' + self.matchCriterion + '"' + ""
        if self.objectType != ["ALL"]:
            result += " objectType " + MFString(self.objectType).VRML() + ""
        if self.sortOrder != 'CLOSEST':
            result += " sortOrder " +  '"' + self.sortOrder + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.pickingGeometry: # output this SFNode
            result += '\n' + '  ' + indent + 'pickingGeometry ' + self.pickingGeometry.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.pickTarget: # walk each child in MFNode list, if any
            for each in self.pickTarget:
                result += each.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class WaveShaper(_X3DSoundProcessingNode):
    """
    WaveShaper node represents a nonlinear distorter that applies a wave-shaping distortion curve to the signal.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'WaveShaper'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/sound.html#WaveShaper'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#WaveShaper'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('channelCountMode', 'max', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('channelInterpretation', 'speakers', FieldType.SFString, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('description', '', FieldType.SFString, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('gain', 1, FieldType.SFFloat, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('oversample', 'none', FieldType.SFString, AccessType.inputOutput, 'WaveShaper'),
            ('pauseTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('resumeTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('startTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('stopTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DTimeDependentNode'),
            ('tailTime', 0, FieldType.SFTime, AccessType.inputOutput, 'X3DSoundProcessingNode'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 channelCountMode='max',
                 channelInterpretation='speakers',
                 description='',
                 enabled=True,
                 gain=1,
                 oversample='none',
                 pauseTime=0,
                 resumeTime=0,
                 startTime=0,
                 stopTime=0,
                 tailTime=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode WaveShaper __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.channelCountMode = channelCountMode
        self.channelInterpretation = channelInterpretation
        self.description = description
        self.enabled = enabled
        self.gain = gain
        self.oversample = oversample
        self.pauseTime = pauseTime
        self.resumeTime = resumeTime
        self.startTime = startTime
        self.stopTime = stopTime
        self.tailTime = tailTime
    @property # getter - - - - - - - - - -
    def channelCountMode(self):
        """channelCountMode determines how individual channels are counted when up-mixing and down-mixing connections to any inputs."""
        return self.__channelCountMode
    @channelCountMode.setter
    def channelCountMode(self, channelCountMode):
        if  channelCountMode is None:
            channelCountMode = 'max' # default
        assertValidSFString(channelCountMode)
        assertValidChannelCountMode('channelCountMode', channelCountMode)
        self.__channelCountMode = channelCountMode
    @property # getter - - - - - - - - - -
    def channelInterpretation(self):
        """channelInterpretation determines how individual channels are treated when up-mixing and down-mixing connections to any inputs."""
        return self.__channelInterpretation
    @channelInterpretation.setter
    def channelInterpretation(self, channelInterpretation):
        if  channelInterpretation is None:
            channelInterpretation = 'speakers' # default
        assertValidSFString(channelInterpretation)
        assertValidChannelInterpretation('channelInterpretation', channelInterpretation)
        self.__channelInterpretation = channelInterpretation
    @property # getter - - - - - - - - - -
    def description(self):
        """Author-provided prose that describes intended purpose of the url asset."""
        return self.__description
    @description.setter
    def description(self, description):
        if  description is None:
            description = SFString.DEFAULT_VALUE(self)
        assertValidSFString(description)
        self.__description = description
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gain(self):
        """(-infinity,+infinity) The gain field is a factor that represents the amount of linear amplification to apply to the output of the node."""
        return self.__gain
    @gain.setter
    def gain(self, gain):
        if  gain is None:
            gain = 1 # default
        assertValidSFFloat(gain)
        self.__gain = gain
    @property # getter - - - - - - - - - -
    def oversample(self):
        """The oversample field is specifies what type of oversampling (if any) should be used when applying the shaping curve."""
        return self.__oversample
    @oversample.setter
    def oversample(self, oversample):
        if  oversample is None:
            oversample = 'none' # default
        assertValidSFString(oversample)
        assertValidWaveShaperOversample('oversample', oversample)
        self.__oversample = oversample
    @property # getter - - - - - - - - - -
    def pauseTime(self):
        """When time now >= pauseTime, isPaused becomes true and AudioClip becomes paused."""
        return self.__pauseTime
    @pauseTime.setter
    def pauseTime(self, pauseTime):
        if  pauseTime is None:
            pauseTime = 0 # default
        assertValidSFTime(pauseTime)
        self.__pauseTime = pauseTime
    @property # getter - - - - - - - - - -
    def resumeTime(self):
        """When resumeTime becomes <= time now, isPaused becomes false and AudioClip becomes active."""
        return self.__resumeTime
    @resumeTime.setter
    def resumeTime(self, resumeTime):
        if  resumeTime is None:
            resumeTime = 0 # default
        assertValidSFTime(resumeTime)
        self.__resumeTime = resumeTime
    @property # getter - - - - - - - - - -
    def startTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__startTime
    @startTime.setter
    def startTime(self, startTime):
        if  startTime is None:
            startTime = 0 # default
        assertValidSFTime(startTime)
        self.__startTime = startTime
    @property # getter - - - - - - - - - -
    def stopTime(self):
        """Absolute time: number of seconds since January 1, 1970, 00:00:00 GMT."""
        return self.__stopTime
    @stopTime.setter
    def stopTime(self, stopTime):
        if  stopTime is None:
            stopTime = 0 # default
        assertValidSFTime(stopTime)
        self.__stopTime = stopTime
    @property # getter - - - - - - - - - -
    def tailTime(self):
        """[0,+infinity) tailTime is duration of time that a node continues to provide output signal after the input signal becomes silent."""
        return self.__tailTime
    @tailTime.setter
    def tailTime(self, tailTime):
        if  tailTime is None:
            tailTime = 0 # default
        assertValidSFTime(tailTime)
        assertNonNegative('tailTime', tailTime)
        self.__tailTime = tailTime
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function WaveShaper.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<WaveShaper'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.channelCountMode != 'max':
            result += " channelCountMode='" + self.channelCountMode + "'"
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation='" + self.channelInterpretation + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.description:
            result += " description='" + self.description + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.gain != 1:
            result += " gain='" + SFFloat(self.gain).XML() + "'"
        if self.oversample != 'none':
            result += " oversample='" + self.oversample + "'"
        if self.pauseTime != 0:
            result += " pauseTime='" + SFTime(self.pauseTime).XML() + "'"
        if self.resumeTime != 0:
            result += " resumeTime='" + SFTime(self.resumeTime).XML() + "'"
        if self.startTime != 0:
            result += " startTime='" + SFTime(self.startTime).XML() + "'"
        if self.stopTime != 0:
            result += " stopTime='" + SFTime(self.stopTime).XML() + "'"
        if self.tailTime != 0:
            result += " tailTime='" + SFTime(self.tailTime).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></WaveShaper>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</WaveShaper>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function WaveShaper.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'WaveShaper' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'WaveShaper' + ' {'
        if self.channelCountMode != 'max':
            result += " channelCountMode " +  '"' + self.channelCountMode + '"' + ""
        if self.channelInterpretation != 'speakers':
            result += " channelInterpretation " +  '"' + self.channelInterpretation + '"' + ""
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.description:
            result += " description " +  '"' + self.description + '"' + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.gain != 1:
            result += " gain " + SFFloat(self.gain).VRML() + ""
        if self.oversample != 'none':
            result += " oversample " +  '"' + self.oversample + '"' + ""
        if self.pauseTime != 0:
            result += " pauseTime " + SFTime(self.pauseTime).VRML() + ""
        if self.resumeTime != 0:
            result += " resumeTime " + SFTime(self.resumeTime).VRML() + ""
        if self.startTime != 0:
            result += " startTime " + SFTime(self.startTime).VRML() + ""
        if self.stopTime != 0:
            result += " stopTime " + SFTime(self.stopTime).VRML() + ""
        if self.tailTime != 0:
            result += " tailTime " + SFTime(self.tailTime).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class WindPhysicsModel(_X3DParticlePhysicsModelNode):
    """
    WindPhysicsModel applies a wind effect to the particles.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'WindPhysicsModel'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/particleSystems.html#WindPhysicsModel'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#WindPhysicsModel'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('direction', (1, 0, 0), FieldType.SFVec3f, AccessType.inputOutput, 'WindPhysicsModel'),
            ('enabled', True, FieldType.SFBool, AccessType.inputOutput, 'X3DParticlePhysicsModelNode'),
            ('gustiness', 0.1, FieldType.SFFloat, AccessType.inputOutput, 'WindPhysicsModel'),
            ('speed', 0.1, FieldType.SFFloat, AccessType.inputOutput, 'WindPhysicsModel'),
            ('turbulence', 0, FieldType.SFFloat, AccessType.inputOutput, 'WindPhysicsModel'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 direction=(1, 0, 0),
                 enabled=True,
                 gustiness=0.1,
                 speed=0.1,
                 turbulence=0,
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode WindPhysicsModel __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.direction = direction
        self.enabled = enabled
        self.gustiness = gustiness
        self.speed = speed
        self.turbulence = turbulence
    @property # getter - - - - - - - - - -
    def direction(self):
        """direction in which wind is travelling in the form of a normalized, unit vector."""
        return self.__direction
    @direction.setter
    def direction(self, direction):
        if  direction is None:
            direction = (1, 0, 0) # default
        assertValidSFVec3f(direction)
        self.__direction = direction
    @property # getter - - - - - - - - - -
    def enabled(self):
        """Enables/disables node operation."""
        return self.__enabled
    @enabled.setter
    def enabled(self, enabled):
        if  enabled is None:
            enabled = True # default
        assertValidSFBool(enabled)
        self.__enabled = enabled
    @property # getter - - - - - - - - - -
    def gustiness(self):
        """[0,+infinity) gustiness specifies how much wind speed varies from the average speed."""
        return self.__gustiness
    @gustiness.setter
    def gustiness(self, gustiness):
        if  gustiness is None:
            gustiness = 0.1 # default
        assertValidSFFloat(gustiness)
        assertNonNegative('gustiness', gustiness)
        self.__gustiness = gustiness
    @property # getter - - - - - - - - - -
    def speed(self):
        """[0,+infinity) Initial linear speed (default is m/s) imparted to all particles along their direction of movement."""
        return self.__speed
    @speed.setter
    def speed(self, speed):
        if  speed is None:
            speed = 0.1 # default
        assertValidSFFloat(speed)
        assertNonNegative('speed', speed)
        self.__speed = speed
    @property # getter - - - - - - - - - -
    def turbulence(self):
        """[0,1] turbulence field specifies how much the wind acts directly in line with the direction, and how much variation is applied in directions other than the wind direction."""
        return self.__turbulence
    @turbulence.setter
    def turbulence(self, turbulence):
        if  turbulence is None:
            turbulence = 0 # default
        assertValidSFFloat(turbulence)
        assertZeroToOne('turbulence', turbulence)
        self.__turbulence = turbulence
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function WindPhysicsModel.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<WindPhysicsModel'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.direction != (1, 0, 0):
            result += " direction='" + SFVec3f(self.direction).XML() + "'"
        if not self.enabled: # default=true
            result += " enabled='" + SFBool(self.enabled).XML() + "'"
        if self.gustiness != 0.1:
            result += " gustiness='" + SFFloat(self.gustiness).XML() + "'"
        if self.speed != 0.1:
            result += " speed='" + SFFloat(self.speed).XML() + "'"
        if self.turbulence != 0:
            result += " turbulence='" + SFFloat(self.turbulence).XML() + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></WindPhysicsModel>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</WindPhysicsModel>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function WindPhysicsModel.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'WindPhysicsModel' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'WindPhysicsModel' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.direction != (1, 0, 0):
            result += " direction " + SFVec3f(self.direction).VRML() + ""
        if not self.enabled: # default=true
            result += " enabled " + SFBool(self.enabled).VRML() + ""
        if self.gustiness != 0.1:
            result += " gustiness " + SFFloat(self.gustiness).VRML() + ""
        if self.speed != 0.1:
            result += " speed " + SFFloat(self.speed).VRML() + ""
        if self.turbulence != 0:
            result += " turbulence " + SFFloat(self.turbulence).VRML() + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

class WorldInfo(_X3DInfoNode):
    """
    WorldInfo contains a title and simple persistent metadata information about an X3D scene. This node is strictly for documentation purposes and has no effect on the visual appearance or behaviour of the world.
    """
    def NAME(self):
        ''' Name of this X3D Node class. '''
        return 'WorldInfo'
    def SPECIFICATION_URL(self):
        ''' Extensible 3D (X3D) Graphics International Standard governs X3D architecture for all file formats and programming languages. '''
        return 'https://www.web3d.org/specifications/X3Dv4Draft/ISO-IEC19775-1v4-WD2/Part01/components/core.html#WorldInfo'
    def TOOLTIP_URL(self):
        ''' X3D Tooltips provide authoring tips, hints and warnings for each node and field in X3D. '''
        return 'https://www.web3d.org/x3d/tooltips/X3dTooltips.html#WorldInfo'
    def FIELD_DECLARATIONS(self):
        ''' Field declarations for this node: name, defaultValue, type, accessType, inheritedFrom '''
        return [
            ('info', list(), FieldType.MFString, AccessType.inputOutput, 'WorldInfo'),
            ('title', '', FieldType.SFString, AccessType.inputOutput, 'WorldInfo'),
            ('DEF', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('USE', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('class_', '', FieldType.SFString, AccessType.inputOutput, 'X3DNode'),
            ('IS', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode'),
            ('metadata', None, FieldType.SFNode, AccessType.inputOutput, 'X3DNode')]
    def __init__(self,
                 info=list(),
                 title='',
                 DEF='',
                 USE='',
                 class_='',
                 IS=None,
                 metadata=None):
        # if _DEBUG: print('... in ConcreteNode WorldInfo __init__ calling super.__init__(' + str(DEF) + ',' + str(USE) + ',' + str(class_) + ',' + str(metadata) + ',' + str(IS) + ')', flush=True)
        super().__init__(DEF, USE, class_, IS, metadata) # fields for _X3DNode only
        self.info = info
        self.title = title
    @property # getter - - - - - - - - - -
    def info(self):
        """Additional information about this model."""
        return self.__info
    @info.setter
    def info(self, info):
        if  info is None:
            info = MFString.DEFAULT_VALUE(self)
        assertValidMFString(info)
        self.__info = info
    @property # getter - - - - - - - - - -
    def title(self):
        """title of this world, placed in window title."""
        return self.__title
    @title.setter
    def title(self, title):
        if  title is None:
            title = SFString.DEFAULT_VALUE(self)
        assertValidSFString(title)
        self.__title = title
    # hasChild() function - - - - - - - - - -
    def hasChild(self):
        ''' Whether or not this node has any child node, statement or comment '''
        return self.IS or self.metadata
    # output function - - - - - - - - - -
    def XML(self, indentLevel=0, syntax="XML"):
        """ Provide Canonical X3D output serialization using XML encoding. """
        result = ''
        indent = '  ' * indentLevel
        result = indent ### confirm
        # if _DEBUG: result += indent + '# invoked class function WorldInfo.XML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        result += '<WorldInfo'
        if self.DEF:
            result += " DEF='" + self.DEF + "'"
        if self.USE:
            result += " USE='" + self.USE + "'"
        if self.class_:
            result += " class_='" + self.class_ + "'"
        if self.info != list():
            result += " info='" + MFString(self.info).XML() + "'"
        if self.title:
            result += " title='" + self.title + "'"
        if not self.hasChild():
            if syntax.upper() == "HTML5":
                result += '></WorldInfo>' + '\n' # no self-closing tags allowed by HTML5
            elif syntax.upper() == "XML":
                result += '/>' + '\n' # singleton element
            else:
                raise X3DValueError('.toXML(syntax=' + syntax + ') is incorrect, allowed values are "HTML5" and "XML"')
        else:
            result += '>' + '\n'
            if self.IS: # output this SFNode
                result += self.IS.XML(indentLevel=indentLevel+1, syntax=syntax)
            if self.metadata: # output this SFNode
                result += self.metadata.XML(indentLevel=indentLevel+1, syntax=syntax)
            result += indent + '</WorldInfo>' + '\n'
#       print('XML serialization complete.', flush=True)
        return result
    # output function - - - - - - - - - -
    def HTML5(self, indentLevel=0):
        """ Provide HTML5 output serialization using XML encoding with no singleton self-closing elements. """
        return self.XML(indentLevel, syntax="HTML5")
    # output function - - - - - - - - - -
    def VRML(self, indentLevel=0, VRML97=False):
        """ Provide X3D output serialization using VRML encoding. """
        result = ''
        indent = '  ' * indentLevel
        # if _DEBUG: result += indent + '# invoked class function WorldInfo.VRML(self=' + str(self) + ', indentLevel=' + str(indentLevel) + '), indent="' + indent + '"'
        # print(result)
        if indentLevel == 0:
            result += '\n'
        if self.DEF:
            result += 'DEF ' + self.DEF + ' ' + 'WorldInfo' + ' {'
        elif self.USE:
            result += 'USE ' + self.USE # no node name, nothing follows
        else:
            result += 'WorldInfo' + ' {'
        if self.class_:
            result += " class_ " +  '"' + self.class_ + '"' + ""
        if self.info != list():
            result += " info " + MFString(self.info).VRML() + ""
        if self.title:
            result += " title " +  '"' + self.title + '"' + ""
        if self.IS: # output this SFNode
            result += '\n' + '  ' + indent + 'IS ' + self.IS.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if self.metadata: # output this SFNode
            result += '\n' + '  ' + indent + 'metadata ' + self.metadata.VRML(indentLevel=indentLevel+1, VRML97=VRML97)
        if not self.USE:
            result += ' }'
#       print('VRML serialization complete.', flush=True)
        return result

###############################################

# Exceptions

class X3DError(Exception):
    """ Base class for all exceptions raised by this module.
        Reference: X3D Scene Access Interface (SAI), 5.3 Error types
        https://www.web3d.org/documents/specifications/19775-2/V3.3/Part02/dataRef.html
    """

class X3DTypeError(X3DError):
    """ Type error for simple fields (SFBool, SFInt32, SFVec3f etc.) or contained nodes (SFNode, MFNode) according to content model."""

class X3DValueError(X3DError):
    """ Value error for a given X3D type."""

###############################################

# Python x3d Package Loading Complete

print("x3d.py package loaded, have fun with X3D Graphics!")

###############################################
